{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>Welcome to the Helm documentation. Helm is the package manager for Kubernetes, and you can read detailed background information in the CNCF Helm Project Journey report.</p>"},{"location":"#how-the-documentation-is-organized","title":"How the documentation is organized","text":"<p>Helm has a lot of documentation. A high-level overview of how it\u2019s organized will help you know where to look for certain things:</p> <ul> <li>Tutorials take you by the hand through a series of steps to create   your first Helm chart. Start here if you\u2019re new to Helm.</li> <li>Topic guides discuss key topics and concepts at a fairly high level   and provide useful background information and explanation.</li> <li>Community Guides discuss topics centered around Helm\u2019s community.   Start here if you want to learn more about the development process of Helm   itself and how you can contribute.</li> <li>How-to guides are recipes. They guide you through the steps involved   in addressing key problems and use-cases. They are more advanced than   tutorials and assume some knowledge of how Helm works.</li> </ul>"},{"location":"chart_best_practices/","title":"The Chart Best Practices Guide","text":"<p>This guide covers the Helm Team's considered best practices for creating charts. It focuses on how charts should be structured.</p> <p>We focus primarily on best practices for charts that may be publicly deployed. We know that many charts are for internal-use only, and authors of such charts may find that their internal interests override our suggestions here.</p>"},{"location":"chart_best_practices/conventions/","title":"General Conventions","text":"<p>This part of the Best Practices Guide explains general conventions.</p>"},{"location":"chart_best_practices/conventions/#chart-names","title":"Chart Names","text":"<p>Chart names must be lower case letters and numbers. Words may be separated with dashes (-):</p> <p>Examples:</p> <pre><code>drupal\nnginx-lego\naws-cluster-autoscaler\n</code></pre> <p>Neither uppercase letters nor underscores can be used in chart names. Dots should not be used in chart names.</p>"},{"location":"chart_best_practices/conventions/#version-numbers","title":"Version Numbers","text":"<p>Wherever possible, Helm uses SemVer 2 to represent version numbers. (Note that Docker image tags do not necessarily follow SemVer, and are thus considered an unfortunate exception to the rule.)</p> <p>When SemVer versions are stored in Kubernetes labels, we conventionally alter the <code>+</code> character to an <code>_</code> character, as labels do not allow the <code>+</code> sign as a value.</p>"},{"location":"chart_best_practices/conventions/#formatting-yaml","title":"Formatting YAML","text":"<p>YAML files should be indented using two spaces (and never tabs).</p>"},{"location":"chart_best_practices/conventions/#usage-of-the-words-helm-and-chart","title":"Usage of the Words Helm and Chart","text":"<p>There are a few conventions for using the words Helm and helm.</p> <ul> <li>Helm refers to the project as a whole</li> <li><code>helm</code> refers to the client-side command</li> <li>The term <code>chart</code> does not need to be capitalized, as it is not a proper noun</li> <li>However, <code>Chart.yaml</code> does need to be capitalized because the file name is   case sensitive</li> </ul> <p>When in doubt, use Helm (with an uppercase 'H').</p>"},{"location":"chart_best_practices/custom_resource_definitions/","title":"Custom Resource Definitions","text":"<p>This section of the Best Practices Guide deals with creating and using Custom Resource Definition objects.</p> <p>When working with Custom Resource Definitions (CRDs), it is important to distinguish two different pieces:</p> <ul> <li>There is a declaration of a CRD. This is the YAML file that has the kind   <code>CustomResourceDefinition</code></li> <li>Then there are resources that use the CRD. Say a CRD defines   <code>foo.example.com/v1</code>. Any resource that has <code>apiVersion: example.com/v1</code> and   kind <code>Foo</code> is a resource that uses the CRD.</li> </ul>"},{"location":"chart_best_practices/custom_resource_definitions/#install-a-crd-declaration-before-using-the-resource","title":"Install a CRD Declaration Before Using the Resource","text":"<p>Helm is optimized to load as many resources into Kubernetes as fast as possible. By design, Kubernetes can take an entire set of manifests and bring them all online (this is called the reconciliation loop).</p> <p>But there's a difference with CRDs.</p> <p>For a CRD, the declaration must be registered before any resources of that CRDs kind(s) can be used. And the registration process sometimes takes a few seconds.</p>"},{"location":"chart_best_practices/custom_resource_definitions/#method-1-let-helm-do-it-for-you","title":"Method 1: Let <code>helm</code> Do It For You","text":"<p>With the arrival of Helm 3, we removed the old <code>crd-install</code> hooks for a more simple methodology. There is now a special directory called <code>crds</code> that you can create in your chart to hold your CRDs. These CRDs are not templated, but will be installed by default when running a <code>helm install</code> for the chart. If the CRD already exists, it will be skipped with a warning. If you wish to skip the CRD installation step, you can pass the <code>--skip-crds</code> flag.</p>"},{"location":"chart_best_practices/custom_resource_definitions/#some-caveats-and-explanations","title":"Some caveats (and explanations)","text":"<p>There is no support at this time for upgrading or deleting CRDs using Helm. This was an explicit decision after much community discussion due to the danger for unintentional data loss. Furthermore, there is currently no community consensus around how to handle CRDs and their lifecycle. As this evolves, Helm will add support for those use cases.</p> <p>The <code>--dry-run</code> flag of <code>helm install</code> and <code>helm upgrade</code> is not currently supported for CRDs. The purpose of \"Dry Run\" is to validate that the output of the chart will actually work if sent to the server. But CRDs are a modification of the server's behavior. Helm cannot install the CRD on a dry run, so the discovery client will not know about that Custom Resource (CR), and validation will fail. You can alternatively move the CRDs to their own chart or use <code>helm template</code> instead.</p> <p>Another important point to consider in the discussion around CRD support is how the rendering of templates is handled. One of the distinct disadvantages of the <code>crd-install</code> method used in Helm 2 was the inability to properly validate charts due to changing API availability (a CRD is actually adding another available API to your Kubernetes cluster). If a chart installed a CRD, <code>helm</code> no longer had a valid set of API versions to work against. This is also the reason behind removing templating support from CRDs. With the new <code>crds</code> method of CRD installation, we now ensure that <code>helm</code> has completely valid information about the current state of the cluster.</p>"},{"location":"chart_best_practices/custom_resource_definitions/#method-2-separate-charts","title":"Method 2: Separate Charts","text":"<p>Another way to do this is to put the CRD definition in one chart, and then put any resources that use that CRD in another chart.</p> <p>In this method, each chart must be installed separately. However, this workflow may be more useful for cluster operators who have admin access to a cluster</p>"},{"location":"chart_best_practices/dependencies/","title":"Dependencies","text":"<p>This section of the guide covers best practices for <code>dependencies</code> declared in <code>Chart.yaml</code>.</p>"},{"location":"chart_best_practices/dependencies/#versions","title":"Versions","text":"<p>Where possible, use version ranges instead of pinning to an exact version. The suggested default is to use a patch-level version match:</p> <pre><code>version: ~1.2.3\n</code></pre> <p>This will match version <code>1.2.3</code> and any patches to that release.  In other words, <code>~1.2.3</code> is equivalent to <code>&gt;= 1.2.3, &lt; 1.3.0</code></p> <p>For the complete version matching syntax, please see the semver documentation.</p>"},{"location":"chart_best_practices/dependencies/#prerelease-versions","title":"Prerelease versions","text":"<p>The above versioning constraints will not match on pre-release versions. For example <code>version: ~1.2.3</code> will match <code>version: ~1.2.4</code> but not <code>version: ~1.2.3-1</code>. The following provides a pre-release as well as patch-level matching:</p> <pre><code>version: ~1.2.3-0\n</code></pre>"},{"location":"chart_best_practices/dependencies/#repository-urls","title":"Repository URLs","text":"<p>Where possible, use <code>https://</code> repository URLs, followed by <code>http://</code> URLs.</p> <p>If the repository has been added to the repository index file, the repository name can be used as an alias of URL. Use <code>alias:</code> or <code>@</code> followed by repository names.</p> <p>File URLs (<code>file://...</code>) are considered a \"special case\" for charts that are assembled by a fixed deployment pipeline.</p> <p>When using downloader plugins the URL scheme will be specific to the plugin. Note, a user of the chart will need to have a plugin supporting the scheme installed to update or build the dependency.</p> <p>Helm cannot perform dependency management operations on the dependency when the <code>repository</code> field is left blank. In that case Helm will assume the dependency is in a sub-directory of the <code>charts</code> folder with the name being the same as the <code>name</code> property for the dependency.</p>"},{"location":"chart_best_practices/dependencies/#conditions-and-tags","title":"Conditions and Tags","text":"<p>Conditions or tags should be added to any dependencies that are optional.</p> <p>The preferred form of a condition is:</p> <pre><code>condition: somechart.enabled\n</code></pre> <p>Where <code>somechart</code> is the chart name of the dependency.</p> <p>When multiple subcharts (dependencies) together provide an optional or swappable feature, those charts should share the same tags.</p> <p>For example, if both <code>nginx</code> and <code>memcached</code> together provide performance optimizations for the main app in the chart, and are required to both be present when that feature is enabled, then they should both have a tags section like this:</p> <pre><code>tags:\n  - webaccelerator\n</code></pre> <p>This allows a user to turn that feature on and off with one tag.</p>"},{"location":"chart_best_practices/labels/","title":"Labels and Annotations","text":"<p>This part of the Best Practices Guide discusses the best practices for using labels and annotations in your chart.</p>"},{"location":"chart_best_practices/labels/#is-it-a-label-or-an-annotation","title":"Is it a Label or an Annotation?","text":"<p>An item of metadata should be a label under the following conditions:</p> <ul> <li>It is used by Kubernetes to identify this resource</li> <li>It is useful to expose to operators for the purpose of querying the system.</li> </ul> <p>For example, we suggest using <code>helm.sh/chart: NAME-VERSION</code> as a label so that operators can conveniently find all of the instances of a particular chart to use.</p> <p>If an item of metadata is not used for querying, it should be set as an annotation instead.</p> <p>Helm hooks are always annotations.</p>"},{"location":"chart_best_practices/labels/#standard-labels","title":"Standard Labels","text":"<p>The following table defines common labels that Helm charts use. Helm itself never requires that a particular label be present. Labels that are marked REC are recommended, and should be placed onto a chart for global consistency. Those marked OPT are optional. These are idiomatic or commonly in use, but are not relied upon frequently for operational purposes.</p> Name Status Description <code>app.kubernetes.io/name</code> REC This should be the app name, reflecting the entire app. Usually <code>{{ template \"name\" . }}</code> is used for this. This is used by many Kubernetes manifests, and is not Helm-specific. <code>helm.sh/chart</code> REC This should be the chart name and version: <code>{{ .Chart.Name }}-{{ .Chart.Version \\| replace \"+\" \"_\" }}</code>. <code>app.kubernetes.io/managed-by</code> REC This should always be set to <code>{{ .Release.Service }}</code>. It is for finding all things managed by Helm. <code>app.kubernetes.io/instance</code> REC This should be the <code>{{ .Release.Name }}</code>. It aids in differentiating between different instances of the same application. <code>app.kubernetes.io/version</code> OPT The version of the app and can be set to <code>{{ .Chart.AppVersion }}</code>. <code>app.kubernetes.io/component</code> OPT This is a common label for marking the different roles that pieces may play in an application. For example, <code>app.kubernetes.io/component: frontend</code>. <code>app.kubernetes.io/part-of</code> OPT When multiple charts or pieces of software are used together to make one application. For example, application software and a database to produce a website. This can be set to the top level application being supported. <p>You can find more information on the Kubernetes labels, prefixed with <code>app.kubernetes.io</code>, in the Kubernetes documentation.</p>"},{"location":"chart_best_practices/pods/","title":"Pods and PodTemplates","text":"<p>This part of the Best Practices Guide discusses formatting the Pod and PodTemplate portions in chart manifests.</p> <p>The following (non-exhaustive) list of resources use PodTemplates:</p> <ul> <li>Deployment</li> <li>ReplicationController</li> <li>ReplicaSet</li> <li>DaemonSet</li> <li>StatefulSet</li> </ul>"},{"location":"chart_best_practices/pods/#images","title":"Images","text":"<p>A container image should use a fixed tag or the SHA of the image. It should not use the tags <code>latest</code>, <code>head</code>, <code>canary</code>, or other tags that are designed to be \"floating\".</p> <p>Images may be defined in the <code>values.yaml</code> file to make it easy to swap out images.</p> <pre><code>image: {{ .Values.redisImage | quote }}\n</code></pre> <p>An image and a tag may be defined in <code>values.yaml</code> as two separate fields:</p> <pre><code>image: \"{{ .Values.redisImage }}:{{ .Values.redisTag }}\"\n</code></pre>"},{"location":"chart_best_practices/pods/#imagepullpolicy","title":"ImagePullPolicy","text":"<p><code>helm create</code> sets the <code>imagePullPolicy</code> to <code>IfNotPresent</code> by default by doing the following in your <code>deployment.yaml</code>:</p> <pre><code>imagePullPolicy: {{ .Values.image.pullPolicy }}\n</code></pre> <p>And <code>values.yaml</code>:</p> <pre><code>image:\n  pullPolicy: IfNotPresent\n</code></pre> <p>Similarly, Kubernetes defaults the <code>imagePullPolicy</code> to <code>IfNotPresent</code> if it is not defined at all. If you want a value other than <code>IfNotPresent</code>, simply update the value in <code>values.yaml</code> to your desired value.</p>"},{"location":"chart_best_practices/pods/#podtemplates-should-declare-selectors","title":"PodTemplates Should Declare Selectors","text":"<p>All PodTemplate sections should specify a selector. For example:</p> <pre><code>selector:\n  matchLabels:\n      app.kubernetes.io/name: MyName\ntemplate:\n  metadata:\n    labels:\n      app.kubernetes.io/name: MyName\n</code></pre> <p>This is a good practice because it makes the relationship between the set and the pod.</p> <p>But this is even more important for sets like Deployment. Without this, the entire set of labels is used to select matching pods, and this will break if you use labels that change, like version or release date.</p>"},{"location":"chart_best_practices/rbac/","title":"Role-Based Access Control","text":"<p>This part of the Best Practices Guide discusses the creation and formatting of RBAC resources in chart manifests.</p> <p>RBAC resources are:</p> <ul> <li>ServiceAccount (namespaced)</li> <li>Role (namespaced)</li> <li>ClusterRole</li> <li>RoleBinding (namespaced)</li> <li>ClusterRoleBinding</li> </ul>"},{"location":"chart_best_practices/rbac/#yaml-configuration","title":"YAML Configuration","text":"<p>RBAC and ServiceAccount configuration should happen under separate keys. They are separate things. Splitting these two concepts out in the YAML disambiguates them and makes this clearer.</p> <pre><code>rbac:\n  # Specifies whether RBAC resources should be created\n  create: true\n\nserviceAccount:\n  # Specifies whether a ServiceAccount should be created\n  create: true\n  # The name of the ServiceAccount to use.\n  # If not set and create is true, a name is generated using the fullname template\n  name:\n</code></pre> <p>This structure can be extended for more complex charts that require multiple ServiceAccounts.</p> <pre><code>someComponent:\n  serviceAccount:\n    create: true\n    name:\nanotherComponent:\n  serviceAccount:\n    create: true\n    name:\n</code></pre>"},{"location":"chart_best_practices/rbac/#rbac-resources-should-be-created-by-default","title":"RBAC Resources Should be Created by Default","text":"<p><code>rbac.create</code> should be a boolean value controlling whether RBAC resources are created.  The default should be <code>true</code>.  Users who wish to manage RBAC access controls themselves can set this value to <code>false</code> (in which case see below).</p>"},{"location":"chart_best_practices/rbac/#using-rbac-resources","title":"Using RBAC Resources","text":"<p><code>serviceAccount.name</code> should be set to the name of the ServiceAccount to be used by access-controlled resources created by the chart.  If <code>serviceAccount.create</code> is true, then a ServiceAccount with this name should be created.  If the name is not set, then a name is generated using the <code>fullname</code> template, If <code>serviceAccount.create</code> is false, then it should not be created, but it should still be associated with the same resources so that manually-created RBAC resources created later that reference it will function correctly.  If <code>serviceAccount.create</code> is false and the name is not specified, then the default ServiceAccount is used.</p> <p>The following helper template should be used for the ServiceAccount.</p> <pre><code>{{/*\nCreate the name of the service account to use\n*/}}\n{{- define \"mychart.serviceAccountName\" -}}\n{{- if .Values.serviceAccount.create -}}\n    {{ default (include \"mychart.fullname\" .) .Values.serviceAccount.name }}\n{{- else -}}\n    {{ default \"default\" .Values.serviceAccount.name }}\n{{- end -}}\n{{- end -}}\n</code></pre>"},{"location":"chart_best_practices/templates/","title":"Templates","text":"<p>This part of the Best Practices Guide focuses on templates.</p>"},{"location":"chart_best_practices/templates/#structure-of-templates","title":"Structure of <code>templates/</code>","text":"<p>The <code>templates/</code> directory should be structured as follows:</p> <ul> <li>Template files should have the extension <code>.yaml</code> if they produce YAML output.   The extension <code>.tpl</code> may be used for template files that produce no formatted   content.</li> <li>Template file names should use dashed notation (<code>my-example-configmap.yaml</code>),   not camelcase.</li> <li>Each resource definition should be in its own template file.</li> <li>Template file names should reflect the resource kind in the name. e.g.   <code>foo-pod.yaml</code>, <code>bar-svc.yaml</code></li> </ul>"},{"location":"chart_best_practices/templates/#names-of-defined-templates","title":"Names of Defined Templates","text":"<p>Defined templates (templates created inside a <code>{{ define }}</code> directive) are globally accessible. That means that a chart and all of its subcharts will have access to all of the templates created with <code>{{ define }}</code>.</p> <p>For that reason, all defined template names should be namespaced.</p> <p>Correct:</p> <pre><code>{{- define \"nginx.fullname\" }}\n{{/* ... */}}\n{{ end -}}\n</code></pre> <p>Incorrect:</p> <pre><code>{{- define \"fullname\" -}}\n{{/* ... */}}\n{{ end -}}\n</code></pre> <p>It is highly recommended that new charts are created via <code>helm create</code> command as the template names are automatically defined as per this best practice.</p>"},{"location":"chart_best_practices/templates/#formatting-templates","title":"Formatting Templates","text":"<p>Templates should be indented using two spaces (never tabs).</p> <p>Template directives should have whitespace after the opening  braces and before the closing braces:</p> <p>Correct:</p> <pre><code>{{ .foo }}\n{{ print \"foo\" }}\n{{- print \"bar\" -}}\n</code></pre> <p>Incorrect:</p> <pre><code>{{.foo}}\n{{print \"foo\"}}\n{{-print \"bar\"-}}\n</code></pre> <p>Templates should chomp whitespace where possible:</p> <pre><code>foo:\n  {{- range .Values.items }}\n  {{ . }}\n  {{ end -}}\n</code></pre> <p>Blocks (such as control structures) may be indented to indicate flow of the template code.</p> <pre><code>{{ if $foo -}}\n  {{- with .Bar }}Hello{{ end -}}\n{{- end -}}\n</code></pre> <p>However, since YAML is a whitespace-oriented language, it is often not possible for code indentation to follow that convention.</p>"},{"location":"chart_best_practices/templates/#whitespace-in-generated-templates","title":"Whitespace in Generated Templates","text":"<p>It is preferable to keep the amount of whitespace in generated templates to a minimum. In particular, numerous blank lines should not appear adjacent to each other. But occasional empty lines (particularly between logical sections) is fine.</p> <p>This is best:</p> <pre><code>apiVersion: batch/v1\nkind: Job\nmetadata:\n  name: example\n  labels:\n    first: first\n    second: second\n</code></pre> <p>This is okay:</p> <pre><code>apiVersion: batch/v1\nkind: Job\n\nmetadata:\n  name: example\n\n  labels:\n    first: first\n    second: second\n\n</code></pre> <p>But this should be avoided:</p> <pre><code>apiVersion: batch/v1\nkind: Job\n\nmetadata:\n  name: example\n\n\n\n\n\n  labels:\n    first: first\n\n    second: second\n\n</code></pre>"},{"location":"chart_best_practices/templates/#comments-yaml-comments-vs-template-comments","title":"Comments (YAML Comments vs. Template Comments)","text":"<p>Both YAML and Helm Templates have comment markers.</p> <p>YAML comments:</p> <pre><code># This is a comment\ntype: sprocket\n</code></pre> <p>Template Comments:</p> <pre><code>{{- /*\nThis is a comment.\n*/}}\ntype: frobnitz\n</code></pre> <p>Template comments should be used when documenting features of a template, such as explaining a defined template:</p> <pre><code>{{- /*\nmychart.shortname provides a 6 char truncated version of the release name.\n*/}}\n{{ define \"mychart.shortname\" -}}\n{{ .Release.Name | trunc 6 }}\n{{- end -}}\n\n</code></pre> <p>Inside of templates, YAML comments may be used when it is useful for Helm users to (possibly) see the comments during debugging.</p> <pre><code># This may cause problems if the value is more than 100Gi\nmemory: {{ .Values.maxMem | quote }}\n</code></pre> <p>The comment above is visible when the user runs <code>helm install --debug</code>, while comments specified in <code>{{- /* */}}</code> sections are not.</p> <p>Beware of adding <code>#</code> YAML comments on template sections containing Helm values that may be required by certain template functions.</p> <p>For example, if <code>required</code> function is introduced to the above example, and <code>maxMem</code> is unset, then a <code>#</code> YAML comment will introduce a rendering error.</p> <p>Correct: <code>helm template</code> does not render this block</p> <pre><code>{{- /*\n# This may cause problems if the value is more than 100Gi\nmemory: {{ required \"maxMem must be set\" .Values.maxMem | quote }}\n*/ -}}\n</code></pre> <p>Incorrect: <code>helm template</code> returns <code>Error: execution error at (templates/test.yaml:2:13): maxMem must be set</code></p> <pre><code># This may cause problems if the value is more than 100Gi\n# memory: {{ required .Values.maxMem \"maxMem must be set\" | quote }}\n</code></pre> <p>Review Debugging Templates for another example of this behavior of how YAML comments are left intact.</p>"},{"location":"chart_best_practices/templates/#use-of-json-in-templates-and-template-output","title":"Use of JSON in Templates and Template Output","text":"<p>YAML is a superset of JSON. In some cases, using a JSON syntax can be more readable than other YAML representations.</p> <p>For example, this YAML is closer to the normal YAML method of expressing lists:</p> <pre><code>arguments:\n  - \"--dirname\"\n  - \"/foo\"\n</code></pre> <p>But it is easier to read when collapsed into a JSON list style:</p> <pre><code>arguments: [\"--dirname\", \"/foo\"]\n</code></pre> <p>Using JSON for increased legibility is good. However, JSON syntax should not be used for representing more complex constructs.</p> <p>When dealing with pure JSON embedded inside of YAML (such as init container configuration), it is of course appropriate to use the JSON format.</p>"},{"location":"chart_best_practices/values/","title":"Values","text":"<p>This part of the best practices guide covers using values. In this part of the guide, we provide recommendations on how you should structure and use your values, with focus on designing a chart's <code>values.yaml</code> file.</p>"},{"location":"chart_best_practices/values/#naming-conventions","title":"Naming Conventions","text":"<p>Variable names should begin with a lowercase letter, and words should be separated with camelcase:</p> <p>Correct:</p> <pre><code>chicken: true\nchickenNoodleSoup: true\n</code></pre> <p>Incorrect:</p> <pre><code>Chicken: true  # initial caps may conflict with built-ins\nchicken-noodle-soup: true # do not use hyphens in the name\n</code></pre> <p>Note that all of Helm's built-in variables begin with an uppercase letter to easily distinguish them from user-defined values: <code>.Release.Name</code>, <code>.Capabilities.KubeVersion</code>.</p>"},{"location":"chart_best_practices/values/#flat-or-nested-values","title":"Flat or Nested Values","text":"<p>YAML is a flexible format, and values may be nested deeply or flattened.</p> <p>Nested:</p> <pre><code>server:\n  name: nginx\n  port: 80\n</code></pre> <p>Flat:</p> <pre><code>serverName: nginx\nserverPort: 80\n</code></pre> <p>In most cases, flat should be favored over nested. The reason for this is that it is simpler for template developers and users.</p> <p>For optimal safety, a nested value must be checked at every level:</p> <pre><code>{{ if .Values.server }}\n  {{ default \"none\" .Values.server.name }}\n{{ end }}\n</code></pre> <p>For every layer of nesting, an existence check must be done. But for flat configuration, such checks can be skipped, making the template easier to read and use.</p> <pre><code>{{ default \"none\" .Values.serverName }}\n</code></pre> <p>When there are a large number of related variables, and at least one of them is non-optional, nested values may be used to improve readability.</p>"},{"location":"chart_best_practices/values/#make-types-clear","title":"Make Types Clear","text":"<p>YAML's type coercion rules are sometimes counterintuitive. For example, <code>foo: false</code> is not the same as <code>foo: \"false\"</code>. Large integers like <code>foo: 12345678</code> will get converted to scientific notation in some cases.</p> <p>The easiest way to avoid type conversion errors is to be explicit about strings, and implicit about everything else. Or, in short, quote all strings.</p> <p>Often, to avoid the integer casting issues, it is advantageous to store your integers as strings as well, and use <code>{{ int $value }}</code> in the template to convert from a string back to an integer.</p> <p>In most cases, explicit type tags are respected, so <code>foo: !!string 1234</code> should treat <code>1234</code> as a string. However, the YAML parser consumes tags, so the type data is lost after one parse.</p>"},{"location":"chart_best_practices/values/#consider-how-users-will-use-your-values","title":"Consider How Users Will Use Your Values","text":"<p>There are three potential sources of values:</p> <ul> <li>A chart's <code>values.yaml</code> file</li> <li>A values file supplied by <code>helm install -f</code> or <code>helm upgrade -f</code></li> <li>The values passed to a <code>--set</code> or <code>--set-string</code> flag on <code>helm install</code> or   <code>helm upgrade</code></li> </ul> <p>When designing the structure of your values, keep in mind that users of your chart may want to override them via either the <code>-f</code> flag or with the <code>--set</code> option.</p> <p>Since <code>--set</code> is more limited in expressiveness, the first guidelines for writing your <code>values.yaml</code> file is make it easy to override from <code>--set</code>.</p> <p>For this reason, it's often better to structure your values file using maps.</p> <p>Difficult to use with <code>--set</code>:</p> <pre><code>servers:\n  - name: foo\n    port: 80\n  - name: bar\n    port: 81\n</code></pre> <p>The above cannot be expressed with <code>--set</code> in Helm <code>&lt;=2.4</code>. In Helm 2.5, accessing the port on foo is <code>--set servers[0].port=80</code>. Not only is it harder for the user to figure out, but it is prone to errors if at some later time the order of the <code>servers</code> is changed.</p> <p>Easy to use:</p> <pre><code>servers:\n  foo:\n    port: 80\n  bar:\n    port: 81\n</code></pre> <p>Accessing foo's port is much more obvious: <code>--set servers.foo.port=80</code>.</p>"},{"location":"chart_best_practices/values/#document-valuesyaml","title":"Document <code>values.yaml</code>","text":"<p>Every defined property in <code>values.yaml</code> should be documented. The documentation string should begin with the name of the property that it describes, and then give at least a one-sentence description.</p> <p>Incorrect:</p> <pre><code># the host name for the webserver\nserverHost: example\nserverPort: 9191\n</code></pre> <p>Correct:</p> <pre><code># serverHost is the host name for the webserver\nserverHost: example\n# serverPort is the HTTP listener port for the webserver\nserverPort: 9191\n</code></pre> <p>Beginning each comment with the name of the parameter it documents makes it easy to grep out documentation, and will enable documentation tools to reliably correlate doc strings with the parameters they describe.</p>"},{"location":"chart_template_guide/","title":"The Chart Template Developer's Guide","text":"<p>This guide provides an introduction to Helm's chart templates, with emphasis on the template language.</p> <p>Templates generate manifest files, which are YAML-formatted resource descriptions that Kubernetes can understand. We'll look at how templates are structured, how they can be used, how to write Go templates, and how to debug your work.</p> <p>This guide focuses on the following concepts:</p> <ul> <li>The Helm template language</li> <li>Using values</li> <li>Techniques for working with templates</li> </ul> <p>This guide is oriented toward learning the ins and outs of the Helm template language. Other guides provide introductory material, examples, and best practices.</p>"},{"location":"chart_template_guide/accessing_files/","title":"Accessing Files Inside Templates","text":"<p>In the previous section we looked at several ways to create and access named templates. This makes it easy to import one template from within another template. But sometimes it is desirable to import a file that is not a template and inject its contents without sending the contents through the template renderer.</p> <p>Helm provides access to files through the <code>.Files</code> object. Before we get going with the template examples, though, there are a few things to note about how this works:</p> <ul> <li>It is okay to add extra files to your Helm chart. These files will be bundled.   Be careful, though. Charts must be smaller than 1M because of the storage   limitations of Kubernetes objects.</li> <li>Some files cannot be accessed through the <code>.Files</code> object, usually for   security reasons.</li> <li>Files in <code>templates/</code> cannot be accessed.</li> <li>Files excluded using <code>.helmignore</code> cannot be accessed.</li> <li>Files outside of a Helm application subchart, including those of the parent, cannot be accessed</li> <li>Charts do not preserve UNIX mode information, so file-level permissions will   have no impact on the availability of a file when it comes to the <code>.Files</code>   object.</li> </ul> <ul> <li>Basic example</li> <li>Path helpers</li> <li>Glob patterns</li> <li>ConfigMap and Secrets utility functions</li> <li>Encoding</li> <li>Lines</li> </ul>"},{"location":"chart_template_guide/accessing_files/#basic-example","title":"Basic example","text":"<p>With those caveats behind, let's write a template that reads three files into our ConfigMap. To get started, we will add three files to the chart, putting all three directly inside of the <code>mychart/</code> directory.</p> <p><code>config1.toml</code>:</p> <pre><code>message = Hello from config 1\n</code></pre> <p><code>config2.toml</code>:</p> <pre><code>message = This is config 2\n</code></pre> <p><code>config3.toml</code>:</p> <pre><code>message = Goodbye from config 3\n</code></pre> <p>Each of these is a simple TOML file (think old-school Windows INI files). We know the names of these files, so we can use a <code>range</code> function to loop through them and inject their contents into our ConfigMap.</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: {{ .Release.Name }}-configmap\ndata:\n  {{- $files := .Files }}\n  {{- range tuple \"config1.toml\" \"config2.toml\" \"config3.toml\" }}\n  {{ . }}: |-\n    {{ $files.Get . }}\n  {{- end }}\n</code></pre> <p>This ConfigMap uses several of the techniques discussed in previous sections. For example, we create a <code>$files</code> variable to hold a reference to the <code>.Files</code> object. We also use the <code>tuple</code> function to create a list of files that we loop through. Then we print each file name (<code>{{ . }}: |-</code>) followed by the contents of the file <code>{{ $files.Get . }}</code>.</p> <p>Running this template will produce a single ConfigMap with the contents of all three files:</p> <pre><code># Source: mychart/templates/configmap.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: quieting-giraf-configmap\ndata:\n  config1.toml: |-\n    message = Hello from config 1\n\n  config2.toml: |-\n    message = This is config 2\n\n  config3.toml: |-\n    message = Goodbye from config 3\n</code></pre>"},{"location":"chart_template_guide/accessing_files/#path-helpers","title":"Path helpers","text":"<p>When working with files, it can be very useful to perform some standard operations on the file paths themselves. To help with this, Helm imports many of the functions from Go's path package for your use. They are all accessible with the same names as in the Go package, but with a lowercase first letter. For example, <code>Base</code> becomes <code>base</code>, etc.</p> <p>The imported functions are: - Base - Dir - Ext - IsAbs - Clean</p>"},{"location":"chart_template_guide/accessing_files/#glob-patterns","title":"Glob patterns","text":"<p>As your chart grows, you may find you have a greater need to organize your files more, and so we provide a <code>Files.Glob(pattern string)</code> method to assist in extracting certain files with all the flexibility of glob patterns.</p> <p><code>.Glob</code> returns a <code>Files</code> type, so you may call any of the <code>Files</code> methods on the returned object.</p> <p>For example, imagine the directory structure:</p> <pre><code>foo/:\n  foo.txt foo.yaml\n\nbar/:\n  bar.go bar.conf baz.yaml\n</code></pre> <p>You have multiple options with Globs:</p> <pre><code>{{ $currentScope := .}}\n{{ range $path, $_ :=  .Files.Glob  \"**.yaml\" }}\n    {{- with $currentScope}}\n        {{ .Files.Get $path }}\n    {{- end }}\n{{ end }}\n</code></pre> <p>Or</p> <pre><code>{{ range $path, $_ :=  .Files.Glob  \"**.yaml\" }}\n      {{ $.Files.Get $path }}\n{{ end }}\n</code></pre>"},{"location":"chart_template_guide/accessing_files/#configmap-and-secrets-utility-functions","title":"ConfigMap and Secrets utility functions","text":"<p>(Available Helm 2.0.2 and after)</p> <p>It is very common to want to place file content into both ConfigMaps and Secrets, for mounting into your pods at run time. To help with this, we provide a couple utility methods on the <code>Files</code> type.</p> <p>For further organization, it is especially useful to use these methods in conjunction with the <code>Glob</code> method.</p> <p>Given the directory structure from the Glob example above:</p> <pre><code>---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: conf\ndata:\n{{ (.Files.Glob \"foo/*\").AsConfig | indent 2 }}\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: very-secret\ntype: Opaque\ndata:\n{{ (.Files.Glob \"bar/*\").AsSecrets | indent 2 }}\n</code></pre>"},{"location":"chart_template_guide/accessing_files/#encoding","title":"Encoding","text":"<p>You can import a file and have the template base-64 encode it to ensure successful transmission:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: {{ .Release.Name }}-secret\ntype: Opaque\ndata:\n  token: |-\n    {{ .Files.Get \"config1.toml\" | b64enc }}\n</code></pre> <p>The above will take the same <code>config1.toml</code> file we used before and encode it:</p> <pre><code># Source: mychart/templates/secret.yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  name: lucky-turkey-secret\ntype: Opaque\ndata:\n  token: |-\n    bWVzc2FnZSA9IEhlbGxvIGZyb20gY29uZmlnIDEK\n</code></pre>"},{"location":"chart_template_guide/accessing_files/#lines","title":"Lines","text":"<p>Sometimes it is desirable to access each line of a file in your template. We provide a convenient <code>Lines</code> method for this.</p> <p>You can loop through <code>Lines</code> using a <code>range</code> function:</p> <pre><code>data:\n  some-file.txt: {{ range .Files.Lines \"foo/bar.txt\" }}\n    {{ . }}{{ end }}\n</code></pre> <p>There is no way to pass files external to the chart during <code>helm install</code>. So if you are asking users to supply data, it must be loaded using <code>helm install -f</code> or <code>helm install --set</code>.</p> <p>This discussion wraps up our dive into the tools and techniques for writing Helm templates. In the next section we will see how you can use one special file, <code>templates/NOTES.txt</code>, to send post-installation instructions to the users of your chart.</p>"},{"location":"chart_template_guide/builtin_objects/","title":"Built-in Objects","text":"<p>Objects are passed into a template from the template engine. And your code can pass objects around (we'll see examples when we look at the <code>with</code> and <code>range</code> statements). There are even a few ways to create new objects within your templates, like with the <code>tuple</code> function we'll see later.</p> <p>Objects can be simple, and have just one value. Or they can contain other objects or functions. For example, the <code>Release</code> object contains several objects (like <code>Release.Name</code>) and the <code>Files</code> object has a few functions.</p> <p>In the previous section, we use <code>{{ .Release.Name }}</code> to insert the name of a release into a template. <code>Release</code> is one of the top-level objects that you can access in your templates.</p> <ul> <li><code>Release</code>: This object describes the release itself. It has several objects   inside of it:</li> <li><code>Release.Name</code>: The release name</li> <li><code>Release.Namespace</code>: The namespace to be released into (if the manifest     doesn\u2019t override)</li> <li><code>Release.IsUpgrade</code>: This is set to <code>true</code> if the current operation is an     upgrade or rollback.</li> <li><code>Release.IsInstall</code>: This is set to <code>true</code> if the current operation is an     install.</li> <li><code>Release.Revision</code>: The revision number for this release. On install, this     is 1, and it is incremented with each upgrade and rollback.</li> <li><code>Release.Service</code>: The service that is rendering the present template. On     Helm, this is always <code>Helm</code>.</li> <li><code>Values</code>: Values passed into the template from the <code>values.yaml</code> file and from   user-supplied files. By default, <code>Values</code> is empty.</li> <li><code>Chart</code>: The contents of the <code>Chart.yaml</code> file. Any data in <code>Chart.yaml</code> will   be accessible here. For example <code>{{ .Chart.Name }}-{{ .Chart.Version }}</code> will   print out the <code>mychart-0.1.0</code>.</li> <li>The available fields are listed in the Charts Guide</li> <li><code>Subcharts</code>: This provides access to the scope (.Values, .Charts, .Releases etc.)   of subcharts to the parent. For example <code>.Subcharts.mySubChart.myValue</code> to access   the <code>myValue</code> in the <code>mySubChart</code> chart.</li> <li><code>Files</code>: This provides access to all non-special files in a chart. While you   cannot use it to access templates, you can use it to access other files in the   chart. See the section Accessing Files for more.</li> <li><code>Files.Get</code> is a function for getting a file by name (<code>.Files.Get     config.ini</code>)</li> <li><code>Files.GetBytes</code> is a function for getting the contents of a file as an     array of bytes instead of as a string. This is useful for things like     images.</li> <li><code>Files.Glob</code> is a function that returns a list of files whose names match     the given shell glob pattern.</li> <li><code>Files.Lines</code> is a function that reads a file line-by-line. This is useful     for iterating over each line in a file.</li> <li><code>Files.AsSecrets</code> is a function that returns the file bodies as Base 64     encoded strings.</li> <li><code>Files.AsConfig</code> is a function that returns file bodies as a YAML map.</li> <li><code>Capabilities</code>: This provides information about what capabilities the   Kubernetes cluster supports.</li> <li><code>Capabilities.APIVersions</code> is a set of versions.</li> <li><code>Capabilities.APIVersions.Has $version</code> indicates whether a version (e.g.,     <code>batch/v1</code>) or resource (e.g., <code>apps/v1/Deployment</code>) is available on the     cluster.</li> <li><code>Capabilities.KubeVersion</code> and <code>Capabilities.KubeVersion.Version</code> is the     Kubernetes version.</li> <li><code>Capabilities.KubeVersion.Major</code> is the Kubernetes major version.</li> <li><code>Capabilities.KubeVersion.Minor</code> is the Kubernetes minor version.</li> <li><code>Capabilities.HelmVersion</code> is the object containing the Helm Version details, it is the same output of <code>helm version</code>.</li> <li><code>Capabilities.HelmVersion.Version</code> is the current Helm version in semver format.</li> <li><code>Capabilities.HelmVersion.GitCommit</code> is the Helm git sha1.</li> <li><code>Capabilities.HelmVersion.GitTreeState</code> is the state of the Helm git tree.</li> <li><code>Capabilities.HelmVersion.GoVersion</code> is the version of the Go compiler used.</li> <li><code>Template</code>: Contains information about the current template that is being   executed</li> <li><code>Template.Name</code>: A namespaced file path to the current template (e.g.     <code>mychart/templates/mytemplate.yaml</code>)</li> <li><code>Template.BasePath</code>: The namespaced path to the templates directory of the current     chart (e.g. <code>mychart/templates</code>).</li> </ul> <p>The built-in values always begin with a capital letter. This is in keeping with Go's naming convention. When you create your own names, you are free to use a convention that suits your team. Some teams, like many whose charts you may see on Artifact Hub, choose to use only initial lower case letters in order to distinguish local names from those built-in. In this guide, we follow that convention.</p>"},{"location":"chart_template_guide/control_structures/","title":"Flow Control","text":"<p>Control structures (called \"actions\" in template parlance) provide you, the template author, with the ability to control the flow of a template's generation. Helm's template language provides the following control structures:</p> <ul> <li><code>if</code>/<code>else</code> for creating conditional blocks</li> <li><code>with</code> to specify a scope</li> <li><code>range</code>, which provides a \"for each\"-style loop</li> </ul> <p>In addition to these, it provides a few actions for declaring and using named template segments:</p> <ul> <li><code>define</code> declares a new named template inside of your template</li> <li><code>template</code> imports a named template</li> <li><code>block</code> declares a special kind of fillable template area</li> </ul> <p>In this section, we'll talk about <code>if</code>, <code>with</code>, and <code>range</code>. The others are covered in the \"Named Templates\" section later in this guide.</p>"},{"location":"chart_template_guide/control_structures/#ifelse","title":"If/Else","text":"<p>The first control structure we'll look at is for conditionally including blocks of text in a template. This is the <code>if</code>/<code>else</code> block.</p> <p>The basic structure for a conditional looks like this:</p> <pre><code>{{ if PIPELINE }}\n  # Do something\n{{ else if OTHER PIPELINE }}\n  # Do something else\n{{ else }}\n  # Default case\n{{ end }}\n</code></pre> <p>Notice that we're now talking about pipelines instead of values. The reason for this is to make it clear that control structures can execute an entire pipeline, not just evaluate a value.</p> <p>A pipeline is evaluated as false if the value is:</p> <ul> <li>a boolean false</li> <li>a numeric zero</li> <li>an empty string</li> <li>a <code>nil</code> (empty or null)</li> <li>an empty collection (<code>map</code>, <code>slice</code>, <code>tuple</code>, <code>dict</code>, <code>array</code>)</li> </ul> <p>Under all other conditions, the condition is true.</p> <p>Let's add a simple conditional to our ConfigMap. We'll add another setting if the drink is set to coffee:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: {{ .Release.Name }}-configmap\ndata:\n  myvalue: \"Hello World\"\n  drink: {{ .Values.favorite.drink | default \"tea\" | quote }}\n  food: {{ .Values.favorite.food | upper | quote }}\n  {{ if eq .Values.favorite.drink \"coffee\" }}mug: \"true\"{{ end }}\n</code></pre> <p>Since we commented out <code>drink: coffee</code> in our last example, the output should not include a <code>mug: \"true\"</code> flag. But if we add that line back into our <code>values.yaml</code> file, the output should look like this:</p> <pre><code># Source: mychart/templates/configmap.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: eyewitness-elk-configmap\ndata:\n  myvalue: \"Hello World\"\n  drink: \"coffee\"\n  food: \"PIZZA\"\n  mug: \"true\"\n</code></pre>"},{"location":"chart_template_guide/control_structures/#controlling-whitespace","title":"Controlling Whitespace","text":"<p>While we're looking at conditionals, we should take a quick look at the way whitespace is controlled in templates. Let's take the previous example and format it to be a little easier to read:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: {{ .Release.Name }}-configmap\ndata:\n  myvalue: \"Hello World\"\n  drink: {{ .Values.favorite.drink | default \"tea\" | quote }}\n  food: {{ .Values.favorite.food | upper | quote }}\n  {{ if eq .Values.favorite.drink \"coffee\" }}\n    mug: \"true\"\n  {{ end }}\n</code></pre> <p>Initially, this looks good. But if we run it through the template engine, we'll get an unfortunate result:</p> <pre><code>$ helm install --dry-run --debug ./mychart\nSERVER: \"localhost:44134\"\nCHART PATH: /Users/mattbutcher/Code/Go/src/helm.sh/helm/_scratch/mychart\nError: YAML parse error on mychart/templates/configmap.yaml: error converting YAML to JSON: yaml: line 9: did not find expected key\n</code></pre> <p>What happened? We generated incorrect YAML because of the whitespacing above.</p> <pre><code># Source: mychart/templates/configmap.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: eyewitness-elk-configmap\ndata:\n  myvalue: \"Hello World\"\n  drink: \"coffee\"\n  food: \"PIZZA\"\n    mug: \"true\"\n</code></pre> <p><code>mug</code> is incorrectly indented. Let's simply out-dent that one line, and re-run:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: {{ .Release.Name }}-configmap\ndata:\n  myvalue: \"Hello World\"\n  drink: {{ .Values.favorite.drink | default \"tea\" | quote }}\n  food: {{ .Values.favorite.food | upper | quote }}\n  {{ if eq .Values.favorite.drink \"coffee\" }}\n  mug: \"true\"\n  {{ end }}\n</code></pre> <p>When we sent that, we'll get YAML that is valid, but still looks a little funny:</p> <pre><code># Source: mychart/templates/configmap.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: telling-chimp-configmap\ndata:\n  myvalue: \"Hello World\"\n  drink: \"coffee\"\n  food: \"PIZZA\"\n\n  mug: \"true\"\n\n</code></pre> <p>Notice that we received a few empty lines in our YAML. Why? When the template engine runs, it removes the contents inside of <code>{{</code> and <code>}}</code>, but it leaves the remaining whitespace exactly as is.</p> <p>YAML ascribes meaning to whitespace, so managing the whitespace becomes pretty important. Fortunately, Helm templates have a few tools to help.</p> <p>First, the curly brace syntax of template declarations can be modified with special characters to tell the template engine to chomp whitespace. <code>{{-</code> (with the dash and space added) indicates that whitespace should be chomped left, while <code>-}}</code> means whitespace to the right should be consumed. Be careful! Newlines are whitespace!</p> <p>Make sure there is a space between the <code>-</code> and the rest of your directive. <code>{{- 3 }}</code> means \"trim left whitespace and print 3\" while <code>{{-3 }}</code> means \"print -3\".</p> <p>Using this syntax, we can modify our template to get rid of those new lines:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: {{ .Release.Name }}-configmap\ndata:\n  myvalue: \"Hello World\"\n  drink: {{ .Values.favorite.drink | default \"tea\" | quote }}\n  food: {{ .Values.favorite.food | upper | quote }}\n  {{- if eq .Values.favorite.drink \"coffee\" }}\n  mug: \"true\"\n  {{- end }}\n</code></pre> <p>Just for the sake of making this point clear, let's adjust the above, and substitute an <code>*</code> for each whitespace that will be deleted following this rule. An <code>*</code> at the end of the line indicates a newline character that would be removed</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: {{ .Release.Name }}-configmap\ndata:\n  myvalue: \"Hello World\"\n  drink: {{ .Values.favorite.drink | default \"tea\" | quote }}\n  food: {{ .Values.favorite.food | upper | quote }}*\n**{{- if eq .Values.favorite.drink \"coffee\" }}\n  mug: \"true\"*\n**{{- end }}\n\n</code></pre> <p>Keeping that in mind, we can run our template through Helm and see the result:</p> <pre><code># Source: mychart/templates/configmap.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: clunky-cat-configmap\ndata:\n  myvalue: \"Hello World\"\n  drink: \"coffee\"\n  food: \"PIZZA\"\n  mug: \"true\"\n</code></pre> <p>Be careful with the chomping modifiers. It is easy to accidentally do things like this:</p> <pre><code>  food: {{ .Values.favorite.food | upper | quote }}\n  {{- if eq .Values.favorite.drink \"coffee\" -}}\n  mug: \"true\"\n  {{- end -}}\n\n</code></pre> <p>That will produce <code>food: \"PIZZA\"mug: \"true\"</code> because it consumed newlines on both sides.</p> <p>For the details on whitespace control in templates, see the Official Go template documentation</p> <p>Finally, sometimes it's easier to tell the template system how to indent for you instead of trying to master the spacing of template directives. For that reason, you may sometimes find it useful to use the <code>indent</code> function (<code>{{ indent 2 \"mug:true\" }}</code>).</p>"},{"location":"chart_template_guide/control_structures/#modifying-scope-using-with","title":"Modifying scope using <code>with</code>","text":"<p>The next control structure to look at is the <code>with</code> action. This controls variable scoping. Recall that <code>.</code> is a reference to the current scope. So <code>.Values</code> tells the template to find the <code>Values</code> object in the current scope.</p> <p>The syntax for <code>with</code> is similar to a simple <code>if</code> statement:</p> <pre><code>{{ with PIPELINE }}\n  # restricted scope\n{{ end }}\n</code></pre> <p>Scopes can be changed. <code>with</code> can allow you to set the current scope (<code>.</code>) to a particular object. For example, we've been working with <code>.Values.favorite</code>. Let's rewrite our ConfigMap to alter the <code>.</code> scope to point to <code>.Values.favorite</code>:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: {{ .Release.Name }}-configmap\ndata:\n  myvalue: \"Hello World\"\n  {{- with .Values.favorite }}\n  drink: {{ .drink | default \"tea\" | quote }}\n  food: {{ .food | upper | quote }}\n  {{- end }}\n</code></pre> <p>Note that we removed the <code>if</code> conditional from the previous exercise because it is now unnecessary - the block after <code>with</code> only executes if the value of <code>PIPELINE</code> is not empty.</p> <p>Notice that now we can reference <code>.drink</code> and <code>.food</code> without qualifying them. That is because the <code>with</code> statement sets <code>.</code> to point to <code>.Values.favorite</code>. The <code>.</code> is reset to its previous scope after <code>{{ end }}</code>.</p> <p>But here's a note of caution! Inside of the restricted scope, you will not be able to access the other objects from the parent scope using <code>.</code>. This, for example, will fail:</p> <pre><code>  {{- with .Values.favorite }}\n  drink: {{ .drink | default \"tea\" | quote }}\n  food: {{ .food | upper | quote }}\n  release: {{ .Release.Name }}\n  {{- end }}\n</code></pre> <p>It will produce an error because <code>Release.Name</code> is not inside of the restricted scope for <code>.</code>. However, if we swap the last two lines, all will work as expected because the scope is reset after <code>{{ end }}</code>.</p> <pre><code>  {{- with .Values.favorite }}\n  drink: {{ .drink | default \"tea\" | quote }}\n  food: {{ .food | upper | quote }}\n  {{- end }}\n  release: {{ .Release.Name }}\n</code></pre> <p>Or, we can use <code>$</code> for accessing the object <code>Release.Name</code> from the parent scope. <code>$</code> is mapped to the root scope when template execution begins and it does not change during template execution. The following would work as well:</p> <pre><code>  {{- with .Values.favorite }}\n  drink: {{ .drink | default \"tea\" | quote }}\n  food: {{ .food | upper | quote }}\n  release: {{ $.Release.Name }}\n  {{- end }}\n</code></pre> <p>After looking at <code>range</code>, we will take a look at template variables, which offer one solution to the scoping issue above.</p>"},{"location":"chart_template_guide/control_structures/#looping-with-the-range-action","title":"Looping with the <code>range</code> action","text":"<p>Many programming languages have support for looping using <code>for</code> loops, <code>foreach</code> loops, or similar functional mechanisms. In Helm's template language, the way to iterate through a collection is to use the <code>range</code> operator.</p> <p>To start, let's add a list of pizza toppings to our <code>values.yaml</code> file:</p> <pre><code>favorite:\n  drink: coffee\n  food: pizza\npizzaToppings:\n  - mushrooms\n  - cheese\n  - peppers\n  - onions\n  - pineapple\n</code></pre> <p>Now we have a list (called a <code>slice</code> in templates) of <code>pizzaToppings</code>. We can modify our template to print this list into our ConfigMap:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: {{ .Release.Name }}-configmap\ndata:\n  myvalue: \"Hello World\"\n  {{- with .Values.favorite }}\n  drink: {{ .drink | default \"tea\" | quote }}\n  food: {{ .food | upper | quote }}\n  {{- end }}\n  toppings: |-\n    {{- range .Values.pizzaToppings }}\n    - {{ . | title | quote }}\n    {{- end }}\n\n</code></pre> <p>We can use <code>$</code> for accessing the list <code>Values.pizzaToppings</code> from the parent scope. <code>$</code> is mapped to the root scope when template execution begins and it does not change during template execution. The following would work as well:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: {{ .Release.Name }}-configmap\ndata:\n  myvalue: \"Hello World\"\n  {{- with .Values.favorite }}\n  drink: {{ .drink | default \"tea\" | quote }}\n  food: {{ .food | upper | quote }}\n  toppings: |-\n    {{- range $.Values.pizzaToppings }}\n    - {{ . | title | quote }}\n    {{- end }}\n  {{- end }}\n</code></pre> <p>Let's take a closer look at the <code>toppings:</code> list. The <code>range</code> function will \"range over\" (iterate through) the <code>pizzaToppings</code> list. But now something interesting happens. Just like <code>with</code> sets the scope of <code>.</code>, so does a <code>range</code> operator. Each time through the loop, <code>.</code> is set to the current pizza topping. That is, the first time, <code>.</code> is set to <code>mushrooms</code>. The second iteration it is set to <code>cheese</code>, and so on.</p> <p>We can send the value of <code>.</code> directly down a pipeline, so when we do <code>{{ . | title | quote }}</code>, it sends <code>.</code> to <code>title</code> (title case function) and then to <code>quote</code>. If we run this template, the output will be:</p> <pre><code># Source: mychart/templates/configmap.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: edgy-dragonfly-configmap\ndata:\n  myvalue: \"Hello World\"\n  drink: \"coffee\"\n  food: \"PIZZA\"\n  toppings: |-\n    - \"Mushrooms\"\n    - \"Cheese\"\n    - \"Peppers\"\n    - \"Onions\"\n    - \"Pineapple\"\n</code></pre> <p>Now, in this example we've done something tricky. The <code>toppings: |-</code> line is declaring a multi-line string. So our list of toppings is actually not a YAML list. It's a big string. Why would we do this? Because the data in ConfigMaps <code>data</code> is composed of key/value pairs, where both the key and the value are simple strings. To understand why this is the case, take a look at the Kubernetes ConfigMap docs. For us, though, this detail doesn't matter much.</p> <p>The <code>|-</code> marker in YAML takes a multi-line string. This can be a useful technique for embedding big blocks of data inside of your manifests, as exemplified here.</p> <p>Sometimes it's useful to be able to quickly make a list inside of your template, and then iterate over that list. Helm templates have a function to make this easy: <code>tuple</code>. In computer science, a tuple is a list-like collection of fixed size, but with arbitrary data types. This roughly conveys the way a <code>tuple</code> is used.</p> <pre><code>  sizes: |-\n    {{- range tuple \"small\" \"medium\" \"large\" }}\n    - {{ . }}\n    {{- end }}\n</code></pre> <p>The above will produce this:</p> <pre><code>  sizes: |-\n    - small\n    - medium\n    - large\n</code></pre> <p>In addition to lists and tuples, <code>range</code> can be used to iterate over collections that have a key and a value (like a <code>map</code> or <code>dict</code>). We'll see how to do that in the next section when we introduce template variables.</p>"},{"location":"chart_template_guide/data_types/","title":"Appendix: Go Data Types and Templates","text":"<p>The Helm template language is implemented in the strongly typed Go programming language. For that reason, variables in templates are typed. For the most part, variables will be exposed as one of the following types:</p> <ul> <li>string: A string of text</li> <li>bool: a <code>true</code> or <code>false</code></li> <li>int: An integer value (there are also 8, 16, 32, and 64 bit signed and   unsigned variants of this)</li> <li>float64: a 64-bit floating point value (there are also 8, 16, and 32 bit   varieties of this)</li> <li>a byte slice (<code>[]byte</code>), often used to hold (potentially) binary data</li> <li>struct: an object with properties and methods</li> <li>a slice (indexed list) of one of the previous types</li> <li>a string-keyed map (<code>map[string]interface{}</code>) where the value is one of the   previous types</li> </ul> <p>There are many other types in Go, and sometimes you will have to convert between them in your templates. The easiest way to debug an object's type is to pass it through <code>printf \"%T\"</code> in a template, which will print the type. Also see the <code>typeOf</code> and <code>kindOf</code> functions.</p>"},{"location":"chart_template_guide/debugging/","title":"Debugging Templates","text":"<p>Debugging templates can be tricky because the rendered templates are sent to the Kubernetes API server, which may reject the YAML files for reasons other than formatting.</p> <p>There are a few commands that can help you debug.</p> <ul> <li><code>helm lint</code> is your go-to tool for verifying that your chart follows best   practices</li> <li><code>helm template --debug</code> will test rendering chart templates locally.  </li> <li><code>helm install --dry-run --debug</code> will also render your chart locally without installing it, but will also check if conflicting resources are already running on the cluster. Setting <code>--dry-run=server</code> will additionally execute any <code>lookup</code> in your chart towards the server.</li> <li><code>helm get manifest</code>: This is a good way to see what templates are installed on   the server.</li> </ul> <p>When your YAML is failing to parse, but you want to see what is generated, one easy way to retrieve the YAML is to comment out the problem section in the template, and then re-run <code>helm install --dry-run --debug</code>:</p> <pre><code>apiVersion: v2\n# some: problem section\n# {{ .Values.foo | quote }}\n</code></pre> <p>The above will be rendered and returned with the comments intact:</p> <pre><code>apiVersion: v2\n# some: problem section\n#  \"bar\"\n</code></pre> <p>This provides a quick way of viewing the generated content without YAML parse errors blocking.</p>"},{"location":"chart_template_guide/function_list/","title":"Template Function List","text":"<p>Helm includes many template functions you can take advantage of in templates. They are listed here and broken down by the following categories:</p> <ul> <li>Cryptographic and Security</li> <li>Date</li> <li>Dictionaries</li> <li>Encoding</li> <li>File Path</li> <li>Kubernetes and Chart</li> <li>Logic and Flow Control</li> <li>Lists</li> <li>Math</li> <li>Float Math</li> <li>Network</li> <li>Reflection</li> <li>Regular Expressions</li> <li>Semantic Versions</li> <li>String</li> <li>Type Conversion</li> <li>URL</li> <li>UUID</li> </ul>"},{"location":"chart_template_guide/function_list/#logic-and-flow-control-functions","title":"Logic and Flow Control Functions","text":"<p>Helm includes numerous logic and control flow functions including and, coalesce, default, empty, eq, fail, ge, gt, le, lt, ne, not, or, and required.</p>"},{"location":"chart_template_guide/function_list/#and","title":"and","text":"<p>Returns the boolean AND of two or more arguments (the first empty argument, or the last argument).</p> <pre><code>and .Arg1 .Arg2\n</code></pre>"},{"location":"chart_template_guide/function_list/#or","title":"or","text":"<p>Returns the boolean OR of two or more arguments (the first non-empty argument, or the last argument).</p> <pre><code>or .Arg1 .Arg2\n</code></pre>"},{"location":"chart_template_guide/function_list/#not","title":"not","text":"<p>Returns the boolean negation of its argument.</p> <pre><code>not .Arg\n</code></pre>"},{"location":"chart_template_guide/function_list/#eq","title":"eq","text":"<p>Returns the boolean equality of the arguments (e.g., Arg1 == Arg2).</p> <pre><code>eq .Arg1 .Arg2\n</code></pre>"},{"location":"chart_template_guide/function_list/#ne","title":"ne","text":"<p>Returns the boolean inequality of the arguments (e.g., Arg1 != Arg2)</p> <pre><code>ne .Arg1 .Arg2\n</code></pre>"},{"location":"chart_template_guide/function_list/#lt","title":"lt","text":"<p>Returns a boolean true if the first argument is less than the second. False is returned otherwise (e.g., Arg1 &lt; Arg2).</p> <pre><code>lt .Arg1 .Arg2\n</code></pre>"},{"location":"chart_template_guide/function_list/#le","title":"le","text":"<p>Returns a boolean true if the first argument is less than or equal to the second. False is returned otherwise (e.g., Arg1 &lt;= Arg2).</p> <pre><code>le .Arg1 .Arg2\n</code></pre>"},{"location":"chart_template_guide/function_list/#gt","title":"gt","text":"<p>Returns a boolean true if the first argument is greater than the second. False is returned otherwise (e.g., Arg1 &gt; Arg2).</p> <pre><code>gt .Arg1 .Arg2\n</code></pre>"},{"location":"chart_template_guide/function_list/#ge","title":"ge","text":"<p>Returns a boolean true if the first argument is greater than or equal to the second. False is returned otherwise (e.g., Arg1 &gt;= Arg2).</p> <pre><code>ge .Arg1 .Arg2\n</code></pre>"},{"location":"chart_template_guide/function_list/#default","title":"default","text":"<p>To set a simple default value, use <code>default</code>:</p> <pre><code>default \"foo\" .Bar\n</code></pre> <p>In the above, if <code>.Bar</code> evaluates to a non-empty value, it will be used. But if it is empty, <code>foo</code> will be returned instead.</p> <p>The definition of \"empty\" depends on type:</p> <ul> <li>Numeric: 0</li> <li>String: \"\"</li> <li>Lists: <code>[]</code></li> <li>Dicts: <code>{}</code></li> <li>Boolean: <code>false</code></li> <li>And always <code>nil</code> (aka null)</li> </ul> <p>For structs, there is no definition of empty, so a struct will never return the default.</p>"},{"location":"chart_template_guide/function_list/#required","title":"required","text":"<p>Specify values that must be set with <code>required</code>:</p> <pre><code>required \"A valid foo is required!\" .Bar\n</code></pre> <p>If <code>.Bar</code> is empty or not defined (see default on how this is  evaluated), the template will not render and will return the error message  supplied instead.</p>"},{"location":"chart_template_guide/function_list/#empty","title":"empty","text":"<p>The <code>empty</code> function returns <code>true</code> if the given value is considered empty, and <code>false</code> otherwise. The empty values are listed in the <code>default</code> section.</p> <pre><code>empty .Foo\n</code></pre> <p>Note that in Go template conditionals, emptiness is calculated for you. Thus, you rarely need <code>if not empty .Foo</code>. Instead, just use <code>if .Foo</code>.</p>"},{"location":"chart_template_guide/function_list/#fail","title":"fail","text":"<p>Unconditionally returns an empty <code>string</code> and an <code>error</code> with the specified text. This is useful in scenarios where other conditionals have determined that template rendering should fail.</p> <pre><code>fail \"Please accept the end user license agreement\"\n</code></pre>"},{"location":"chart_template_guide/function_list/#coalesce","title":"coalesce","text":"<p>The <code>coalesce</code> function takes a list of values and returns the first non-empty one.</p> <pre><code>coalesce 0 1 2\n</code></pre> <p>The above returns <code>1</code>.</p> <p>This function is useful for scanning through multiple variables or values:</p> <pre><code>coalesce .name .parent.name \"Matt\"\n</code></pre> <p>The above will first check to see if <code>.name</code> is empty. If it is not, it will return that value. If it is empty, <code>coalesce</code> will evaluate <code>.parent.name</code> for emptiness. Finally, if both <code>.name</code> and <code>.parent.name</code> are empty, it will return <code>Matt</code>.</p>"},{"location":"chart_template_guide/function_list/#ternary","title":"ternary","text":"<p>The <code>ternary</code> function takes two values, and a test value. If the test value is true, the first value will be returned. If the test value is empty, the second value will be returned. This is similar to the ternary operator in C and other programming languages.</p>"},{"location":"chart_template_guide/function_list/#true-test-value","title":"true test value","text":"<pre><code>ternary \"foo\" \"bar\" true\n</code></pre> <p>or</p> <pre><code>true | ternary \"foo\" \"bar\"\n</code></pre> <p>The above returns <code>\"foo\"</code>.</p>"},{"location":"chart_template_guide/function_list/#false-test-value","title":"false test value","text":"<pre><code>ternary \"foo\" \"bar\" false\n</code></pre> <p>or</p> <pre><code>false | ternary \"foo\" \"bar\"\n</code></pre> <p>The above returns <code>\"bar\"</code>.</p>"},{"location":"chart_template_guide/function_list/#string-functions","title":"String Functions","text":"<p>Helm includes the following string functions: abbrev, abbrevboth, camelcase, cat, contains, hasPrefix, hasSuffix, indent, initials, kebabcase, lower, nindent, nospace, plural, print, printf, println, quote, randAlpha, randAlphaNum, randAscii, randNumeric, repeat, replace, shuffle, snakecase, squote, substr, swapcase, title, trim, trimAll, trimPrefix, trimSuffix, trunc, untitle, upper, wrap, and wrapWith.</p>"},{"location":"chart_template_guide/function_list/#print","title":"print","text":"<p>Returns a string from the combination of its parts.</p> <pre><code>print \"Matt has \" .Dogs \" dogs\"\n</code></pre> <p>Types that are not strings are converted to strings where possible.</p> <p>Note, when two arguments next to each other are not strings a space is added between them.</p>"},{"location":"chart_template_guide/function_list/#println","title":"println","text":"<p>Works the same way as print but adds a new line at the end.</p>"},{"location":"chart_template_guide/function_list/#printf","title":"printf","text":"<p>Returns a string based on a formatting string and the arguments to pass to it in order.</p> <pre><code>printf \"%s has %d dogs.\" .Name .NumberDogs\n</code></pre> <p>The placeholder to use depends on the type for the argument being passed in. This includes:</p> <p>General purpose:</p> <ul> <li><code>%v</code> the value in a default format</li> <li>when printing dicts, the plus flag (%+v) adds field names</li> <li><code>%%</code> a literal percent sign; consumes no value</li> </ul> <p>Boolean:</p> <ul> <li><code>%t</code> the word true or false</li> </ul> <p>Integer:</p> <ul> <li><code>%b</code> base 2</li> <li><code>%c</code> the character represented by the corresponding Unicode code point</li> <li><code>%d</code> base 10</li> <li><code>%o</code> base 8</li> <li><code>%O</code> base 8 with 0o prefix</li> <li><code>%q</code> a single-quoted character literal safely escaped</li> <li><code>%x</code> base 16, with lower-case letters for a-f</li> <li><code>%X</code> base 16, with upper-case letters for A-F</li> <li><code>%U</code> Unicode format: U+1234; same as \"U+%04X\"</li> </ul> <p>Floating-point and complex constituents:</p> <ul> <li><code>%b</code> decimal less scientific notation with exponent a power of two, e.g.   -123456p-78</li> <li><code>%e</code> scientific notation, e.g. -1.234456e+78</li> <li><code>%E</code> scientific notation, e.g. -1.234456E+78</li> <li><code>%f</code> decimal point but no exponent, e.g. 123.456</li> <li><code>%F</code> synonym for %f</li> <li><code>%g</code> %e for large exponents, %f otherwise.</li> <li><code>%G</code> %E for large exponents, %F otherwise</li> <li><code>%x</code> hexadecimal notation (with decimal power of two exponent), e.g.   -0x1.23abcp+20</li> <li><code>%X</code> upper-case hexadecimal notation, e.g. -0X1.23ABCP+20</li> </ul> <p>String and slice of bytes (treated equivalently with these verbs):</p> <ul> <li><code>%s</code> the uninterpreted bytes of the string or slice</li> <li><code>%q</code> a double-quoted string safely escaped</li> <li><code>%x</code> base 16, lower-case, two characters per byte</li> <li><code>%X</code> base 16, upper-case, two characters per byte</li> </ul> <p>Slice:</p> <ul> <li><code>%p</code> address of 0th element in base 16 notation, with leading 0x</li> </ul>"},{"location":"chart_template_guide/function_list/#trim","title":"trim","text":"<p>The <code>trim</code> function removes white space from both sides of a string:</p> <pre><code>trim \"   hello    \"\n</code></pre> <p>The above produces <code>hello</code></p>"},{"location":"chart_template_guide/function_list/#trimall","title":"trimAll","text":"<p>Removes the given characters from the front and back of a string:</p> <pre><code>trimAll \"$\" \"$5.00\"\n</code></pre> <p>The above returns <code>5.00</code> (as a string).</p>"},{"location":"chart_template_guide/function_list/#trimprefix","title":"trimPrefix","text":"<p>Trim just the prefix from a string:</p> <pre><code>trimPrefix \"-\" \"-hello\"\n</code></pre> <p>The above returns <code>hello</code></p>"},{"location":"chart_template_guide/function_list/#trimsuffix","title":"trimSuffix","text":"<p>Trim just the suffix from a string:</p> <pre><code>trimSuffix \"-\" \"hello-\"\n</code></pre> <p>The above returns <code>hello</code></p>"},{"location":"chart_template_guide/function_list/#lower","title":"lower","text":"<p>Convert the entire string to lowercase:</p> <pre><code>lower \"HELLO\"\n</code></pre> <p>The above returns <code>hello</code></p>"},{"location":"chart_template_guide/function_list/#upper","title":"upper","text":"<p>Convert the entire string to uppercase:</p> <pre><code>upper \"hello\"\n</code></pre> <p>The above returns <code>HELLO</code></p>"},{"location":"chart_template_guide/function_list/#title","title":"title","text":"<p>Convert to title case:</p> <pre><code>title \"hello world\"\n</code></pre> <p>The above returns <code>Hello World</code></p>"},{"location":"chart_template_guide/function_list/#untitle","title":"untitle","text":"<p>Remove title casing. <code>untitle \"Hello World\"</code> produces <code>hello world</code>.</p>"},{"location":"chart_template_guide/function_list/#repeat","title":"repeat","text":"<p>Repeat a string multiple times:</p> <pre><code>repeat 3 \"hello\"\n</code></pre> <p>The above returns <code>hellohellohello</code></p>"},{"location":"chart_template_guide/function_list/#substr","title":"substr","text":"<p>Get a substring from a string. It takes three parameters:</p> <ul> <li>start (int)</li> <li>end (int)</li> <li>string (string)</li> </ul> <pre><code>substr 0 5 \"hello world\"\n</code></pre> <p>The above returns <code>hello</code></p>"},{"location":"chart_template_guide/function_list/#nospace","title":"nospace","text":"<p>Remove all whitespace from a string.</p> <pre><code>nospace \"hello w o r l d\"\n</code></pre> <p>The above returns <code>helloworld</code></p>"},{"location":"chart_template_guide/function_list/#trunc","title":"trunc","text":"<p>Truncate a string</p> <pre><code>trunc 5 \"hello world\"\n</code></pre> <p>The above produces <code>hello</code>.</p> <pre><code>trunc -5 \"hello world\"\n</code></pre> <p>The above produces <code>world</code>.</p>"},{"location":"chart_template_guide/function_list/#abbrev","title":"abbrev","text":"<p>Truncate a string with ellipses (<code>...</code>)</p> <p>Parameters:</p> <ul> <li>max length</li> <li>the string</li> </ul> <pre><code>abbrev 5 \"hello world\"\n</code></pre> <p>The above returns <code>he...</code>, since it counts the width of the ellipses against the maximum length.</p>"},{"location":"chart_template_guide/function_list/#abbrevboth","title":"abbrevboth","text":"<p>Abbreviate both sides:</p> <pre><code>abbrevboth 5 10 \"1234 5678 9123\"\n</code></pre> <p>the above produces <code>...5678...</code></p> <p>It takes:</p> <ul> <li>left offset</li> <li>max length</li> <li>the string</li> </ul>"},{"location":"chart_template_guide/function_list/#initials","title":"initials","text":"<p>Given multiple words, take the first letter of each word and combine.</p> <pre><code>initials \"First Try\"\n</code></pre> <p>The above returns <code>FT</code></p>"},{"location":"chart_template_guide/function_list/#randalphanum-randalpha-randnumeric-and-randascii","title":"randAlphaNum, randAlpha, randNumeric, and randAscii","text":"<p>These four functions generate cryptographically secure (uses <code>crypto/rand</code>) random strings, but with different base character sets:</p> <ul> <li><code>randAlphaNum</code> uses <code>0-9a-zA-Z</code></li> <li><code>randAlpha</code> uses <code>a-zA-Z</code></li> <li><code>randNumeric</code> uses <code>0-9</code></li> <li><code>randAscii</code> uses all printable ASCII characters</li> </ul> <p>Each of them takes one parameter: the integer length of the string.</p> <pre><code>randNumeric 3\n</code></pre> <p>The above will produce a random string with three digits.</p>"},{"location":"chart_template_guide/function_list/#wrap","title":"wrap","text":"<p>Wrap text at a given column count:</p> <pre><code>wrap 80 $someText\n</code></pre> <p>The above will wrap the string in <code>$someText</code> at 80 columns.</p>"},{"location":"chart_template_guide/function_list/#wrapwith","title":"wrapWith","text":"<p><code>wrapWith</code> works as <code>wrap</code>, but lets you specify the string to wrap with. (<code>wrap</code> uses <code>\\n</code>)</p> <pre><code>wrapWith 5 \"\\t\" \"Hello World\"\n</code></pre> <p>The above produces <code>Hello World</code> (where the whitespace is an ASCII tab character)</p>"},{"location":"chart_template_guide/function_list/#contains","title":"contains","text":"<p>Test to see if one string is contained inside of another:</p> <pre><code>contains \"cat\" \"catch\"\n</code></pre> <p>The above returns <code>true</code> because <code>catch</code> contains <code>cat</code>.</p>"},{"location":"chart_template_guide/function_list/#hasprefix-and-hassuffix","title":"hasPrefix and hasSuffix","text":"<p>The <code>hasPrefix</code> and <code>hasSuffix</code> functions test whether a string has a given prefix or suffix:</p> <pre><code>hasPrefix \"cat\" \"catch\"\n</code></pre> <p>The above returns <code>true</code> because <code>catch</code> has the prefix <code>cat</code>.</p>"},{"location":"chart_template_guide/function_list/#quote-and-squote","title":"quote and squote","text":"<p>These functions wrap a string in double quotes (<code>quote</code>) or single quotes (<code>squote</code>).</p>"},{"location":"chart_template_guide/function_list/#cat","title":"cat","text":"<p>The <code>cat</code> function concatenates multiple strings together into one, separating them with spaces:</p> <pre><code>cat \"hello\" \"beautiful\" \"world\"\n</code></pre> <p>The above produces <code>hello beautiful world</code></p>"},{"location":"chart_template_guide/function_list/#indent","title":"indent","text":"<p>The <code>indent</code> function indents every line in a given string to the specified indent width. This is useful when aligning multi-line strings:</p> <pre><code>indent 4 $lots_of_text\n</code></pre> <p>The above will indent every line of text by 4 space characters.</p>"},{"location":"chart_template_guide/function_list/#nindent","title":"nindent","text":"<p>The <code>nindent</code> function is the same as the indent function, but prepends a new line to the beginning of the string.</p> <pre><code>nindent 4 $lots_of_text\n</code></pre> <p>The above will indent every line of text by 4 space characters and add a new line to the beginning.</p>"},{"location":"chart_template_guide/function_list/#replace","title":"replace","text":"<p>Perform simple string replacement.</p> <p>It takes three arguments:</p> <ul> <li>string to replace</li> <li>string to replace with</li> <li>source string</li> </ul> <pre><code>\"I Am Henry VIII\" | replace \" \" \"-\"\n</code></pre> <p>The above will produce <code>I-Am-Henry-VIII</code></p>"},{"location":"chart_template_guide/function_list/#plural","title":"plural","text":"<p>Pluralize a string.</p> <pre><code>len $fish | plural \"one anchovy\" \"many anchovies\"\n</code></pre> <p>In the above, if the length of the string is 1, the first argument will be printed (<code>one anchovy</code>). Otherwise, the second argument will be printed (<code>many anchovies</code>).</p> <p>The arguments are:</p> <ul> <li>singular string</li> <li>plural string</li> <li>length integer</li> </ul> <p>NOTE: Helm does not currently support languages with more complex pluralization rules. And <code>0</code> is considered a plural because the English language treats it as such (<code>zero anchovies</code>).</p>"},{"location":"chart_template_guide/function_list/#snakecase","title":"snakecase","text":"<p>Convert string from camelCase to snake_case.</p> <pre><code>snakecase \"FirstName\"\n</code></pre> <p>This above will produce <code>first_name</code>.</p>"},{"location":"chart_template_guide/function_list/#camelcase","title":"camelcase","text":"<p>Convert string from snake_case to CamelCase</p> <pre><code>camelcase \"http_server\"\n</code></pre> <p>This above will produce <code>HttpServer</code>.</p>"},{"location":"chart_template_guide/function_list/#kebabcase","title":"kebabcase","text":"<p>Convert string from camelCase to kebab-case.</p> <pre><code>kebabcase \"FirstName\"\n</code></pre> <p>This above will produce <code>first-name</code>.</p>"},{"location":"chart_template_guide/function_list/#swapcase","title":"swapcase","text":"<p>Swap the case of a string using a word based algorithm.</p> <p>Conversion algorithm:</p> <ul> <li>Upper case character converts to Lower case</li> <li>Title case character converts to Lower case</li> <li>Lower case character after Whitespace or at start converts to Title case</li> <li>Other Lower case character converts to Upper case</li> <li>Whitespace is defined by unicode.IsSpace(char)</li> </ul> <pre><code>swapcase \"This Is A.Test\"\n</code></pre> <p>This above will produce <code>tHIS iS a.tEST</code>.</p>"},{"location":"chart_template_guide/function_list/#shuffle","title":"shuffle","text":"<p>Shuffle a string.</p> <pre><code>shuffle \"hello\"\n</code></pre> <p>The above will randomize the letters in <code>hello</code>, perhaps producing <code>oelhl</code>.</p>"},{"location":"chart_template_guide/function_list/#type-conversion-functions","title":"Type Conversion Functions","text":"<p>The following type conversion functions are provided by Helm:</p> <ul> <li><code>atoi</code>: Convert a string to an integer.</li> <li><code>float64</code>: Convert to a <code>float64</code>.</li> <li><code>int</code>: Convert to an <code>int</code> at the system's width.</li> <li><code>int64</code>: Convert to an <code>int64</code>.</li> <li><code>toDecimal</code>: Convert a unix octal to a <code>int64</code>.</li> <li><code>toString</code>: Convert to a string.</li> <li><code>toStrings</code>: Convert a list, slice, or array to a list of strings.</li> <li><code>toJson</code> (<code>mustToJson</code>): Convert list, slice, array, dict, or object to JSON.</li> <li><code>toPrettyJson</code> (<code>mustToPrettyJson</code>): Convert list, slice, array, dict, or   object to indented JSON.</li> <li><code>toRawJson</code> (<code>mustToRawJson</code>): Convert list, slice, array, dict, or object to   JSON with HTML characters unescaped.</li> <li><code>fromYaml</code>: Convert a YAML string to an object.</li> <li><code>fromJson</code>: Convert a JSON string to an object.</li> <li><code>fromJsonArray</code>: Convert a JSON array to a list.</li> <li><code>toYaml</code>: Convert list, slice, array, dict, or object to indented yaml, can be used to copy chunks of yaml from any source. This function is equivalent to GoLang yaml.Marshal function, see docs here: https://pkg.go.dev/gopkg.in/yaml.v2#Marshal</li> <li><code>toToml</code>: Convert list, slice, array, dict, or object to toml, can be used to copy chunks of toml from any source.</li> <li><code>fromYamlArray</code>: Convert a YAML array to a list.</li> </ul> <p>Only <code>atoi</code> requires that the input be a specific type. The others will attempt to convert from any type to the destination type. For example, <code>int64</code> can convert floats to ints, and it can also convert strings to ints.</p>"},{"location":"chart_template_guide/function_list/#tostrings","title":"toStrings","text":"<p>Given a list-like collection, produce a slice of strings.</p> <pre><code>list 1 2 3 | toStrings\n</code></pre> <p>The above converts <code>1</code> to <code>\"1\"</code>, <code>2</code> to <code>\"2\"</code>, and so on, and then returns them as a list.</p>"},{"location":"chart_template_guide/function_list/#todecimal","title":"toDecimal","text":"<p>Given a unix octal permission, produce a decimal.</p> <pre><code>\"0777\" | toDecimal\n</code></pre> <p>The above converts <code>0777</code> to <code>511</code> and returns the value as an int64.</p>"},{"location":"chart_template_guide/function_list/#tojson-musttojson","title":"toJson, mustToJson","text":"<p>The <code>toJson</code> function encodes an item into a JSON string. If the item cannot be converted to JSON the function will return an empty string. <code>mustToJson</code> will return an error in case the item cannot be encoded in JSON.</p> <pre><code>toJson .Item\n</code></pre> <p>The above returns JSON string representation of <code>.Item</code>.</p>"},{"location":"chart_template_guide/function_list/#toprettyjson-musttoprettyjson","title":"toPrettyJson, mustToPrettyJson","text":"<p>The <code>toPrettyJson</code> function encodes an item into a pretty (indented) JSON string.</p> <pre><code>toPrettyJson .Item\n</code></pre> <p>The above returns indented JSON string representation of <code>.Item</code>.</p>"},{"location":"chart_template_guide/function_list/#torawjson-musttorawjson","title":"toRawJson, mustToRawJson","text":"<p>The <code>toRawJson</code> function encodes an item into JSON string with HTML characters unescaped.</p> <pre><code>toRawJson .Item\n</code></pre> <p>The above returns unescaped JSON string representation of <code>.Item</code>.</p>"},{"location":"chart_template_guide/function_list/#fromyaml","title":"fromYaml","text":"<p>The <code>fromYaml</code> function takes a YAML string and returns an object that can be used in templates.</p> <p><code>File at: yamls/person.yaml</code></p> <pre><code>name: Bob\nage: 25\nhobbies:\n  - hiking\n  - fishing\n  - cooking\n</code></pre> <pre><code>{{- $person := .Files.Get \"yamls/person.yaml\" | fromYaml }}\ngreeting: |\n  Hi, my name is {{ $person.name }} and I am {{ $person.age }} years old.\n  My hobbies are {{ range $person.hobbies }}{{ . }} {{ end }}.\n</code></pre>"},{"location":"chart_template_guide/function_list/#fromjson","title":"fromJson","text":"<p>The <code>fromJson</code> function takes a JSON string and returns an object that can be used in templates.</p> <p><code>File at: jsons/person.json</code></p> <pre><code>{\n  \"name\": \"Bob\",\n  \"age\": 25,\n  \"hobbies\": [\n    \"hiking\",\n    \"fishing\",\n    \"cooking\"\n  ]\n}\n</code></pre> <pre><code>{{- $person := .Files.Get \"jsons/person.json\" | fromJson }}\ngreeting: |\n  Hi, my name is {{ $person.name }} and I am {{ $person.age }} years old.\n  My hobbies are {{ range $person.hobbies }}{{ . }} {{ end }}.\n</code></pre>"},{"location":"chart_template_guide/function_list/#fromjsonarray","title":"fromJsonArray","text":"<p>The <code>fromJsonArray</code> function takes a JSON Array and returns a list that can be used in templates.</p> <p><code>File at: jsons/people.json</code></p> <pre><code>[\n { \"name\": \"Bob\",\"age\": 25 },\n { \"name\": \"Ram\",\"age\": 16 }\n]\n</code></pre> <pre><code>{{- $people := .Files.Get \"jsons/people.json\" | fromJsonArray }}\n{{- range $person := $people }}\ngreeting: |\n  Hi, my name is {{ $person.name }} and I am {{ $person.age }} years old.\n{{ end }}\n</code></pre>"},{"location":"chart_template_guide/function_list/#fromyamlarray","title":"fromYamlArray","text":"<p>The <code>fromYamlArray</code> function takes a YAML Array and returns a list that can be used in templates.</p> <p><code>File at: yamls/people.yml</code></p> <pre><code>- name: Bob\n  age: 25\n- name: Ram\n  age: 16\n</code></pre> <pre><code>{{- $people := .Files.Get \"yamls/people.yml\" | fromYamlArray }}\n{{- range $person := $people }}\ngreeting: |\n  Hi, my name is {{ $person.name }} and I am {{ $person.age }} years old.\n{{ end }}\n</code></pre>"},{"location":"chart_template_guide/function_list/#regular-expressions","title":"Regular Expressions","text":"<p>Helm includes the following regular expression functions: regexFind (mustRegexFind), regexFindAll (mustRegexFindAll), regexMatch (mustRegexMatch), regexReplaceAll (mustRegexReplaceAll), regexReplaceAllLiteral (mustRegexReplaceAllLiteral), regexSplit (mustRegexSplit).</p>"},{"location":"chart_template_guide/function_list/#regexmatch-mustregexmatch","title":"regexMatch, mustRegexMatch","text":"<p>Returns true if the input string contains any match of the regular expression.</p> <pre><code>regexMatch \"^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}$\" \"test@acme.com\"\n</code></pre> <p>The above produces <code>true</code></p> <p><code>regexMatch</code> panics if there is a problem and <code>mustRegexMatch</code> returns an error to the template engine if there is a problem.</p>"},{"location":"chart_template_guide/function_list/#regexfindall-mustregexfindall","title":"regexFindAll, mustRegexFindAll","text":"<p>Returns a slice of all matches of the regular expression in the input string. The last parameter n determines the number of substrings to return, where -1 means return all matches</p> <pre><code>regexFindAll \"[2,4,6,8]\" \"123456789\" -1\n</code></pre> <p>The above produces <code>[2 4 6 8]</code></p> <p><code>regexFindAll</code> panics if there is a problem and <code>mustRegexFindAll</code> returns an error to the template engine if there is a problem.</p>"},{"location":"chart_template_guide/function_list/#regexfind-mustregexfind","title":"regexFind, mustRegexFind","text":"<p>Return the first (left most) match of the regular expression in the input string</p> <pre><code>regexFind \"[a-zA-Z][1-9]\" \"abcd1234\"\n</code></pre> <p>The above produces <code>d1</code></p> <p><code>regexFind</code> panics if there is a problem and <code>mustRegexFind</code> returns an error to the template engine if there is a problem.</p>"},{"location":"chart_template_guide/function_list/#regexreplaceall-mustregexreplaceall","title":"regexReplaceAll, mustRegexReplaceAll","text":"<p>Returns a copy of the input string, replacing matches of the Regexp with the replacement string replacement. Inside string replacement, $ signs are interpreted as in Expand, so for instance $1 represents the text of the first submatch</p> <pre><code>regexReplaceAll \"a(x*)b\" \"-ab-axxb-\" \"${1}W\"\n</code></pre> <p>The above produces <code>-W-xxW-</code></p> <p><code>regexReplaceAll</code> panics if there is a problem and <code>mustRegexReplaceAll</code> returns an error to the template engine if there is a problem.</p>"},{"location":"chart_template_guide/function_list/#regexreplaceallliteral-mustregexreplaceallliteral","title":"regexReplaceAllLiteral, mustRegexReplaceAllLiteral","text":"<p>Returns a copy of the input string, replacing matches of the Regexp with the replacement string replacement. The replacement string is substituted directly, without using Expand</p> <pre><code>regexReplaceAllLiteral \"a(x*)b\" \"-ab-axxb-\" \"${1}\"\n</code></pre> <p>The above produces <code>-${1}-${1}-</code></p> <p><code>regexReplaceAllLiteral</code> panics if there is a problem and <code>mustRegexReplaceAllLiteral</code> returns an error to the template engine if there is a problem.</p>"},{"location":"chart_template_guide/function_list/#regexsplit-mustregexsplit","title":"regexSplit, mustRegexSplit","text":"<p>Slices the input string into substrings separated by the expression and returns a slice of the substrings between those expression matches. The last parameter <code>n</code> determines the number of substrings to return, where <code>-1</code> means return all matches</p> <pre><code>regexSplit \"z+\" \"pizza\" -1\n</code></pre> <p>The above produces <code>[pi a]</code></p> <p><code>regexSplit</code> panics if there is a problem and <code>mustRegexSplit</code> returns an error to the template engine if there is a problem.</p>"},{"location":"chart_template_guide/function_list/#cryptographic-and-security-functions","title":"Cryptographic and Security Functions","text":"<p>Helm provides some advanced cryptographic functions. They include adler32sum, buildCustomCert, decryptAES, derivePassword, encryptAES, genCA, genPrivateKey, genSelfSignedCert, genSignedCert, htpasswd, randBytes, sha1sum, and sha256sum.</p>"},{"location":"chart_template_guide/function_list/#sha1sum","title":"sha1sum","text":"<p>The <code>sha1sum</code> function receives a string, and computes it's SHA1 digest.</p> <pre><code>sha1sum \"Hello world!\"\n</code></pre>"},{"location":"chart_template_guide/function_list/#sha256sum","title":"sha256sum","text":"<p>The <code>sha256sum</code> function receives a string, and computes it's SHA256 digest.</p> <pre><code>sha256sum \"Hello world!\"\n</code></pre> <p>The above will compute the SHA 256 sum in an \"ASCII armored\" format that is safe to print.</p>"},{"location":"chart_template_guide/function_list/#adler32sum","title":"adler32sum","text":"<p>The <code>adler32sum</code> function receives a string, and computes its Adler-32 checksum.</p> <pre><code>adler32sum \"Hello world!\"\n</code></pre>"},{"location":"chart_template_guide/function_list/#htpasswd","title":"htpasswd","text":"<p>The <code>htpasswd</code> function takes a <code>username</code> and <code>password</code> and generates a <code>bcrypt</code> hash of the password. The result can be used for basic authentication on an Apache HTTP Server.</p> <pre><code>htpasswd \"myUser\" \"myPassword\"\n</code></pre> <p>Note that it is insecure to store the password directly in the template.</p>"},{"location":"chart_template_guide/function_list/#randbytes","title":"randBytes","text":"<p>The randBytes function accepts a count N and generates a cryptographically secure (uses crypto/rand) random sequence of N bytes. The sequence is returned as a base64 encoded string.</p> <pre><code>randBytes 24\n</code></pre>"},{"location":"chart_template_guide/function_list/#derivepassword","title":"derivePassword","text":"<p>The <code>derivePassword</code> function can be used to derive a specific password based on some shared \"master password\" constraints. The algorithm for this is well specified.</p> <pre><code>derivePassword 1 \"long\" \"password\" \"user\" \"example.com\"\n</code></pre> <p>Note that it is considered insecure to store the parts directly in the template.</p>"},{"location":"chart_template_guide/function_list/#genprivatekey","title":"genPrivateKey","text":"<p>The <code>genPrivateKey</code> function generates a new private key encoded into a PEM block.</p> <p>It takes one of the values for its first param:</p> <ul> <li><code>ecdsa</code>: Generate an elliptic curve DSA key (P256)</li> <li><code>dsa</code>: Generate a DSA key (L2048N256)</li> <li><code>rsa</code>: Generate an RSA 4096 key</li> </ul>"},{"location":"chart_template_guide/function_list/#buildcustomcert","title":"buildCustomCert","text":"<p>The <code>buildCustomCert</code> function allows customizing the certificate.</p> <p>It takes the following string parameters:</p> <ul> <li>A base64 encoded PEM format certificate</li> <li>A base64 encoded PEM format private key</li> </ul> <p>It returns a certificate object with the following attributes:</p> <ul> <li><code>Cert</code>: A PEM-encoded certificate</li> <li><code>Key</code>: A PEM-encoded private key</li> </ul> <p>Example:</p> <pre><code>$ca := buildCustomCert \"base64-encoded-ca-crt\" \"base64-encoded-ca-key\"\n</code></pre> <p>Note that the returned object can be passed to the <code>genSignedCert</code> function to sign a certificate using this CA.</p>"},{"location":"chart_template_guide/function_list/#genca","title":"genCA","text":"<p>The <code>genCA</code> function generates a new, self-signed x509 certificate authority.</p> <p>It takes the following parameters:</p> <ul> <li>Subject's common name (cn)</li> <li>Cert validity duration in days</li> </ul> <p>It returns an object with the following attributes:</p> <ul> <li><code>Cert</code>: A PEM-encoded certificate</li> <li><code>Key</code>: A PEM-encoded private key</li> </ul> <p>Example:</p> <pre><code>$ca := genCA \"foo-ca\" 365\n</code></pre> <p>Note that the returned object can be passed to the <code>genSignedCert</code> function to sign a certificate using this CA.</p>"},{"location":"chart_template_guide/function_list/#genselfsignedcert","title":"genSelfSignedCert","text":"<p>The <code>genSelfSignedCert</code> function generates a new, self-signed x509 certificate.</p> <p>It takes the following parameters:</p> <ul> <li>Subject's common name (cn)</li> <li>Optional list of IPs; may be nil</li> <li>Optional list of alternate DNS names; may be nil</li> <li>Cert validity duration in days</li> </ul> <p>It returns an object with the following attributes:</p> <ul> <li><code>Cert</code>: A PEM-encoded certificate</li> <li><code>Key</code>: A PEM-encoded private key</li> </ul> <p>Example:</p> <pre><code>$cert := genSelfSignedCert \"foo.com\" (list \"10.0.0.1\" \"10.0.0.2\") (list \"bar.com\" \"bat.com\") 365\n</code></pre>"},{"location":"chart_template_guide/function_list/#gensignedcert","title":"genSignedCert","text":"<p>The <code>genSignedCert</code> function generates a new, x509 certificate signed by the specified CA.</p> <p>It takes the following parameters:</p> <ul> <li>Subject's common name (cn)</li> <li>Optional list of IPs; may be nil</li> <li>Optional list of alternate DNS names; may be nil</li> <li>Cert validity duration in days</li> <li>CA (see <code>genCA</code>)</li> </ul> <p>Example:</p> <pre><code>$ca := genCA \"foo-ca\" 365\n$cert := genSignedCert \"foo.com\" (list \"10.0.0.1\" \"10.0.0.2\") (list \"bar.com\" \"bat.com\") 365 $ca\n</code></pre>"},{"location":"chart_template_guide/function_list/#encryptaes","title":"encryptAES","text":"<p>The <code>encryptAES</code> function encrypts text with AES-256 CBC and returns a base64 encoded string.</p> <pre><code>encryptAES \"secretkey\" \"plaintext\"\n</code></pre>"},{"location":"chart_template_guide/function_list/#decryptaes","title":"decryptAES","text":"<p>The <code>decryptAES</code> function receives a base64 string encoded by the AES-256 CBC algorithm and returns the decoded text.</p> <pre><code>\"30tEfhuJSVRhpG97XCuWgz2okj7L8vQ1s6V9zVUPeDQ=\" | decryptAES \"secretkey\"\n</code></pre>"},{"location":"chart_template_guide/function_list/#date-functions","title":"Date Functions","text":"<p>Helm includes the following date functions you can use in templates: ago, date, dateInZone, dateModify (mustDateModify), duration, durationRound, htmlDate, htmlDateInZone, now, toDate (mustToDate), and unixEpoch.</p>"},{"location":"chart_template_guide/function_list/#now","title":"now","text":"<p>The current date/time. Use this in conjunction with other date functions.</p>"},{"location":"chart_template_guide/function_list/#ago","title":"ago","text":"<p>The <code>ago</code> function returns duration from time. Now in seconds resolution.</p> <pre><code>ago .CreatedAt\n</code></pre> <p>returns in <code>time.Duration</code> String() format</p> <pre><code>2h34m7s\n</code></pre>"},{"location":"chart_template_guide/function_list/#date","title":"date","text":"<p>The <code>date</code> function formats a date.</p> <p>Format the date to YEAR-MONTH-DAY:</p> <pre><code>now | date \"2006-01-02\"\n</code></pre> <p>Date formatting in Go is a little bit different.</p> <p>In short, take this as the base date:</p> <pre><code>Mon Jan 2 15:04:05 MST 2006\n</code></pre> <p>Write it in the format you want. Above, <code>2006-01-02</code> is the same date, but in the format we want.</p>"},{"location":"chart_template_guide/function_list/#dateinzone","title":"dateInZone","text":"<p>Same as <code>date</code>, but with a timezone.</p> <pre><code>dateInZone \"2006-01-02\" (now) \"UTC\"\n</code></pre>"},{"location":"chart_template_guide/function_list/#duration","title":"duration","text":"<p>Formats a given amount of seconds as a <code>time.Duration</code>.</p> <p>This returns 1m35s</p> <pre><code>duration \"95\"\n</code></pre>"},{"location":"chart_template_guide/function_list/#durationround","title":"durationRound","text":"<p>Rounds a given duration to the most significant unit. Strings and <code>time.Duration</code> gets parsed as a duration, while a <code>time.Time</code> is calculated as the duration since.</p> <p>This return 2h</p> <pre><code>durationRound \"2h10m5s\"\n</code></pre> <p>This returns 3mo</p> <pre><code>durationRound \"2400h10m5s\"\n</code></pre>"},{"location":"chart_template_guide/function_list/#unixepoch","title":"unixEpoch","text":"<p>Returns the seconds since the unix epoch for a <code>time.Time</code>.</p> <pre><code>now | unixEpoch\n</code></pre>"},{"location":"chart_template_guide/function_list/#datemodify-mustdatemodify","title":"dateModify, mustDateModify","text":"<p>The <code>dateModify</code> takes a modification and a date and returns the timestamp.</p> <p>Subtract an hour and thirty minutes from the current time:</p> <pre><code>now | dateModify \"-1.5h\"\n</code></pre> <p>If the modification format is wrong <code>dateModify</code> will return the date unmodified. <code>mustDateModify</code> will return an error otherwise.</p>"},{"location":"chart_template_guide/function_list/#htmldate","title":"htmlDate","text":"<p>The <code>htmlDate</code> function formats a date for inserting into an HTML date picker input field.</p> <pre><code>now | htmlDate\n</code></pre>"},{"location":"chart_template_guide/function_list/#htmldateinzone","title":"htmlDateInZone","text":"<p>Same as htmlDate, but with a timezone.</p> <pre><code>htmlDateInZone (now) \"UTC\"\n</code></pre>"},{"location":"chart_template_guide/function_list/#todate-musttodate","title":"toDate, mustToDate","text":"<p><code>toDate</code> converts a string to a date. The first argument is the date layout and the second the date string. If the string can't be convert it returns the zero value. <code>mustToDate</code> will return an error in case the string cannot be converted.</p> <p>This is useful when you want to convert a string date to another format (using pipe). The example below converts \"2017-12-31\" to \"31/12/2017\".</p> <pre><code>toDate \"2006-01-02\" \"2017-12-31\" | date \"02/01/2006\"\n</code></pre>"},{"location":"chart_template_guide/function_list/#dictionaries-and-dict-functions","title":"Dictionaries and Dict Functions","text":"<p>Helm provides a key/value storage type called a <code>dict</code> (short for \"dictionary\", as in Python). A <code>dict</code> is an unordered type.</p> <p>The key to a dictionary must be a string. However, the value can be any type, even another <code>dict</code> or <code>list</code>.</p> <p>Unlike <code>list</code>s, <code>dict</code>s are not immutable. The <code>set</code> and <code>unset</code> functions will modify the contents of a dictionary.</p> <p>Helm provides the following functions to support working with dicts: deepCopy (mustDeepCopy), dict, dig, get, hasKey, keys, merge (mustMerge), mergeOverwrite (mustMergeOverwrite), omit, pick, pluck, set, unset, and values.</p>"},{"location":"chart_template_guide/function_list/#dict","title":"dict","text":"<p>Creating dictionaries is done by calling the <code>dict</code> function and passing it a list of pairs.</p> <p>The following creates a dictionary with three items:</p> <pre><code>$myDict := dict \"name1\" \"value1\" \"name2\" \"value2\" \"name3\" \"value 3\"\n</code></pre>"},{"location":"chart_template_guide/function_list/#get","title":"get","text":"<p>Given a map and a key, get the value from the map.</p> <pre><code>get $myDict \"name1\"\n</code></pre> <p>The above returns <code>\"value1\"</code></p> <p>Note that if the key is not found, this operation will simply return <code>\"\"</code>. No error will be generated.</p>"},{"location":"chart_template_guide/function_list/#set","title":"set","text":"<p>Use <code>set</code> to add a new key/value pair to a dictionary.</p> <pre><code>$_ := set $myDict \"name4\" \"value4\"\n</code></pre> <p>Note that <code>set</code> returns the dictionary (a requirement of Go template functions), so you may need to trap the value as done above with the <code>$_</code> assignment.</p>"},{"location":"chart_template_guide/function_list/#unset","title":"unset","text":"<p>Given a map and a key, delete the key from the map.</p> <pre><code>$_ := unset $myDict \"name4\"\n</code></pre> <p>As with <code>set</code>, this returns the dictionary.</p> <p>Note that if the key is not found, this operation will simply return. No error will be generated.</p>"},{"location":"chart_template_guide/function_list/#haskey","title":"hasKey","text":"<p>The <code>hasKey</code> function returns <code>true</code> if the given dict contains the given key.</p> <pre><code>hasKey $myDict \"name1\"\n</code></pre> <p>If the key is not found, this returns <code>false</code>.</p>"},{"location":"chart_template_guide/function_list/#pluck","title":"pluck","text":"<p>The <code>pluck</code> function makes it possible to give one key and multiple maps, and get a list of all of the matches:</p> <pre><code>pluck \"name1\" $myDict $myOtherDict\n</code></pre> <p>The above will return a <code>list</code> containing every found value (<code>[value1 otherValue1]</code>).</p> <p>If the given key is not found in a map, that map will not have an item in the list (and the length of the returned list will be less than the number of dicts in the call to <code>pluck</code>).</p> <p>If the key is found but the value is an empty value, that value will be inserted.</p> <p>A common idiom in Helm templates is to use <code>pluck... | first</code> to get the first matching key out of a collection of dictionaries.</p>"},{"location":"chart_template_guide/function_list/#dig","title":"dig","text":"<p>The <code>dig</code> function traverses a nested set of dicts, selecting keys from a list of values. It returns a default value if any of the keys are not found at the associated dict.</p> <pre><code>dig \"user\" \"role\" \"humanName\" \"guest\" $dict\n</code></pre> <p>Given a dict structured like</p> <pre><code>{\n  user: {\n    role: {\n      humanName: \"curator\"\n    }\n  }\n}\n</code></pre> <p>the above would return <code>\"curator\"</code>. If the dict lacked even a <code>user</code> field, the result would be <code>\"guest\"</code>.</p> <p>Dig can be very useful in cases where you'd like to avoid guard clauses, especially since Go's template package's <code>and</code> doesn't shortcut. For instance <code>and a.maybeNil a.maybeNil.iNeedThis</code> will always evaluate <code>a.maybeNil.iNeedThis</code>, and panic if <code>a</code> lacks a <code>maybeNil</code> field.)</p> <p><code>dig</code> accepts its dict argument last in order to support pipelining. For instance:</p> <pre><code>merge a b c | dig \"one\" \"two\" \"three\" \"&lt;missing&gt;\"\n</code></pre>"},{"location":"chart_template_guide/function_list/#merge-mustmerge","title":"merge, mustMerge","text":"<p>Merge two or more dictionaries into one, giving precedence to the dest dictionary:</p> <p>Given:</p> <pre><code>dst:\n  default: default\n  overwrite: me\n  key: true\n\nsrc:\n  overwrite: overwritten\n  key: false\n</code></pre> <p>will result in:</p> <pre><code>newdict:\n  default: default\n  overwrite: me\n  key: true\n</code></pre> <pre><code>$newdict := merge $dest $source1 $source2\n</code></pre> <p>This is a deep merge operation but not a deep copy operation. Nested objects that are merged are the same instance on both dicts. If you want a deep copy along with the merge, then use the <code>deepCopy</code> function along with merging. For example,</p> <pre><code>deepCopy $source | merge $dest\n</code></pre> <p><code>mustMerge</code> will return an error in case of unsuccessful merge.</p>"},{"location":"chart_template_guide/function_list/#mergeoverwrite-mustmergeoverwrite","title":"mergeOverwrite, mustMergeOverwrite","text":"<p>Merge two or more dictionaries into one, giving precedence from right to left, effectively overwriting values in the dest dictionary:</p> <p>Given:</p> <pre><code>dst:\n  default: default\n  overwrite: me\n  key: true\n\nsrc:\n  overwrite: overwritten\n  key: false\n</code></pre> <p>will result in:</p> <pre><code>newdict:\n  default: default\n  overwrite: overwritten\n  key: false\n</code></pre> <pre><code>$newdict := mergeOverwrite $dest $source1 $source2\n</code></pre> <p>This is a deep merge operation but not a deep copy operation. Nested objects that are merged are the same instance on both dicts. If you want a deep copy along with the merge then use the <code>deepCopy</code> function along with merging. For example,</p> <pre><code>deepCopy $source | mergeOverwrite $dest\n</code></pre> <p><code>mustMergeOverwrite</code> will return an error in case of unsuccessful merge.</p>"},{"location":"chart_template_guide/function_list/#keys","title":"keys","text":"<p>The <code>keys</code> function will return a <code>list</code> of all of the keys in one or more <code>dict</code> types. Since a dictionary is unordered, the keys will not be in a predictable order. They can be sorted with <code>sortAlpha</code>.</p> <pre><code>keys $myDict | sortAlpha\n</code></pre> <p>When supplying multiple dictionaries, the keys will be concatenated. Use the <code>uniq</code> function along with <code>sortAlpha</code> to get a unique, sorted list of keys.</p> <pre><code>keys $myDict $myOtherDict | uniq | sortAlpha\n</code></pre>"},{"location":"chart_template_guide/function_list/#pick","title":"pick","text":"<p>The <code>pick</code> function selects just the given keys out of a dictionary, creating a new <code>dict</code>.</p> <pre><code>$new := pick $myDict \"name1\" \"name2\"\n</code></pre> <p>The above returns <code>{name1: value1, name2: value2}</code></p>"},{"location":"chart_template_guide/function_list/#omit","title":"omit","text":"<p>The <code>omit</code> function is similar to <code>pick</code>, except it returns a new <code>dict</code> with all the keys that do not match the given keys.</p> <pre><code>$new := omit $myDict \"name1\" \"name3\"\n</code></pre> <p>The above returns <code>{name2: value2}</code></p>"},{"location":"chart_template_guide/function_list/#values","title":"values","text":"<p>The <code>values</code> function is similar to <code>keys</code>, except it returns a new <code>list</code> with all the values of the source <code>dict</code> (only one dictionary is supported).</p> <pre><code>$vals := values $myDict\n</code></pre> <p>The above returns <code>list[\"value1\", \"value2\", \"value 3\"]</code>. Note that the <code>values</code> function gives no guarantees about the result ordering; if you care about this, then use <code>sortAlpha</code>.</p>"},{"location":"chart_template_guide/function_list/#deepcopy-mustdeepcopy","title":"deepCopy, mustDeepCopy","text":"<p>The <code>deepCopy</code> and <code>mustDeepCopy</code> functions take a value and make a deep copy of the value. This includes dicts and other structures. <code>deepCopy</code> panics when there is a problem, while <code>mustDeepCopy</code> returns an error to the template system when there is an error.</p> <pre><code>dict \"a\" 1 \"b\" 2 | deepCopy\n</code></pre>"},{"location":"chart_template_guide/function_list/#a-note-on-dict-internals","title":"A Note on Dict Internals","text":"<p>A <code>dict</code> is implemented in Go as a <code>map[string]interface{}</code>. Go developers can pass <code>map[string]interface{}</code> values into the context to make them available to templates as <code>dict</code>s.</p>"},{"location":"chart_template_guide/function_list/#encoding-functions","title":"Encoding Functions","text":"<p>Helm has the following encoding and decoding functions:</p> <ul> <li><code>b64enc</code>/<code>b64dec</code>: Encode or decode with Base64</li> <li><code>b32enc</code>/<code>b32dec</code>: Encode or decode with Base32</li> </ul>"},{"location":"chart_template_guide/function_list/#lists-and-list-functions","title":"Lists and List Functions","text":"<p>Helm provides a simple <code>list</code> type that can contain arbitrary sequential lists of data. This is similar to arrays or slices, but lists are designed to be used as immutable data types.</p> <p>Create a list of integers:</p> <pre><code>$myList := list 1 2 3 4 5\n</code></pre> <p>The above creates a list of <code>[1 2 3 4 5]</code>.</p> <p>Helm provides the following list functions: append (mustAppend), compact (mustCompact), concat, first (mustFirst), has (mustHas), initial (mustInitial), last (mustLast), prepend (mustPrepend), rest (mustRest), reverse (mustReverse), seq, index, slice (mustSlice), uniq (mustUniq), until, untilStep, and without (mustWithout).</p>"},{"location":"chart_template_guide/function_list/#first-mustfirst","title":"first, mustFirst","text":"<p>To get the head item on a list, use <code>first</code>.</p> <p><code>first $myList</code> returns <code>1</code></p> <p><code>first</code> panics if there is a problem, while <code>mustFirst</code> returns an error to the template engine if there is a problem.</p>"},{"location":"chart_template_guide/function_list/#rest-mustrest","title":"rest, mustRest","text":"<p>To get the tail of the list (everything but the first item), use <code>rest</code>.</p> <p><code>rest $myList</code> returns <code>[2 3 4 5]</code></p> <p><code>rest</code> panics if there is a problem, while <code>mustRest</code> returns an error to the template engine if there is a problem.</p>"},{"location":"chart_template_guide/function_list/#last-mustlast","title":"last, mustLast","text":"<p>To get the last item on a list, use <code>last</code>:</p> <p><code>last $myList</code> returns <code>5</code>. This is roughly analogous to reversing a list and then calling <code>first</code>.</p>"},{"location":"chart_template_guide/function_list/#initial-mustinitial","title":"initial, mustInitial","text":"<p>This compliments <code>last</code> by returning all but the last element. <code>initial $myList</code> returns <code>[1 2 3 4]</code>.</p> <p><code>initial</code> panics if there is a problem, while <code>mustInitial</code> returns an error to the template engine if there is a problem.</p>"},{"location":"chart_template_guide/function_list/#append-mustappend","title":"append, mustAppend","text":"<p>Append a new item to an existing list, creating a new list.</p> <pre><code>$new = append $myList 6\n</code></pre> <p>The above would set <code>$new</code> to <code>[1 2 3 4 5 6]</code>. <code>$myList</code> would remain unaltered.</p> <p><code>append</code> panics if there is a problem, while <code>mustAppend</code> returns an error to the template engine if there is a problem.</p>"},{"location":"chart_template_guide/function_list/#prepend-mustprepend","title":"prepend, mustPrepend","text":"<p>Push an element onto the front of a list, creating a new list.</p> <pre><code>prepend $myList 0\n</code></pre> <p>The above would produce <code>[0 1 2 3 4 5]</code>. <code>$myList</code> would remain unaltered.</p> <p><code>prepend</code> panics if there is a problem, while <code>mustPrepend</code> returns an error to the template engine if there is a problem.</p>"},{"location":"chart_template_guide/function_list/#concat","title":"concat","text":"<p>Concatenate arbitrary number of lists into one.</p> <pre><code>concat $myList ( list 6 7 ) ( list 8 )\n</code></pre> <p>The above would produce <code>[1 2 3 4 5 6 7 8]</code>. <code>$myList</code> would remain unaltered.</p>"},{"location":"chart_template_guide/function_list/#reverse-mustreverse","title":"reverse, mustReverse","text":"<p>Produce a new list with the reversed elements of the given list.</p> <pre><code>reverse $myList\n</code></pre> <p>The above would generate the list <code>[5 4 3 2 1]</code>.</p> <p><code>reverse</code> panics if there is a problem, while <code>mustReverse</code> returns an error to the template engine if there is a problem.</p>"},{"location":"chart_template_guide/function_list/#uniq-mustuniq","title":"uniq, mustUniq","text":"<p>Generate a list with all of the duplicates removed.</p> <pre><code>list 1 1 1 2 | uniq\n</code></pre> <p>The above would produce <code>[1 2]</code></p> <p><code>uniq</code> panics if there is a problem, while <code>mustUniq</code> returns an error to the template engine if there is a problem.</p>"},{"location":"chart_template_guide/function_list/#without-mustwithout","title":"without, mustWithout","text":"<p>The <code>without</code> function filters items out of a list.</p> <pre><code>without $myList 3\n</code></pre> <p>The above would produce <code>[1 2 4 5]</code></p> <p><code>without</code> can take more than one filter:</p> <pre><code>without $myList 1 3 5\n</code></pre> <p>That would produce <code>[2 4]</code></p> <p><code>without</code> panics if there is a problem, while <code>mustWithout</code> returns an error to the template engine if there is a problem.</p>"},{"location":"chart_template_guide/function_list/#has-musthas","title":"has, mustHas","text":"<p>Test to see if a list has a particular element.</p> <pre><code>has 4 $myList\n</code></pre> <p>The above would return <code>true</code>, while <code>has \"hello\" $myList</code> would return false.</p> <p><code>has</code> panics if there is a problem, while <code>mustHas</code> returns an error to the template engine if there is a problem.</p>"},{"location":"chart_template_guide/function_list/#compact-mustcompact","title":"compact, mustCompact","text":"<p>Accepts a list and removes entries with empty values.</p> <pre><code>$list := list 1 \"a\" \"foo\" \"\"\n$copy := compact $list\n</code></pre> <p><code>compact</code> will return a new list with the empty (i.e., \"\") item removed.</p> <p><code>compact</code> panics if there is a problem and <code>mustCompact</code> returns an error to the template engine if there is a problem.</p>"},{"location":"chart_template_guide/function_list/#index","title":"index","text":"<p>To get the nth element of a list, use <code>index list [n]</code>. To index into  multi-dimensional lists, use <code>index list [n] [m] ...</code> - <code>index $myList 0</code> returns <code>1</code>. It is the same as <code>myList[0]</code> - <code>index $myList 0 1</code> would be the same as <code>myList[0][1]</code></p>"},{"location":"chart_template_guide/function_list/#slice-mustslice","title":"slice, mustSlice","text":"<p>To get partial elements of a list, use <code>slice list [n] [m]</code>. It is equivalent of <code>list[n:m]</code>.</p> <ul> <li><code>slice $myList</code> returns <code>[1 2 3 4 5]</code>. It is same as <code>myList[:]</code>.</li> <li><code>slice $myList 3</code> returns <code>[4 5]</code>. It is same as <code>myList[3:]</code>.</li> <li><code>slice $myList 1 3</code> returns <code>[2 3]</code>. It is same as <code>myList[1:3]</code>.</li> <li><code>slice $myList 0 3</code> returns <code>[1 2 3]</code>. It is same as <code>myList[:3]</code>.</li> </ul> <p><code>slice</code> panics if there is a problem, while <code>mustSlice</code> returns an error to the template engine if there is a problem.</p>"},{"location":"chart_template_guide/function_list/#until","title":"until","text":"<p>The <code>until</code> function builds a range of integers.</p> <pre><code>until 5\n</code></pre> <p>The above generates the list <code>[0, 1, 2, 3, 4]</code>.</p> <p>This is useful for looping with <code>range $i, $e := until 5</code>.</p>"},{"location":"chart_template_guide/function_list/#untilstep","title":"untilStep","text":"<p>Like <code>until</code>, <code>untilStep</code> generates a list of counting integers. But it allows you to define a start, stop, and step:</p> <pre><code>untilStep 3 6 2\n</code></pre> <p>The above will produce <code>[3 5]</code> by starting with 3, and adding 2 until it is equal or greater than 6. This is similar to Python's <code>range</code> function.</p>"},{"location":"chart_template_guide/function_list/#seq","title":"seq","text":"<p>Works like the bash <code>seq</code> command.</p> <ul> <li>1 parameter  (end) - will generate all counting integers between 1 and <code>end</code>   inclusive.</li> <li>2 parameters (start, end) - will generate all counting integers between   <code>start</code> and <code>end</code> inclusive incrementing or decrementing by 1.</li> <li>3 parameters (start, step, end) - will generate all counting integers between   <code>start</code> and <code>end</code> inclusive incrementing or decrementing by <code>step</code>.</li> </ul> <pre><code>seq 5       =&gt; 1 2 3 4 5\nseq -3      =&gt; 1 0 -1 -2 -3\nseq 0 2     =&gt; 0 1 2\nseq 2 -2    =&gt; 2 1 0 -1 -2\nseq 0 2 10  =&gt; 0 2 4 6 8 10\nseq 0 -2 -5 =&gt; 0 -2 -4\n</code></pre>"},{"location":"chart_template_guide/function_list/#math-functions","title":"Math Functions","text":"<p>All math functions operate on <code>int64</code> values unless specified otherwise.</p> <p>The following math functions are available: add, add1, ceil, div, floor, len, max, min, mod, mul, round, and sub.</p>"},{"location":"chart_template_guide/function_list/#add","title":"add","text":"<p>Sum numbers with <code>add</code>. Accepts two or more inputs.</p> <pre><code>add 1 2 3\n</code></pre>"},{"location":"chart_template_guide/function_list/#add1","title":"add1","text":"<p>To increment by 1, use <code>add1</code>.</p>"},{"location":"chart_template_guide/function_list/#sub","title":"sub","text":"<p>To subtract, use <code>sub</code>.</p>"},{"location":"chart_template_guide/function_list/#div","title":"div","text":"<p>Perform integer division with <code>div</code>.</p>"},{"location":"chart_template_guide/function_list/#mod","title":"mod","text":"<p>Modulo with <code>mod</code>.</p>"},{"location":"chart_template_guide/function_list/#mul","title":"mul","text":"<p>Multiply with <code>mul</code>. Accepts two or more inputs.</p> <pre><code>mul 1 2 3\n</code></pre>"},{"location":"chart_template_guide/function_list/#max","title":"max","text":"<p>Return the largest of a series of integers.</p> <p>This will return <code>3</code>:</p> <pre><code>max 1 2 3\n</code></pre>"},{"location":"chart_template_guide/function_list/#min","title":"min","text":"<p>Return the smallest of a series of integers.</p> <p><code>min 1 2 3</code> will return <code>1</code>.</p>"},{"location":"chart_template_guide/function_list/#len","title":"len","text":"<p>Returns the length of the argument as an integer.</p> <pre><code>len .Arg\n</code></pre>"},{"location":"chart_template_guide/function_list/#float-math-functions","title":"Float Math Functions","text":"<p>All math functions operate on <code>float64</code> values.</p>"},{"location":"chart_template_guide/function_list/#addf","title":"addf","text":"<p>Sum numbers with <code>addf</code></p> <p>This will return <code>5.5</code>:</p> <pre><code>addf 1.5 2 2\n</code></pre>"},{"location":"chart_template_guide/function_list/#add1f","title":"add1f","text":"<p>To increment by 1, use <code>add1f</code></p>"},{"location":"chart_template_guide/function_list/#subf","title":"subf","text":"<p>To subtract, use <code>subf</code></p> <p>This is equivalent to <code>7.5 - 2 - 3</code> and will return <code>2.5</code>:</p> <pre><code>subf 7.5 2 3\n</code></pre>"},{"location":"chart_template_guide/function_list/#divf","title":"divf","text":"<p>Perform integer division with <code>divf</code></p> <p>This is equivalent to <code>10 / 2 / 4</code> and will return <code>1.25</code>:</p> <pre><code>divf 10 2 4\n</code></pre>"},{"location":"chart_template_guide/function_list/#mulf","title":"mulf","text":"<p>Multiply with <code>mulf</code></p> <p>This will return <code>6</code>:</p> <pre><code>mulf 1.5 2 2\n</code></pre>"},{"location":"chart_template_guide/function_list/#maxf","title":"maxf","text":"<p>Return the largest of a series of floats:</p> <p>This will return <code>3</code>:</p> <pre><code>maxf 1 2.5 3\n</code></pre>"},{"location":"chart_template_guide/function_list/#minf","title":"minf","text":"<p>Return the smallest of a series of floats.</p> <p>This will return <code>1.5</code>:</p> <pre><code>minf 1.5 2 3\n</code></pre>"},{"location":"chart_template_guide/function_list/#floor","title":"floor","text":"<p>Returns the greatest float value less than or equal to input value.</p> <p><code>floor 123.9999</code> will return <code>123.0</code>.</p>"},{"location":"chart_template_guide/function_list/#ceil","title":"ceil","text":"<p>Returns the greatest float value greater than or equal to input value.</p> <p><code>ceil 123.001</code> will return <code>124.0</code>.</p>"},{"location":"chart_template_guide/function_list/#round","title":"round","text":"<p>Returns a float value with the remainder rounded to the given number to digits after the decimal point.</p> <p><code>round 123.555555 3</code> will return <code>123.556</code>.</p>"},{"location":"chart_template_guide/function_list/#network-functions","title":"Network Functions","text":"<p>Helm has a single network function, <code>getHostByName</code>.</p> <p>The <code>getHostByName</code> receives a domain name and returns the ip address.</p> <p><code>getHostByName \"www.google.com\"</code> would return the corresponding ip address of <code>www.google.com</code>.</p>"},{"location":"chart_template_guide/function_list/#file-path-functions","title":"File Path Functions","text":"<p>While Helm template functions do not grant access to the filesystem, they do provide functions for working with strings that follow file path conventions. Those include base, clean, dir, ext, and isAbs.</p>"},{"location":"chart_template_guide/function_list/#base","title":"base","text":"<p>Return the last element of a path.</p> <pre><code>base \"foo/bar/baz\"\n</code></pre> <p>The above prints \"baz\".</p>"},{"location":"chart_template_guide/function_list/#dir","title":"dir","text":"<p>Return the directory, stripping the last part of the path. So <code>dir \"foo/bar/baz\"</code> returns <code>foo/bar</code>.</p>"},{"location":"chart_template_guide/function_list/#clean","title":"clean","text":"<p>Clean up a path.</p> <pre><code>clean \"foo/bar/../baz\"\n</code></pre> <p>The above resolves the <code>..</code> and returns <code>foo/baz</code>.</p>"},{"location":"chart_template_guide/function_list/#ext","title":"ext","text":"<p>Return the file extension.</p> <pre><code>ext \"foo.bar\"\n</code></pre> <p>The above returns <code>.bar</code>.</p>"},{"location":"chart_template_guide/function_list/#isabs","title":"isAbs","text":"<p>To check whether a file path is absolute, use <code>isAbs</code>.</p>"},{"location":"chart_template_guide/function_list/#reflection-functions","title":"Reflection Functions","text":"<p>Helm provides rudimentary reflection tools. These help advanced template developers understand the underlying Go type information for a particular value. Helm is written in Go and is strongly typed. The type system applies within templates.</p> <p>Go has several primitive kinds, like <code>string</code>, <code>slice</code>, <code>int64</code>, and <code>bool</code>.</p> <p>Go has an open type system that allows developers to create their own types.</p> <p>Helm provides a set of functions for each via kind functions and type functions. A deepEqual function is also provided to compare to values.</p>"},{"location":"chart_template_guide/function_list/#kind-functions","title":"Kind Functions","text":"<p>There are two Kind functions: <code>kindOf</code> returns the kind of an object.</p> <pre><code>kindOf \"hello\"\n</code></pre> <p>The above would return <code>string</code>. For simple tests (like in <code>if</code> blocks), the <code>kindIs</code> function will let you verify that a value is a particular kind:</p> <pre><code>kindIs \"int\" 123\n</code></pre> <p>The above will return <code>true</code>.</p>"},{"location":"chart_template_guide/function_list/#type-functions","title":"Type Functions","text":"<p>Types are slightly harder to work with, so there are three different functions:</p> <ul> <li><code>typeOf</code> returns the underlying type of a value: <code>typeOf $foo</code></li> <li><code>typeIs</code> is like <code>kindIs</code>, but for types: <code>typeIs \"*io.Buffer\" $myVal</code></li> <li><code>typeIsLike</code> works as <code>typeIs</code>, except that it also dereferences pointers</li> </ul> <p>Note: None of these can test whether or not something implements a given interface, since doing so would require compiling the interface in ahead of time.</p>"},{"location":"chart_template_guide/function_list/#deepequal","title":"deepEqual","text":"<p><code>deepEqual</code> returns true if two values are \"deeply equal\"</p> <p>Works for non-primitive types as well (compared to the built-in <code>eq</code>).</p> <pre><code>deepEqual (list 1 2 3) (list 1 2 3)\n</code></pre> <p>The above will return <code>true</code>.</p>"},{"location":"chart_template_guide/function_list/#semantic-version-functions","title":"Semantic Version Functions","text":"<p>Some version schemes are easily parseable and comparable. Helm provides functions for working with SemVer 2 versions. These include semver and semverCompare. Below you will also find details on using ranges for comparisons.</p>"},{"location":"chart_template_guide/function_list/#semver","title":"semver","text":"<p>The <code>semver</code> function parses a string into a Semantic Version:</p> <pre><code>$version := semver \"1.2.3-alpha.1+123\"\n</code></pre> <p>If the parser fails, it will cause template execution to halt with an error.</p> <p>At this point, <code>$version</code> is a pointer to a <code>Version</code> object with the following properties:</p> <ul> <li><code>$version.Major</code>: The major number (<code>1</code> above)</li> <li><code>$version.Minor</code>: The minor number (<code>2</code> above)</li> <li><code>$version.Patch</code>: The patch number (<code>3</code> above)</li> <li><code>$version.Prerelease</code>: The prerelease (<code>alpha.1</code> above)</li> <li><code>$version.Metadata</code>: The build metadata (<code>123</code> above)</li> <li><code>$version.Original</code>: The original version as a string</li> </ul> <p>Additionally, you can compare a <code>Version</code> to another <code>version</code> using the <code>Compare</code> function:</p> <pre><code>semver \"1.4.3\" | (semver \"1.2.3\").Compare\n</code></pre> <p>The above will return <code>-1</code>.</p> <p>The return values are:</p> <ul> <li><code>-1</code> if the given semver is greater than the semver whose <code>Compare</code> method was   called</li> <li><code>1</code> if the version who's <code>Compare</code> function was called is greater.</li> <li><code>0</code> if they are the same version</li> </ul> <p>(Note that in SemVer, the <code>Metadata</code> field is not compared during version comparison operations.)</p>"},{"location":"chart_template_guide/function_list/#semvercompare","title":"semverCompare","text":"<p>A more robust comparison function is provided as <code>semverCompare</code>. This version supports version ranges:</p> <ul> <li><code>semverCompare \"1.2.3\" \"1.2.3\"</code> checks for an exact match</li> <li><code>semverCompare \"~1.2.0\" \"1.2.3\"</code> checks that the major and minor versions   match, and that the patch number of the second version is greater than or   equal to the first parameter.</li> </ul> <p>The SemVer functions use the Masterminds semver library, from the creators of Sprig.</p>"},{"location":"chart_template_guide/function_list/#basic-comparisons","title":"Basic Comparisons","text":"<p>There are two elements to the comparisons. First, a comparison string is a list of space or comma separated AND comparisons. These are then separated by || (OR) comparisons. For example, <code>\"&gt;= 1.2 &lt; 3.0.0 || &gt;= 4.2.3\"</code> is looking for a comparison that's greater than or equal to 1.2 and less than 3.0.0 or is greater than or equal to 4.2.3.</p> <p>The basic comparisons are:</p> <ul> <li><code>=</code>: equal (aliased to no operator)</li> <li><code>!=</code>: not equal</li> <li><code>&gt;</code>: greater than</li> <li><code>&lt;</code>: less than</li> <li><code>&gt;=</code>: greater than or equal to</li> <li><code>&lt;=</code>: less than or equal to</li> </ul>"},{"location":"chart_template_guide/function_list/#working-with-prerelease-versions","title":"Working With Prerelease Versions","text":"<p>Pre-releases, for those not familiar with them, are used for software releases prior to stable or generally available releases. Examples of prereleases include development, alpha, beta, and release candidate releases. A prerelease may be a version such as <code>1.2.3-beta.1</code>, while the stable release would be <code>1.2.3</code>. In the order of precedence, prereleases come before their associated releases. In this example <code>1.2.3-beta.1 &lt; 1.2.3</code>.</p> <p>According to the Semantic Version specification prereleases may not be API compliant with their release counterpart. It says,</p> <p>A pre-release version indicates that the version is unstable and might not satisfy the intended compatibility requirements as denoted by its associated normal version.</p> <p>SemVer comparisons using constraints without a prerelease comparator will skip prerelease versions. For example, <code>&gt;=1.2.3</code> will skip prereleases when looking at a list of releases, while <code>&gt;=1.2.3-0</code> will evaluate and find prereleases.</p> <p>The reason for the <code>0</code> as a pre-release version in the example comparison is because pre-releases can only contain ASCII alphanumerics and hyphens (along with <code>.</code> separators), per the spec. Sorting happens in ASCII sort order, again per the spec. The lowest character is a <code>0</code> in ASCII sort order (see an ASCII Table)</p> <p>Understanding ASCII sort ordering is important because A-Z comes before a-z. That means <code>&gt;=1.2.3-BETA</code> will return <code>1.2.3-alpha</code>. What you might expect from case sensitivity doesn't apply here. This is due to ASCII sort ordering which is what the spec specifies.</p>"},{"location":"chart_template_guide/function_list/#hyphen-range-comparisons","title":"Hyphen Range Comparisons","text":"<p>There are multiple methods to handle ranges and the first is hyphens ranges. These look like:</p> <ul> <li><code>1.2 - 1.4.5</code> which is equivalent to <code>&gt;= 1.2 &lt;= 1.4.5</code></li> <li><code>2.3.4 - 4.5</code> which is equivalent to <code>&gt;= 2.3.4 &lt;= 4.5</code></li> </ul>"},{"location":"chart_template_guide/function_list/#wildcards-in-comparisons","title":"Wildcards In Comparisons","text":"<p>The <code>x</code>, <code>X</code>, and <code>*</code> characters can be used as a wildcard character. This works for all comparison operators. When used on the <code>=</code> operator it falls back to the patch level comparison (see tilde below). For example,</p> <ul> <li><code>1.2.x</code> is equivalent to <code>&gt;= 1.2.0, &lt; 1.3.0</code></li> <li><code>&gt;= 1.2.x</code> is equivalent to <code>&gt;= 1.2.0</code></li> <li><code>&lt;= 2.x</code> is equivalent to <code>&lt; 3</code></li> <li><code>*</code> is equivalent to <code>&gt;= 0.0.0</code></li> </ul>"},{"location":"chart_template_guide/function_list/#tilde-range-comparisons-patch","title":"Tilde Range Comparisons (Patch)","text":"<p>The tilde (<code>~</code>) comparison operator is for patch level ranges when a minor version is specified and major level changes when the minor number is missing. For example,</p> <ul> <li><code>~1.2.3</code> is equivalent to <code>&gt;= 1.2.3, &lt; 1.3.0</code></li> <li><code>~1</code> is equivalent to <code>&gt;= 1, &lt; 2</code></li> <li><code>~2.3</code> is equivalent to <code>&gt;= 2.3, &lt; 2.4</code></li> <li><code>~1.2.x</code> is equivalent to <code>&gt;= 1.2.0, &lt; 1.3.0</code></li> <li><code>~1.x</code> is equivalent to <code>&gt;= 1, &lt; 2</code></li> </ul>"},{"location":"chart_template_guide/function_list/#caret-range-comparisons-major","title":"Caret Range Comparisons (Major)","text":"<p>The caret (<code>^</code>) comparison operator is for major level changes once a stable (1.0.0) release has occurred. Prior to a 1.0.0 release the minor versions acts as the API stability level. This is useful when comparisons of API versions as a major change is API breaking. For example,</p> <ul> <li><code>^1.2.3</code> is equivalent to <code>&gt;= 1.2.3, &lt; 2.0.0</code></li> <li><code>^1.2.x</code> is equivalent to <code>&gt;= 1.2.0, &lt; 2.0.0</code></li> <li><code>^2.3</code> is equivalent to <code>&gt;= 2.3, &lt; 3</code></li> <li><code>^2.x</code> is equivalent to <code>&gt;= 2.0.0, &lt; 3</code></li> <li><code>^0.2.3</code> is equivalent to <code>&gt;=0.2.3 &lt;0.3.0</code></li> <li><code>^0.2</code> is equivalent to <code>&gt;=0.2.0 &lt;0.3.0</code></li> <li><code>^0.0.3</code> is equivalent to <code>&gt;=0.0.3 &lt;0.0.4</code></li> <li><code>^0.0</code> is equivalent to <code>&gt;=0.0.0 &lt;0.1.0</code></li> <li><code>^0</code> is equivalent to <code>&gt;=0.0.0 &lt;1.0.0</code></li> </ul>"},{"location":"chart_template_guide/function_list/#url-functions","title":"URL Functions","text":"<p>Helm includes the urlParse, urlJoin, and urlquery functions enabling you to work with URL parts.</p>"},{"location":"chart_template_guide/function_list/#urlparse","title":"urlParse","text":"<p>Parses string for URL and produces dict with URL parts</p> <pre><code>urlParse \"http://admin:secret@server.com:8080/api?list=false#anchor\"\n</code></pre> <p>The above returns a dict, containing URL object:</p> <pre><code>scheme:   'http'\nhost:     'server.com:8080'\npath:     '/api'\nquery:    'list=false'\nopaque:   nil\nfragment: 'anchor'\nuserinfo: 'admin:secret'\n</code></pre> <p>This is implemented used the URL packages from the Go standard library. For more info, check https://golang.org/pkg/net/url/#URL</p>"},{"location":"chart_template_guide/function_list/#urljoin","title":"urlJoin","text":"<p>Joins map (produced by <code>urlParse</code>) to produce URL string</p> <pre><code>urlJoin (dict \"fragment\" \"fragment\" \"host\" \"host:80\" \"path\" \"/path\" \"query\" \"query\" \"scheme\" \"http\")\n</code></pre> <p>The above returns the following string:</p> <pre><code>http://host:80/path?query#fragment\n</code></pre>"},{"location":"chart_template_guide/function_list/#urlquery","title":"urlquery","text":"<p>Returns the escaped version of the value passed in as an argument so that it is suitable for embedding in the query portion of a URL.</p> <pre><code>$var := urlquery \"string for query\"\n</code></pre>"},{"location":"chart_template_guide/function_list/#uuid-functions","title":"UUID Functions","text":"<p>Helm can generate UUID v4 universally unique IDs.</p> <pre><code>uuidv4\n</code></pre> <p>The above returns a new UUID of the v4 (randomly generated) type.</p>"},{"location":"chart_template_guide/function_list/#kubernetes-and-chart-functions","title":"Kubernetes and Chart Functions","text":"<p>Helm includes functions for working with Kubernetes including .Capabilities.APIVersions.Has, Files, and lookup.</p>"},{"location":"chart_template_guide/function_list/#lookup","title":"lookup","text":"<p><code>lookup</code> is used to look up resource in a running cluster. When used with the <code>helm template</code> command it always returns an empty response.</p> <p>You can find more detail in the documentation on the lookup function.</p>"},{"location":"chart_template_guide/function_list/#capabilitiesapiversionshas","title":".Capabilities.APIVersions.Has","text":"<p>Returns if an API version or resource is available in a cluster.</p> <pre><code>.Capabilities.APIVersions.Has \"apps/v1\"\n.Capabilities.APIVersions.Has \"apps/v1/Deployment\"\n</code></pre> <p>More information is available on the built-in object documentation.</p>"},{"location":"chart_template_guide/function_list/#file-functions","title":"File Functions","text":"<p>There are several functions that enable you to get to non-special files within a chart. For example, to access application configuration files. These are documented in Accessing Files Inside Templates.</p> <p>Note, the documentation for many of these functions come from Sprig. Sprig is a template function library available to Go applications.</p>"},{"location":"chart_template_guide/functions_and_pipelines/","title":"Template Functions and Pipelines","text":"<p>So far, we've seen how to place information into a template. But that information is placed into the template unmodified. Sometimes we want to transform the supplied data in a way that makes it more useable to us.</p> <p>Let's start with a best practice: When injecting strings from the <code>.Values</code> object into the template, we ought to quote these strings. We can do that by calling the <code>quote</code> function in the template directive:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: {{ .Release.Name }}-configmap\ndata:\n  myvalue: \"Hello World\"\n  drink: {{ quote .Values.favorite.drink }}\n  food: {{ quote .Values.favorite.food }}\n</code></pre> <p>Template functions follow the syntax <code>functionName arg1 arg2...</code>. In the snippet above, <code>quote .Values.favorite.drink</code> calls the <code>quote</code> function and passes it a single argument.</p> <p>Helm has over 60 available functions. Some of them are defined by the Go template language itself. Most of the others are part of the Sprig template library. We'll see many of them as we progress through the examples.</p> <p>While we talk about the \"Helm template language\" as if it is Helm-specific, it is actually a combination of the Go template language, some extra functions, and a variety of wrappers to expose certain objects to the templates. Many resources on Go templates may be helpful as you learn about templating.</p>"},{"location":"chart_template_guide/functions_and_pipelines/#pipelines","title":"Pipelines","text":"<p>One of the powerful features of the template language is its concept of pipelines. Drawing on a concept from UNIX, pipelines are a tool for chaining together a series of template commands to compactly express a series of transformations. In other words, pipelines are an efficient way of getting several things done in sequence. Let's rewrite the above example using a pipeline.</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: {{ .Release.Name }}-configmap\ndata:\n  myvalue: \"Hello World\"\n  drink: {{ .Values.favorite.drink | quote }}\n  food: {{ .Values.favorite.food | quote }}\n</code></pre> <p>In this example, instead of calling <code>quote ARGUMENT</code>, we inverted the order. We \"sent\" the argument to the function using a pipeline (<code>|</code>): <code>.Values.favorite.drink | quote</code>. Using pipelines, we can chain several functions together:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: {{ .Release.Name }}-configmap\ndata:\n  myvalue: \"Hello World\"\n  drink: {{ .Values.favorite.drink | quote }}\n  food: {{ .Values.favorite.food | upper | quote }}\n</code></pre> <p>Inverting the order is a common practice in templates. You will see <code>.val | quote</code> more often than <code>quote .val</code>. Either practice is fine.</p> <p>When evaluated, that template will produce this:</p> <pre><code># Source: mychart/templates/configmap.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: trendsetting-p-configmap\ndata:\n  myvalue: \"Hello World\"\n  drink: \"coffee\"\n  food: \"PIZZA\"\n</code></pre> <p>Note that our original <code>pizza</code> has now been transformed to <code>\"PIZZA\"</code>.</p> <p>When pipelining arguments like this, the result of the first evaluation (<code>.Values.favorite.drink</code>) is sent as the last argument to the function. We can modify the drink example above to illustrate with a function that takes two arguments: <code>repeat COUNT STRING</code>:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: {{ .Release.Name }}-configmap\ndata:\n  myvalue: \"Hello World\"\n  drink: {{ .Values.favorite.drink | repeat 5 | quote }}\n  food: {{ .Values.favorite.food | upper | quote }}\n</code></pre> <p>The <code>repeat</code> function will echo the given string the given number of times, so we will get this for output:</p> <pre><code># Source: mychart/templates/configmap.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: melting-porcup-configmap\ndata:\n  myvalue: \"Hello World\"\n  drink: \"coffeecoffeecoffeecoffeecoffee\"\n  food: \"PIZZA\"\n</code></pre>"},{"location":"chart_template_guide/functions_and_pipelines/#using-the-default-function","title":"Using the <code>default</code> function","text":"<p>One function frequently used in templates is the <code>default</code> function: <code>default DEFAULT_VALUE GIVEN_VALUE</code>. This function allows you to specify a default value inside of the template, in case the value is omitted. Let's use it to modify the drink example above:</p> <pre><code>drink: {{ .Values.favorite.drink | default \"tea\" | quote }}\n</code></pre> <p>If we run this as normal, we'll get our <code>coffee</code>:</p> <pre><code># Source: mychart/templates/configmap.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: virtuous-mink-configmap\ndata:\n  myvalue: \"Hello World\"\n  drink: \"coffee\"\n  food: \"PIZZA\"\n</code></pre> <p>Now, we will remove the favorite drink setting from <code>values.yaml</code>:</p> <pre><code>favorite:\n  #drink: coffee\n  food: pizza\n</code></pre> <p>Now re-running <code>helm install --dry-run --debug fair-worm ./mychart</code> will produce this YAML:</p> <pre><code># Source: mychart/templates/configmap.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: fair-worm-configmap\ndata:\n  myvalue: \"Hello World\"\n  drink: \"tea\"\n  food: \"PIZZA\"\n</code></pre> <p>In an actual chart, all static default values should live in the <code>values.yaml</code>, and should not be repeated using the <code>default</code> command (otherwise they would be redundant). However, the <code>default</code> command is perfect for computed values, which cannot be declared inside <code>values.yaml</code>. For example:</p> <pre><code>drink: {{ .Values.favorite.drink | default (printf \"%s-tea\" (include \"fullname\" .)) }}\n</code></pre> <p>In some places, an <code>if</code> conditional guard may be better suited than <code>default</code>. We'll see those in the next section.</p> <p>Template functions and pipelines are a powerful way to transform information and then insert it into your YAML. But sometimes it's necessary to add some template logic that is a little more sophisticated than just inserting a string. In the next section we will look at the control structures provided by the template language.</p>"},{"location":"chart_template_guide/functions_and_pipelines/#using-the-lookup-function","title":"Using the <code>lookup</code> function","text":"<p>The <code>lookup</code> function can be used to look up resources in a running cluster. The synopsis of the lookup function is <code>lookup apiVersion, kind, namespace, name -&gt; resource or resource list</code>.</p> parameter type apiVersion string kind string namespace string name string <p>Both <code>name</code> and <code>namespace</code> are optional and can be passed as an empty string (<code>\"\"</code>). However, if you're working with a namespace-scoped resource, both <code>name</code> and <code>namespace</code> must be specified.</p> <p>The following combination of parameters are possible:</p> Behavior Lookup function <code>kubectl get pod mypod -n mynamespace</code> <code>lookup \"v1\" \"Pod\" \"mynamespace\" \"mypod\"</code> <code>kubectl get pods -n mynamespace</code> <code>lookup \"v1\" \"Pod\" \"mynamespace\" \"\"</code> <code>kubectl get pods --all-namespaces</code> <code>lookup \"v1\" \"Pod\" \"\" \"\"</code> <code>kubectl get namespace mynamespace</code> <code>lookup \"v1\" \"Namespace\" \"\" \"mynamespace\"</code> <code>kubectl get namespaces</code> <code>lookup \"v1\" \"Namespace\" \"\" \"\"</code> <p>When <code>lookup</code> returns an object, it will return a dictionary. This dictionary can be further navigated to extract specific values.</p> <p>The following example will return the annotations present for the <code>mynamespace</code> object:</p> <pre><code>(lookup \"v1\" \"Namespace\" \"\" \"mynamespace\").metadata.annotations\n</code></pre> <p>When <code>lookup</code> returns a list of objects, it is possible to access the object list via the <code>items</code> field:</p> <pre><code>{{ range $index, $service := (lookup \"v1\" \"Service\" \"mynamespace\" \"\").items }}\n    {{/* do something with each service */}}\n{{ end }}\n</code></pre> <p>When no object is found, an empty value is returned. This can be used to check for the existence of an object.</p> <p>The <code>lookup</code> function uses Helm's existing Kubernetes connection configuration to query Kubernetes. If any error is returned when interacting with calling the API server (for example due to lack of permission to access a resource), Helm's template processing will fail.</p> <p>Keep in mind that Helm is not supposed to contact the Kubernetes API Server during  a <code>helm template|install|upgrade|delete|rollback --dry-run</code> operation. To test <code>lookup</code>  against a running cluster, <code>helm template|install|upgrade|delete|rollback --dry-run=server</code> should be used instead to allow cluster connection.</p>"},{"location":"chart_template_guide/functions_and_pipelines/#operators-are-functions","title":"Operators are functions","text":"<p>For templates, the operators (<code>eq</code>, <code>ne</code>, <code>lt</code>, <code>gt</code>, <code>and</code>, <code>or</code> and so on) are all implemented as functions. In pipelines, operations can be grouped with parentheses (<code>(</code>, and <code>)</code>).</p> <p>Now we can turn from functions and pipelines to flow control with conditions, loops, and scope modifiers.</p>"},{"location":"chart_template_guide/getting_started/","title":"Getting Started","text":"<p>In this section of the guide, we'll create a chart and then add a first template. The chart we created here will be used throughout the rest of the guide.</p> <p>To get going, let's take a brief look at a Helm chart.</p>"},{"location":"chart_template_guide/getting_started/#charts","title":"Charts","text":"<p>As described in the Charts Guide, Helm charts are structured like this:</p> <pre><code>mychart/\n  Chart.yaml\n  values.yaml\n  charts/\n  templates/\n  ...\n</code></pre> <p>The <code>templates/</code> directory is for template files. When Helm evaluates a chart, it will send all of the files in the <code>templates/</code> directory through the template rendering engine. It then collects the results of those templates and sends them on to Kubernetes.</p> <p>The <code>values.yaml</code> file is also important to templates. This file contains the default values for a chart. These values may be overridden by users during <code>helm install</code> or <code>helm upgrade</code>.</p> <p>The <code>Chart.yaml</code> file contains a description of the chart. You can access it from within a template.</p> <p>The <code>charts/</code> directory may contain other charts (which we call subcharts). Later in this guide we will see how those work when it comes to template rendering.</p>"},{"location":"chart_template_guide/getting_started/#a-starter-chart","title":"A Starter Chart","text":"<p>For this guide, we'll create a simple chart called <code>mychart</code>, and then we'll create some templates inside of the chart.</p> <pre><code>$ helm create mychart\nCreating mychart\n</code></pre>"},{"location":"chart_template_guide/getting_started/#a-quick-glimpse-of-mycharttemplates","title":"A Quick Glimpse of <code>mychart/templates/</code>","text":"<p>If you take a look at the <code>mychart/templates/</code> directory, you'll notice a few files already there.</p> <ul> <li><code>NOTES.txt</code>: The \"help text\" for your chart. This will be displayed to your   users when they run <code>helm install</code>.</li> <li><code>deployment.yaml</code>: A basic manifest for creating a Kubernetes   deployment</li> <li><code>service.yaml</code>: A basic manifest for creating a service   endpoint for your deployment</li> <li><code>_helpers.tpl</code>: A place to put template helpers that you can re-use throughout   the chart</li> </ul> <p>And what we're going to do is... remove them all! That way we can work through our tutorial from scratch. We'll actually create our own <code>NOTES.txt</code> and <code>_helpers.tpl</code> as we go.</p> <pre><code>$ rm -rf mychart/templates/*\n</code></pre> <p>When you're writing production grade charts, having basic versions of these charts can be really useful. So in your day-to-day chart authoring, you probably won't want to remove them.</p>"},{"location":"chart_template_guide/getting_started/#a-first-template","title":"A First Template","text":"<p>The first template we are going to create will be a <code>ConfigMap</code>. In Kubernetes, a ConfigMap is simply an object for storing configuration data. Other things, like pods, can access the data in a ConfigMap.</p> <p>Because ConfigMaps are basic resources, they make a great starting point for us.</p> <p>Let's begin by creating a file called <code>mychart/templates/configmap.yaml</code>:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: mychart-configmap\ndata:\n  myvalue: \"Hello World\"\n</code></pre> <p>TIP: Template names do not follow a rigid naming pattern. However, we recommend using the extension <code>.yaml</code> for YAML files and <code>.tpl</code> for helpers.</p> <p>The YAML file above is a bare-bones ConfigMap, having the minimal necessary fields. By virtue of the fact that this file is in the <code>mychart/templates/</code> directory, it will be sent through the template engine.</p> <p>It is just fine to put a plain YAML file like this in the <code>mychart/templates/</code> directory. When Helm reads this template, it will simply send it to Kubernetes as-is.</p> <p>With this simple template, we now have an installable chart. And we can install it like this:</p> <pre><code>$ helm install full-coral ./mychart\nNAME: full-coral\nLAST DEPLOYED: Tue Nov  1 17:36:01 2016\nNAMESPACE: default\nSTATUS: DEPLOYED\nREVISION: 1\nTEST SUITE: None\n</code></pre> <p>Using Helm, we can retrieve the release and see the actual template that was loaded.</p> <pre><code>$ helm get manifest full-coral\n\n---\n# Source: mychart/templates/configmap.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: mychart-configmap\ndata:\n  myvalue: \"Hello World\"\n</code></pre> <p>The <code>helm get manifest</code> command takes a release name (<code>full-coral</code>) and prints out all of the Kubernetes resources that were uploaded to the server. Each file begins with <code>---</code> to indicate the start of a YAML document, and then is followed by an automatically generated comment line that tells us what template file generated this YAML document.</p> <p>From there on, we can see that the YAML data is exactly what we put in our <code>configmap.yaml</code> file.</p> <p>Now we can uninstall our release: <code>helm uninstall full-coral</code>.</p>"},{"location":"chart_template_guide/getting_started/#adding-a-simple-template-call","title":"Adding a Simple Template Call","text":"<p>Hard-coding the <code>name:</code> into a resource is usually considered to be bad practice. Names should be unique to a release. So we might want to generate a name field by inserting the release name.</p> <p>TIP: The <code>name:</code> field is limited to 63 characters because of limitations to the DNS system. For that reason, release names are limited to 53 characters. Kubernetes 1.3 and earlier limited to only 24 characters (thus 14 character names).</p> <p>Let's alter <code>configmap.yaml</code> accordingly.</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: {{ .Release.Name }}-configmap\ndata:\n  myvalue: \"Hello World\"\n</code></pre> <p>The big change comes in the value of the <code>name:</code> field, which is now <code>{{ .Release.Name }}-configmap</code>.</p> <p>A template directive is enclosed in <code>{{</code> and <code>}}</code> blocks.</p> <p>The template directive <code>{{ .Release.Name }}</code> injects the release name into the template. The values that are passed into a template can be thought of as namespaced objects, where a dot (<code>.</code>) separates each namespaced element.</p> <p>The leading dot before <code>Release</code> indicates that we start with the top-most namespace for this scope (we'll talk about scope in a bit). So we could read <code>.Release.Name</code> as \"start at the top namespace, find the <code>Release</code> object, then look inside of it for an object called <code>Name</code>\".</p> <p>The <code>Release</code> object is one of the built-in objects for Helm, and we'll cover it in more depth later. But for now, it is sufficient to say that this will display the release name that the library assigns to our release.</p> <p>Now when we install our resource, we'll immediately see the result of using this template directive:</p> <pre><code>$ helm install clunky-serval ./mychart\nNAME: clunky-serval\nLAST DEPLOYED: Tue Nov  1 17:45:37 2016\nNAMESPACE: default\nSTATUS: DEPLOYED\nREVISION: 1\nTEST SUITE: None\n</code></pre> <p>You can run <code>helm get manifest clunky-serval</code> to see the entire generated YAML.</p> <p>Note that the ConfigMap inside Kubernetes name is <code>clunky-serval-configmap</code> instead of <code>mychart-configmap</code> previously.</p> <p>At this point, we've seen templates at their most basic: YAML files that have template directives embedded in <code>{{</code> and <code>}}</code>. In the next part, we'll take a deeper look into templates. But before moving on, there's one quick trick that can make building templates faster: When you want to test the template rendering, but not actually install anything, you can use <code>helm install --debug --dry-run goodly-guppy ./mychart</code>. This will render the templates. But instead of installing the chart, it will return the rendered template to you so you can see the output:</p> <pre><code>$ helm install --debug --dry-run goodly-guppy ./mychart\ninstall.go:149: [debug] Original chart version: \"\"\ninstall.go:166: [debug] CHART PATH: /Users/ninja/mychart\n\nNAME: goodly-guppy\nLAST DEPLOYED: Thu Dec 26 17:24:13 2019\nNAMESPACE: default\nSTATUS: pending-install\nREVISION: 1\nTEST SUITE: None\nUSER-SUPPLIED VALUES:\n{}\n\nCOMPUTED VALUES:\naffinity: {}\nfullnameOverride: \"\"\nimage:\n  pullPolicy: IfNotPresent\n  repository: nginx\nimagePullSecrets: []\ningress:\n  annotations: {}\n  enabled: false\n  hosts:\n  - host: chart-example.local\n    paths: []\n  tls: []\nnameOverride: \"\"\nnodeSelector: {}\npodSecurityContext: {}\nreplicaCount: 1\nresources: {}\nsecurityContext: {}\nservice:\n  port: 80\n  type: ClusterIP\nserviceAccount:\n  create: true\n  name: null\ntolerations: []\n\nHOOKS:\nMANIFEST:\n---\n# Source: mychart/templates/configmap.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: goodly-guppy-configmap\ndata:\n  myvalue: \"Hello World\"\n\n</code></pre> <p>Using <code>--dry-run</code> will make it easier to test your code, but it won't ensure that Kubernetes itself will accept the templates you generate. It's best not to assume that your chart will install just because <code>--dry-run</code> works.</p> <p>In the Chart Template Guide, we take the basic chart we defined here and explore the Helm template language in detail. And we'll get started with built-in objects.</p>"},{"location":"chart_template_guide/helm_ignore_file/","title":"The .helmignore file","text":"<p>The <code>.helmignore</code> file is used to specify files you don't want to include in your helm chart.</p> <p>If this file exists, the <code>helm package</code> command will ignore all the files that match the pattern specified in the <code>.helmignore</code> file while packaging your application.</p> <p>This can help in avoiding unnecessary or sensitive files or directories from being added in your helm chart.</p> <p>The <code>.helmignore</code> file supports Unix shell glob matching, relative path matching, and negation (prefixed with !). Only one pattern per line is considered.</p> <p>Here is an example <code>.helmignore</code> file:</p> <pre><code># comment\n\n# Match any file or path named .helmignore\n.helmignore\n\n# Match any file or path named .git\n.git\n\n# Match any text file\n*.txt\n\n# Match only directories named mydir\nmydir/\n\n# Match only text files in the top-level directory\n/*.txt\n\n# Match only the file foo.txt in the top-level directory\n/foo.txt\n\n# Match any file named ab.txt, ac.txt, or ad.txt\na[b-d].txt\n\n# Match any file under subdir matching temp*\n*/temp*\n\n*/*/temp*\ntemp?\n</code></pre> <p>Some notable differences from .gitignore: - The '**' syntax is not supported. - The globbing library is Go's 'filepath.Match', not fnmatch(3) - Trailing spaces are always ignored (there is no supported escape sequence) - There is no support for '!' as a special leading sequence. - It does not exclude itself by default, you have to add an explicit entry for <code>.helmignore</code></p> <p>We'd love your help making this document better. To add, correct, or remove information, file an issue or send us a pull request.</p>"},{"location":"chart_template_guide/named_templates/","title":"Named Templates","text":"<p>It is time to move beyond one template, and begin to create others. In this section, we will see how to define named templates in one file, and then use them elsewhere. A named template (sometimes called a partial or a subtemplate) is simply a template defined inside of a file, and given a name. We'll see two ways to create them, and a few different ways to use them.</p> <p>In the Flow Control section we introduced three actions for declaring and managing templates: <code>define</code>, <code>template</code>, and <code>block</code>. In this section, we'll cover those three actions, and also introduce a special-purpose <code>include</code> function that works similarly to the <code>template</code> action.</p> <p>An important detail to keep in mind when naming templates: template names are global. If you declare two templates with the same name, whichever one is loaded last will be the one used. Because templates in subcharts are compiled together with top-level templates, you should be careful to name your templates with chart-specific names.</p> <p>One popular naming convention is to prefix each defined template with the name of the chart: <code>{{ define \"mychart.labels\" }}</code>. By using the specific chart name as a prefix we can avoid any conflicts that may arise due to two different charts that implement templates of the same name.</p> <p>This behavior also applies to different versions of a chart. If you have <code>mychart</code> version <code>1.0.0</code> that defines a template one way, and a <code>mychart</code> version <code>2.0.0</code> that modifies the existing named template, it will use the one that was loaded last. You can work around this issue by also adding a version in the name of the chart: <code>{{ define \"mychart.v1.labels\" }}</code> and <code>{{ define \"mychart.v2.labels\" }}</code>.</p>"},{"location":"chart_template_guide/named_templates/#partials-and-_-files","title":"Partials and <code>_</code> files","text":"<p>So far, we've used one file, and that one file has contained a single template. But Helm's template language allows you to create named embedded templates, that can be accessed by name elsewhere.</p> <p>Before we get to the nuts-and-bolts of writing those templates, there is file naming convention that deserves mention:</p> <ul> <li>Most files in <code>templates/</code> are treated as if they contain Kubernetes manifests</li> <li>The <code>NOTES.txt</code> is one exception</li> <li>But files whose name begins with an underscore (<code>_</code>) are assumed to not have   a manifest inside. These files are not rendered to Kubernetes object   definitions, but are available everywhere within other chart templates for   use.</li> </ul> <p>These files are used to store partials and helpers. In fact, when we first created <code>mychart</code>, we saw a file called <code>_helpers.tpl</code>. That file is the default location for template partials.</p>"},{"location":"chart_template_guide/named_templates/#declaring-and-using-templates-with-define-and-template","title":"Declaring and using templates with <code>define</code> and <code>template</code>","text":"<p>The <code>define</code> action allows us to create a named template inside of a template file. Its syntax goes like this:</p> <pre><code>{{- define \"MY.NAME\" }}\n  # body of template here\n{{- end }}\n</code></pre> <p>For example, we can define a template to encapsulate a Kubernetes block of labels:</p> <pre><code>{{- define \"mychart.labels\" }}\n  labels:\n    generator: helm\n    date: {{ now | htmlDate }}\n{{- end }}\n</code></pre> <p>Now we can embed this template inside of our existing ConfigMap, and then include it with the <code>template</code> action:</p> <pre><code>{{- define \"mychart.labels\" }}\n  labels:\n    generator: helm\n    date: {{ now | htmlDate }}\n{{- end }}\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: {{ .Release.Name }}-configmap\n  {{- template \"mychart.labels\" }}\ndata:\n  myvalue: \"Hello World\"\n  {{- range $key, $val := .Values.favorite }}\n  {{ $key }}: {{ $val | quote }}\n  {{- end }}\n</code></pre> <p>When the template engine reads this file, it will store away the reference to <code>mychart.labels</code> until <code>template \"mychart.labels\"</code> is called. Then it will render that template inline. So the result will look like this:</p> <pre><code># Source: mychart/templates/configmap.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: running-panda-configmap\n  labels:\n    generator: helm\n    date: 2016-11-02\ndata:\n  myvalue: \"Hello World\"\n  drink: \"coffee\"\n  food: \"pizza\"\n</code></pre> <p>Note: a <code>define</code> does not produce output unless it is called with a template, as in this example.</p> <p>Conventionally, Helm charts put these templates inside of a partials file, usually <code>_helpers.tpl</code>. Let's move this function there:</p> <pre><code>{{/* Generate basic labels */}}\n{{- define \"mychart.labels\" }}\n  labels:\n    generator: helm\n    date: {{ now | htmlDate }}\n{{- end }}\n</code></pre> <p>By convention, <code>define</code> functions should have a simple documentation block (<code>{{/* ... */}}</code>) describing what they do.</p> <p>Even though this definition is in <code>_helpers.tpl</code>, it can still be accessed in <code>configmap.yaml</code>:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: {{ .Release.Name }}-configmap\n  {{- template \"mychart.labels\" }}\ndata:\n  myvalue: \"Hello World\"\n  {{- range $key, $val := .Values.favorite }}\n  {{ $key }}: {{ $val | quote }}\n  {{- end }}\n</code></pre> <p>As mentioned above, template names are global. As a result of this, if two templates are declared with the same name the last occurrence will be the one that is used. Since templates in subcharts are compiled together with top-level templates, it is best to name your templates with chart specific names. A popular naming convention is to prefix each defined template with the name of the chart: <code>{{ define \"mychart.labels\" }}</code>.</p>"},{"location":"chart_template_guide/named_templates/#setting-the-scope-of-a-template","title":"Setting the scope of a template","text":"<p>In the template we defined above, we did not use any objects. We just used functions. Let's modify our defined template to include the chart name and chart version:</p> <pre><code>{{/* Generate basic labels */}}\n{{- define \"mychart.labels\" }}\n  labels:\n    generator: helm\n    date: {{ now | htmlDate }}\n    chart: {{ .Chart.Name }}\n    version: {{ .Chart.Version }}\n{{- end }}\n</code></pre> <p>If we render this, we will get an error like this:</p> <pre><code>$ helm install --dry-run moldy-jaguar ./mychart\nError: unable to build kubernetes objects from release manifest: error validating \"\": error validating data: [unknown object type \"nil\" in ConfigMap.metadata.labels.chart, unknown object type \"nil\" in ConfigMap.metadata.labels.version]\n</code></pre> <p>To see what rendered, re-run with <code>--disable-openapi-validation</code>: <code>helm install --dry-run --disable-openapi-validation moldy-jaguar ./mychart</code>. The result will not be what we expect:</p> <pre><code># Source: mychart/templates/configmap.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: moldy-jaguar-configmap\n  labels:\n    generator: helm\n    date: 2021-03-06\n    chart:\n    version:\n</code></pre> <p>What happened to the name and version? They weren't in the scope for our defined template. When a named template (created with <code>define</code>) is rendered, it will receive the scope passed in by the <code>template</code> call. In our example, we included the template like this:</p> <pre><code>{{- template \"mychart.labels\" }}\n</code></pre> <p>No scope was passed in, so within the template we cannot access anything in <code>.</code>. This is easy enough to fix, though. We simply pass a scope to the template:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: {{ .Release.Name }}-configmap\n  {{- template \"mychart.labels\" . }}\n</code></pre> <p>Note that we pass <code>.</code> at the end of the <code>template</code> call. We could just as easily pass <code>.Values</code> or <code>.Values.favorite</code> or whatever scope we want. But what we want is the top-level scope. In the context of the named template, <code>$</code> will refer to the scope you passed in and not some global scope.</p> <p>Now when we execute this template with <code>helm install --dry-run --debug plinking-anaco ./mychart</code>, we get this:</p> <pre><code># Source: mychart/templates/configmap.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: plinking-anaco-configmap\n  labels:\n    generator: helm\n    date: 2021-03-06\n    chart: mychart\n    version: 0.1.0\n</code></pre> <p>Now <code>{{ .Chart.Name }}</code> resolves to <code>mychart</code>, and <code>{{ .Chart.Version }}</code> resolves to <code>0.1.0</code>.</p>"},{"location":"chart_template_guide/named_templates/#the-include-function","title":"The <code>include</code> function","text":"<p>Say we've defined a simple template that looks like this:</p> <pre><code>{{- define \"mychart.app\" -}}\napp_name: {{ .Chart.Name }}\napp_version: \"{{ .Chart.Version }}\"\n{{- end -}}\n</code></pre> <p>Now say I want to insert this both into the <code>labels:</code> section of my template, and also the <code>data:</code> section:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: {{ .Release.Name }}-configmap\n  labels:\n    {{ template \"mychart.app\" . }}\ndata:\n  myvalue: \"Hello World\"\n  {{- range $key, $val := .Values.favorite }}\n  {{ $key }}: {{ $val | quote }}\n  {{- end }}\n{{ template \"mychart.app\" . }}\n</code></pre> <p>If we render this, we will get an error like this:</p> <pre><code>$ helm install --dry-run measly-whippet ./mychart\nError: unable to build kubernetes objects from release manifest: error validating \"\": error validating data: [ValidationError(ConfigMap): unknown field \"app_name\" in io.k8s.api.core.v1.ConfigMap, ValidationError(ConfigMap): unknown field \"app_version\" in io.k8s.api.core.v1.ConfigMap]\n</code></pre> <p>To see what rendered, re-run with <code>--disable-openapi-validation</code>: <code>helm install --dry-run --disable-openapi-validation measly-whippet ./mychart</code>. The output will not be what we expect:</p> <pre><code># Source: mychart/templates/configmap.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: measly-whippet-configmap\n  labels:\n    app_name: mychart\napp_version: \"0.1.0\"\ndata:\n  myvalue: \"Hello World\"\n  drink: \"coffee\"\n  food: \"pizza\"\napp_name: mychart\napp_version: \"0.1.0\"\n</code></pre> <p>Note that the indentation on <code>app_version</code> is wrong in both places. Why? Because the template that is substituted in has the text aligned to the left. Because <code>template</code> is an action, and not a function, there is no way to pass the output of a <code>template</code> call to other functions; the data is simply inserted inline.</p> <p>To work around this case, Helm provides an alternative to <code>template</code> that will import the contents of a template into the present pipeline where it can be passed along to other functions in the pipeline.</p> <p>Here's the example above, corrected to use <code>indent</code> to indent the <code>mychart.app</code> template correctly:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: {{ .Release.Name }}-configmap\n  labels:\n{{ include \"mychart.app\" . | indent 4 }}\ndata:\n  myvalue: \"Hello World\"\n  {{- range $key, $val := .Values.favorite }}\n  {{ $key }}: {{ $val | quote }}\n  {{- end }}\n{{ include \"mychart.app\" . | indent 2 }}\n</code></pre> <p>Now the produced YAML is correctly indented for each section:</p> <pre><code># Source: mychart/templates/configmap.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: edgy-mole-configmap\n  labels:\n    app_name: mychart\n    app_version: \"0.1.0\"\ndata:\n  myvalue: \"Hello World\"\n  drink: \"coffee\"\n  food: \"pizza\"\n  app_name: mychart\n  app_version: \"0.1.0\"\n</code></pre> <p>It is considered preferable to use <code>include</code> over <code>template</code> in Helm templates simply so that the output formatting can be handled better for YAML documents.</p> <p>Sometimes we want to import content, but not as templates. That is, we want to import files verbatim. We can achieve this by accessing files through the <code>.Files</code> object described in the next section.</p>"},{"location":"chart_template_guide/notes_files/","title":"Creating a NOTES.txt File","text":"<p>In this section we are going to look at Helm's tool for providing instructions to your chart users. At the end of a <code>helm install</code> or <code>helm upgrade</code>, Helm can print out a block of helpful information for users. This information is highly customizable using templates.</p> <p>To add installation notes to your chart, simply create a <code>templates/NOTES.txt</code> file. This file is plain text, but it is processed like a template, and has all the normal template functions and objects available.</p> <p>Let's create a simple <code>NOTES.txt</code> file:</p> <pre><code>Thank you for installing {{ .Chart.Name }}.\n\nYour release is named {{ .Release.Name }}.\n\nTo learn more about the release, try:\n\n  $ helm status {{ .Release.Name }}\n  $ helm get all {{ .Release.Name }}\n\n</code></pre> <p>Now if we run <code>helm install rude-cardinal ./mychart</code> we will see this message at the bottom:</p> <pre><code>RESOURCES:\n==&gt; v1/Secret\nNAME                   TYPE      DATA      AGE\nrude-cardinal-secret   Opaque    1         0s\n\n==&gt; v1/ConfigMap\nNAME                      DATA      AGE\nrude-cardinal-configmap   3         0s\n\n\nNOTES:\nThank you for installing mychart.\n\nYour release is named rude-cardinal.\n\nTo learn more about the release, try:\n\n  $ helm status rude-cardinal\n  $ helm get all rude-cardinal\n</code></pre> <p>Using <code>NOTES.txt</code> this way is a great way to give your users detailed information about how to use their newly installed chart. Creating a <code>NOTES.txt</code> file is strongly recommended, though it is not required.</p>"},{"location":"chart_template_guide/subcharts_and_globals/","title":"Subcharts and Global Values","text":"<p>To this point we have been working only with one chart. But charts can have dependencies, called subcharts, that also have their own values and templates. In this section we will create a subchart and see the different ways we can access values from within templates.</p> <p>Before we dive into the code, there are a few important details to learn about application subcharts.</p> <ol> <li>A subchart is considered \"stand-alone\", which means a subchart can never    explicitly depend on its parent chart.</li> <li>For that reason, a subchart cannot access the values of its parent.</li> <li>A parent chart can override values for subcharts.</li> <li>Helm has a concept of global values that can be accessed by all charts.</li> </ol> <p>These limitations do not all necessarily apply to library charts, which are designed to provide standardized helper functionality.</p> <p>As we walk through the examples in this section, many of these concepts will become clearer.</p>"},{"location":"chart_template_guide/subcharts_and_globals/#creating-a-subchart","title":"Creating a Subchart","text":"<p>For these exercises, we'll start with the <code>mychart/</code> chart we created at the beginning of this guide, and we'll add a new chart inside of it.</p> <pre><code>$ cd mychart/charts\n$ helm create mysubchart\nCreating mysubchart\n$ rm -rf mysubchart/templates/*\n</code></pre> <p>Notice that just as before, we deleted all of the base templates so that we can start from scratch. In this guide, we are focused on how templates work, not on managing dependencies. But the Charts Guide has more information on how subcharts work.</p>"},{"location":"chart_template_guide/subcharts_and_globals/#adding-values-and-a-template-to-the-subchart","title":"Adding Values and a Template to the Subchart","text":"<p>Next, let's create a simple template and values file for our <code>mysubchart</code> chart. There should already be a <code>values.yaml</code> in <code>mychart/charts/mysubchart</code>. We'll set it up like this:</p> <pre><code>dessert: cake\n</code></pre> <p>Next, we'll create a new ConfigMap template in <code>mychart/charts/mysubchart/templates/configmap.yaml</code>:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: {{ .Release.Name }}-cfgmap2\ndata:\n  dessert: {{ .Values.dessert }}\n</code></pre> <p>Because every subchart is a stand-alone chart, we can test <code>mysubchart</code> on its own:</p> <pre><code>$ helm install --generate-name --dry-run --debug mychart/charts/mysubchart\nSERVER: \"localhost:44134\"\nCHART PATH: /Users/mattbutcher/Code/Go/src/helm.sh/helm/_scratch/mychart/charts/mysubchart\nNAME:   newbie-elk\nTARGET NAMESPACE:   default\nCHART:  mysubchart 0.1.0\nMANIFEST:\n---\n# Source: mysubchart/templates/configmap.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: newbie-elk-cfgmap2\ndata:\n  dessert: cake\n</code></pre>"},{"location":"chart_template_guide/subcharts_and_globals/#overriding-values-from-a-parent-chart","title":"Overriding Values from a Parent Chart","text":"<p>Our original chart, <code>mychart</code> is now the parent chart of <code>mysubchart</code>. This relationship is based entirely on the fact that <code>mysubchart</code> is within <code>mychart/charts</code>.</p> <p>Because <code>mychart</code> is a parent, we can specify configuration in <code>mychart</code> and have that configuration pushed into <code>mysubchart</code>. For example, we can modify <code>mychart/values.yaml</code> like this:</p> <pre><code>favorite:\n  drink: coffee\n  food: pizza\npizzaToppings:\n  - mushrooms\n  - cheese\n  - peppers\n  - onions\n\nmysubchart:\n  dessert: ice cream\n</code></pre> <p>Note the last two lines. Any directives inside of the <code>mysubchart</code> section will be sent to the <code>mysubchart</code> chart. So if we run <code>helm install --generate-name --dry-run --debug mychart</code>, one of the things we will see is the <code>mysubchart</code> ConfigMap:</p> <pre><code># Source: mychart/charts/mysubchart/templates/configmap.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: unhinged-bee-cfgmap2\ndata:\n  dessert: ice cream\n</code></pre> <p>The value at the top level has now overridden the value of the subchart.</p> <p>There's an important detail to notice here. We didn't change the template of <code>mychart/charts/mysubchart/templates/configmap.yaml</code> to point to <code>.Values.mysubchart.dessert</code>. From that template's perspective, the value is still located at <code>.Values.dessert</code>. As the template engine passes values along, it sets the scope. So for the <code>mysubchart</code> templates, only values specifically for <code>mysubchart</code> will be available in <code>.Values</code>.</p> <p>Sometimes, though, you do want certain values to be available to all of the templates. This is accomplished using global chart values.</p>"},{"location":"chart_template_guide/subcharts_and_globals/#global-chart-values","title":"Global Chart Values","text":"<p>Global values are values that can be accessed from any chart or subchart by exactly the same name. Globals require explicit declaration. You can't use an existing non-global as if it were a global.</p> <p>The Values data type has a reserved section called <code>Values.global</code> where global values can be set. Let's set one in our <code>mychart/values.yaml</code> file.</p> <pre><code>favorite:\n  drink: coffee\n  food: pizza\npizzaToppings:\n  - mushrooms\n  - cheese\n  - peppers\n  - onions\n\nmysubchart:\n  dessert: ice cream\n\nglobal:\n  salad: caesar\n</code></pre> <p>Because of the way globals work, both <code>mychart/templates/configmap.yaml</code> and <code>mysubchart/templates/configmap.yaml</code> should be able to access that value as <code>{{ .Values.global.salad }}</code>.</p> <p><code>mychart/templates/configmap.yaml</code>:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: {{ .Release.Name }}-configmap\ndata:\n  salad: {{ .Values.global.salad }}\n</code></pre> <p><code>mysubchart/templates/configmap.yaml</code>:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: {{ .Release.Name }}-cfgmap2\ndata:\n  dessert: {{ .Values.dessert }}\n  salad: {{ .Values.global.salad }}\n</code></pre> <p>Now if we run a dry run install, we'll see the same value in both outputs:</p> <pre><code># Source: mychart/templates/configmap.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: silly-snake-configmap\ndata:\n  salad: caesar\n\n---\n# Source: mychart/charts/mysubchart/templates/configmap.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: silly-snake-cfgmap2\ndata:\n  dessert: ice cream\n  salad: caesar\n</code></pre> <p>Globals are useful for passing information like this, though it does take some planning to make sure the right templates are configured to use globals.</p>"},{"location":"chart_template_guide/subcharts_and_globals/#sharing-templates-with-subcharts","title":"Sharing Templates with Subcharts","text":"<p>Parent charts and subcharts can share templates. Any defined block in any chart is available to other charts.</p> <p>For example, we can define a simple template like this:</p> <pre><code>{{- define \"labels\" }}from: mychart{{ end }}\n</code></pre> <p>Recall how the labels on templates are globally shared. Thus, the <code>labels</code> chart can be included from any other chart.</p> <p>While chart developers have a choice between <code>include</code> and <code>template</code>, one advantage of using <code>include</code> is that <code>include</code> can dynamically reference templates:</p> <pre><code>{{ include $mytemplate }}\n</code></pre> <p>The above will dereference <code>$mytemplate</code>. The <code>template</code> function, in contrast, will only accept a string literal.</p>"},{"location":"chart_template_guide/subcharts_and_globals/#avoid-using-blocks","title":"Avoid Using Blocks","text":"<p>The Go template language provides a <code>block</code> keyword that allows developers to provide a default implementation which is overridden later. In Helm charts, blocks are not the best tool for overriding because if multiple implementations of the same block are provided, the one selected is unpredictable.</p> <p>The suggestion is to instead use <code>include</code>.</p>"},{"location":"chart_template_guide/values_files/","title":"Values Files","text":"<p>In the previous section we looked at the built-in objects that Helm templates offer. One of the built-in objects is <code>Values</code>. This object provides access to values passed into the chart. Its contents come from multiple sources:</p> <ul> <li>The <code>values.yaml</code> file in the chart</li> <li>If this is a subchart, the <code>values.yaml</code> file of a parent chart</li> <li>A values file is passed into <code>helm install</code> or <code>helm upgrade</code> with the <code>-f</code>   flag (<code>helm install -f myvals.yaml ./mychart</code>)</li> <li>Individual parameters are passed with <code>--set</code> (such as <code>helm install --set foo=bar   ./mychart</code>)</li> </ul> <p>The list above is in order of specificity: <code>values.yaml</code> is the default, which can be overridden by a parent chart's <code>values.yaml</code>, which can in turn be overridden by a user-supplied values file, which can in turn be overridden by <code>--set</code> parameters.</p> <p>Values files are plain YAML files. Let's edit <code>mychart/values.yaml</code> and then edit our ConfigMap template.</p> <p>Removing the defaults in <code>values.yaml</code>, we'll set just one parameter:</p> <pre><code>favoriteDrink: coffee\n</code></pre> <p>Now we can use this inside of a template:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: {{ .Release.Name }}-configmap\ndata:\n  myvalue: \"Hello World\"\n  drink: {{ .Values.favoriteDrink }}\n</code></pre> <p>Notice on the last line we access <code>favoriteDrink</code> as an attribute of <code>Values</code>: <code>{{ .Values.favoriteDrink }}</code>.</p> <p>Let's see how this renders.</p> <pre><code>$ helm install geared-marsupi ./mychart --dry-run --debug\ninstall.go:158: [debug] Original chart version: \"\"\ninstall.go:175: [debug] CHART PATH: /home/bagratte/src/playground/mychart\n\nNAME: geared-marsupi\nLAST DEPLOYED: Wed Feb 19 23:21:13 2020\nNAMESPACE: default\nSTATUS: pending-install\nREVISION: 1\nTEST SUITE: None\nUSER-SUPPLIED VALUES:\n{}\n\nCOMPUTED VALUES:\nfavoriteDrink: coffee\n\nHOOKS:\nMANIFEST:\n---\n# Source: mychart/templates/configmap.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: geared-marsupi-configmap\ndata:\n  myvalue: \"Hello World\"\n  drink: coffee\n</code></pre> <p>Because <code>favoriteDrink</code> is set in the default <code>values.yaml</code> file to <code>coffee</code>, that's the value displayed in the template. We can easily override that by adding a <code>--set</code> flag in our call to <code>helm install</code>:</p> <pre><code>$ helm install solid-vulture ./mychart --dry-run --debug --set favoriteDrink=slurm\ninstall.go:158: [debug] Original chart version: \"\"\ninstall.go:175: [debug] CHART PATH: /home/bagratte/src/playground/mychart\n\nNAME: solid-vulture\nLAST DEPLOYED: Wed Feb 19 23:25:54 2020\nNAMESPACE: default\nSTATUS: pending-install\nREVISION: 1\nTEST SUITE: None\nUSER-SUPPLIED VALUES:\nfavoriteDrink: slurm\n\nCOMPUTED VALUES:\nfavoriteDrink: slurm\n\nHOOKS:\nMANIFEST:\n---\n# Source: mychart/templates/configmap.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: solid-vulture-configmap\ndata:\n  myvalue: \"Hello World\"\n  drink: slurm\n</code></pre> <p>Since <code>--set</code> has a higher precedence than the default <code>values.yaml</code> file, our template generates <code>drink: slurm</code>.</p> <p>Values files can contain more structured content, too. For example, we could create a <code>favorite</code> section in our <code>values.yaml</code> file, and then add several keys there:</p> <pre><code>favorite:\n  drink: coffee\n  food: pizza\n</code></pre> <p>Now we would have to modify the template slightly:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: {{ .Release.Name }}-configmap\ndata:\n  myvalue: \"Hello World\"\n  drink: {{ .Values.favorite.drink }}\n  food: {{ .Values.favorite.food }}\n</code></pre> <p>While structuring data this way is possible, the recommendation is that you keep your values trees shallow, favoring flatness. When we look at assigning values to subcharts, we'll see how values are named using a tree structure.</p>"},{"location":"chart_template_guide/values_files/#deleting-a-default-key","title":"Deleting a default key","text":"<p>If you need to delete a key from the default values, you may override the value of the key to be <code>null</code>, in which case Helm will remove the key from the overridden values merge.</p> <p>For example, the stable Drupal chart allows configuring the liveness probe, in case you configure a custom image. Here are the default values:</p> <pre><code>livenessProbe:\n  httpGet:\n    path: /user/login\n    port: http\n  initialDelaySeconds: 120\n</code></pre> <p>If you try to override the livenessProbe handler to <code>exec</code> instead of <code>httpGet</code> using <code>--set livenessProbe.exec.command=[cat,docroot/CHANGELOG.txt]</code>, Helm will coalesce the default and overridden keys together, resulting in the following YAML:</p> <pre><code>livenessProbe:\n  httpGet:\n    path: /user/login\n    port: http\n  exec:\n    command:\n    - cat\n    - docroot/CHANGELOG.txt\n  initialDelaySeconds: 120\n</code></pre> <p>However, Kubernetes would then fail because you can not declare more than one livenessProbe handler. To overcome this, you may instruct Helm to delete the <code>livenessProbe.httpGet</code> by setting it to null:</p> <pre><code>helm install stable/drupal --set image=my-registry/drupal:0.1.0 --set livenessProbe.exec.command=[cat,docroot/CHANGELOG.txt] --set livenessProbe.httpGet=null\n</code></pre> <p>At this point, we've seen several built-in objects, and used them to inject information into a template. Now we will take a look at another aspect of the template engine: functions and pipelines.</p>"},{"location":"chart_template_guide/variables/","title":"Variables","text":"<p>With functions, pipelines, objects, and control structures under our belts, we can turn to one of the more basic ideas in many programming languages: variables. In templates, they are less frequently used. But we will see how to use them to simplify code, and to make better use of <code>with</code> and <code>range</code>.</p> <p>In an earlier example, we saw that this code will fail:</p> <pre><code>  {{- with .Values.favorite }}\n  drink: {{ .drink | default \"tea\" | quote }}\n  food: {{ .food | upper | quote }}\n  release: {{ .Release.Name }}\n  {{- end }}\n</code></pre> <p><code>Release.Name</code> is not inside of the scope that's restricted in the <code>with</code> block. One way to work around scoping issues is to assign objects to variables that can be accessed without respect to the present scope.</p> <p>In Helm templates, a variable is a named reference to another object. It follows the form <code>$name</code>. Variables are assigned with a special assignment operator: <code>:=</code>. We can rewrite the above to use a variable for <code>Release.Name</code>.</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: {{ .Release.Name }}-configmap\ndata:\n  myvalue: \"Hello World\"\n  {{- $relname := .Release.Name -}}\n  {{- with .Values.favorite }}\n  drink: {{ .drink | default \"tea\" | quote }}\n  food: {{ .food | upper | quote }}\n  release: {{ $relname }}\n  {{- end }}\n</code></pre> <p>Notice that before we start the <code>with</code> block, we assign <code>$relname := .Release.Name</code>. Now inside of the <code>with</code> block, the <code>$relname</code> variable still points to the release name.</p> <p>Running that will produce this:</p> <pre><code># Source: mychart/templates/configmap.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: viable-badger-configmap\ndata:\n  myvalue: \"Hello World\"\n  drink: \"coffee\"\n  food: \"PIZZA\"\n  release: viable-badger\n</code></pre> <p>Variables are particularly useful in <code>range</code> loops. They can be used on list-like objects to capture both the index and the value:</p> <pre><code>  toppings: |-\n    {{- range $index, $topping := .Values.pizzaToppings }}\n      {{ $index }}: {{ $topping }}\n    {{- end }}\n\n</code></pre> <p>Note that <code>range</code> comes first, then the variables, then the assignment operator, then the list. This will assign the integer index (starting from zero) to <code>$index</code> and the value to <code>$topping</code>. Running it will produce:</p> <pre><code>  toppings: |-\n      0: mushrooms\n      1: cheese\n      2: peppers\n      3: onions\n</code></pre> <p>For data structures that have both a key and a value, we can use <code>range</code> to get both. For example, we can loop through <code>.Values.favorite</code> like this:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: {{ .Release.Name }}-configmap\ndata:\n  myvalue: \"Hello World\"\n  {{- range $key, $val := .Values.favorite }}\n  {{ $key }}: {{ $val | quote }}\n  {{- end }}\n</code></pre> <p>Now on the first iteration, <code>$key</code> will be <code>drink</code> and <code>$val</code> will be <code>coffee</code>, and on the second, <code>$key</code> will be <code>food</code> and <code>$val</code> will be <code>pizza</code>. Running the above will generate this:</p> <pre><code># Source: mychart/templates/configmap.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: eager-rabbit-configmap\ndata:\n  myvalue: \"Hello World\"\n  drink: \"coffee\"\n  food: \"pizza\"\n</code></pre> <p>Variables are normally not \"global\". They are scoped to the block in which they are declared. Earlier, we assigned <code>$relname</code> in the top level of the template. That variable will be in scope for the entire template. But in our last example, <code>$key</code> and <code>$val</code> will only be in scope inside of the <code>{{ range... }}{{ end }}</code> block.</p> <p>However, there is one variable that will always point to the root context: - <code>$</code> -. This can be very useful when you are looping in a range and you need to know the chart's release name.</p> <p>An example illustrating this:</p> <pre><code>{{- range .Values.tlsSecrets }}\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: {{ .name }}\n  labels:\n    # Many helm templates would use `.` below, but that will not work,\n    # however `$` will work here\n    app.kubernetes.io/name: {{ template \"fullname\" $ }}\n    # I cannot reference .Chart.Name, but I can do $.Chart.Name\n    helm.sh/chart: \"{{ $.Chart.Name }}-{{ $.Chart.Version }}\"\n    app.kubernetes.io/instance: \"{{ $.Release.Name }}\"\n    # Value from appVersion in Chart.yaml\n    app.kubernetes.io/version: \"{{ $.Chart.AppVersion }}\"\n    app.kubernetes.io/managed-by: \"{{ $.Release.Service }}\"\ntype: kubernetes.io/tls\ndata:\n  tls.crt: {{ .certificate }}\n  tls.key: {{ .key }}\n{{- end }}\n</code></pre> <p>So far we have looked at just one template declared in just one file. But one of the powerful features of the Helm template language is its ability to declare multiple templates and use them together. We'll turn to that in the next section.</p>"},{"location":"chart_template_guide/wrapping_up/","title":"Next Steps","text":"<p>This guide is intended to give you, the chart developer, a strong understanding of how to use Helm's template language. The guide focuses on the technical aspects of template development.</p> <p>But there are many things this guide has not covered when it comes to the practical day-to-day development of charts. Here are some useful pointers to other documentation that will help you as you create new charts:</p> <ul> <li>The CNCF Artifact Hub is an   indispensable source of charts.</li> <li>The Kubernetes Documentation provides   detailed examples of the various resource kinds that you can use, from   ConfigMaps and Secrets to DaemonSets and Deployments.</li> <li>The Helm Charts Guide explains the workflow of using   charts.</li> <li>The Helm Chart Hooks Guide explains how to   create lifecycle hooks.</li> <li>The Helm Charts Tips and Tricks article   provides some useful tips for writing charts.</li> <li>The Sprig documentation documents more   than sixty of the template functions.</li> <li>The Go template docs explain the template   syntax in detail.</li> <li>The Schelm tool is a nice helper   utility for debugging charts.</li> </ul> <p>Sometimes it's easier to ask a few questions and get answers from experienced developers. The best place to do this is in the Kubernetes Slack Helm channels:</p> <ul> <li>#helm-users</li> <li>#helm-dev</li> <li>#charts</li> </ul> <p>Finally, if you find errors or omissions in this document, want to suggest some new content, or would like to contribute, visit The Helm Project.</p>"},{"location":"chart_template_guide/yaml_techniques/","title":"Appendix: YAML Techniques","text":"<p>Most of this guide has been focused on writing the template language. Here, we'll look at the YAML format. YAML has some useful features that we, as template authors, can use to make our templates less error prone and easier to read.</p>"},{"location":"chart_template_guide/yaml_techniques/#scalars-and-collections","title":"Scalars and Collections","text":"<p>According to the YAML spec, there are two types of collections, and many scalar types.</p> <p>The two types of collections are maps and sequences:</p> <pre><code>map:\n  one: 1\n  two: 2\n  three: 3\n\nsequence:\n  - one\n  - two\n  - three\n</code></pre> <p>Scalar values are individual values (as opposed to collections)</p>"},{"location":"chart_template_guide/yaml_techniques/#scalar-types-in-yaml","title":"Scalar Types in YAML","text":"<p>In Helm's dialect of YAML, the scalar data type of a value is determined by a complex set of rules, including the Kubernetes schema for resource definitions. But when inferring types, the following rules tend to hold true.</p> <p>If an integer or float is an unquoted bare word, it is typically treated as a numeric type:</p> <pre><code>count: 1\nsize: 2.34\n</code></pre> <p>But if they are quoted, they are treated as strings:</p> <pre><code>count: \"1\" # &lt;-- string, not int\nsize: '2.34' # &lt;-- string, not float\n</code></pre> <p>The same is true of booleans:</p> <pre><code>isGood: true   # bool\nanswer: \"true\" # string\n</code></pre> <p>The word for an empty value is <code>null</code> (not <code>nil</code>).</p> <p>Note that <code>port: \"80\"</code> is valid YAML, and will pass through both the template engine and the YAML parser, but will fail if Kubernetes expects <code>port</code> to be an integer.</p> <p>In some cases, you can force a particular type inference using YAML node tags:</p> <pre><code>coffee: \"yes, please\"\nage: !!str 21\nport: !!int \"80\"\n</code></pre> <p>In the above, <code>!!str</code> tells the parser that <code>age</code> is a string, even if it looks like an int. And <code>port</code> is treated as an int, even though it is quoted.</p>"},{"location":"chart_template_guide/yaml_techniques/#strings-in-yaml","title":"Strings in YAML","text":"<p>Much of the data that we place in YAML documents are strings. YAML has more than one way to represent a string. This section explains the ways and demonstrates how to use some of them.</p> <p>There are three \"inline\" ways of declaring a string:</p> <pre><code>way1: bare words\nway2: \"double-quoted strings\"\nway3: 'single-quoted strings'\n</code></pre> <p>All inline styles must be on one line.</p> <ul> <li>Bare words are unquoted, and are not escaped. For this reason, you have to be   careful what characters you use.</li> <li>Double-quoted strings can have specific characters escaped with <code>\\</code>. For   example <code>\"\\\"Hello\\\", she said\"</code>. You can escape line breaks with <code>\\n</code>.</li> <li>Single-quoted strings are \"literal\" strings, and do not use the <code>\\</code> to escape   characters. The only escape sequence is <code>''</code>, which is decoded as a single   <code>'</code>.</li> </ul> <p>In addition to the one-line strings, you can declare multi-line strings:</p> <pre><code>coffee: |\n  Latte\n  Cappuccino\n  Espresso\n</code></pre> <p>The above will treat the value of <code>coffee</code> as a single string equivalent to <code>Latte\\nCappuccino\\nEspresso\\n</code>.</p> <p>Note that the first line after the <code>|</code> must be correctly indented. So we could break the example above by doing this:</p> <pre><code>coffee: |\n         Latte\n  Cappuccino\n  Espresso\n\n</code></pre> <p>Because <code>Latte</code> is incorrectly indented, we'd get an error like this:</p> <pre><code>Error parsing file: error converting YAML to JSON: yaml: line 7: did not find expected key\n</code></pre> <p>In templates, it is sometimes safer to put a fake \"first line\" of content in a multi-line document just for protection from the above error:</p> <pre><code>coffee: |\n  # Commented first line\n         Latte\n  Cappuccino\n  Espresso\n\n</code></pre> <p>Note that whatever that first line is, it will be preserved in the output of the string. So if you are, for example, using this technique to inject a file's contents into a ConfigMap, the comment should be of the type expected by whatever is reading that entry.</p>"},{"location":"chart_template_guide/yaml_techniques/#controlling-spaces-in-multi-line-strings","title":"Controlling Spaces in Multi-line Strings","text":"<p>In the example above, we used <code>|</code> to indicate a multi-line string. But notice that the content of our string was followed with a trailing <code>\\n</code>. If we want the YAML processor to strip off the trailing newline, we can add a <code>-</code> after the <code>|</code>:</p> <pre><code>coffee: |-\n  Latte\n  Cappuccino\n  Espresso\n</code></pre> <p>Now the <code>coffee</code> value will be: <code>Latte\\nCappuccino\\nEspresso</code> (with no trailing <code>\\n</code>).</p> <p>Other times, we might want all trailing whitespace to be preserved. We can do this with the <code>|+</code> notation:</p> <pre><code>coffee: |+\n  Latte\n  Cappuccino\n  Espresso\n\n\nanother: value\n</code></pre> <p>Now the value of <code>coffee</code> will be <code>Latte\\nCappuccino\\nEspresso\\n\\n\\n</code>.</p> <p>Indentation inside of a text block is preserved, and results in the preservation of line breaks, too:</p> <pre><code>coffee: |-\n  Latte\n    12 oz\n    16 oz\n  Cappuccino\n  Espresso\n</code></pre> <p>In the above case, <code>coffee</code> will be <code>Latte\\n  12 oz\\n  16 oz\\nCappuccino\\nEspresso</code>.</p>"},{"location":"chart_template_guide/yaml_techniques/#indenting-and-templates","title":"Indenting and Templates","text":"<p>When writing templates, you may find yourself wanting to inject the contents of a file into the template. As we saw in previous chapters, there are two ways of doing this:</p> <ul> <li>Use <code>{{ .Files.Get \"FILENAME\" }}</code> to get the contents of a file in the chart.</li> <li>Use <code>{{ include \"TEMPLATE\" . }}</code> to render a template and then place its   contents into the chart.</li> </ul> <p>When inserting files into YAML, it's good to understand the multi-line rules above. Often times, the easiest way to insert a static file is to do something like this:</p> <pre><code>myfile: |\n{{ .Files.Get \"myfile.txt\" | indent 2 }}\n</code></pre> <p>Note how we do the indentation above: <code>indent 2</code> tells the template engine to indent every line in \"myfile.txt\" with two spaces. Note that we do not indent that template line. That's because if we did, the file content of the first line would be indented twice.</p>"},{"location":"chart_template_guide/yaml_techniques/#folded-multi-line-strings","title":"Folded Multi-line Strings","text":"<p>Sometimes you want to represent a string in your YAML with multiple lines, but want it to be treated as one long line when it is interpreted. This is called \"folding\". To declare a folded block, use <code>&gt;</code> instead of <code>|</code>:</p> <pre><code>coffee: &gt;\n  Latte\n  Cappuccino\n  Espresso\n\n\n</code></pre> <p>The value of <code>coffee</code> above will be <code>Latte Cappuccino Espresso\\n</code>. Note that all but the last line feed will be converted to spaces. You can combine the whitespace controls with the folded text marker, so <code>&gt;-</code> will replace or trim all newlines.</p> <p>Note that in the folded syntax, indenting text will cause lines to be preserved.</p> <pre><code>coffee: &gt;-\n  Latte\n    12 oz\n    16 oz\n  Cappuccino\n  Espresso\n</code></pre> <p>The above will produce <code>Latte\\n  12 oz\\n  16 oz\\nCappuccino Espresso</code>. Note that both the spacing and the newlines are still there.</p>"},{"location":"chart_template_guide/yaml_techniques/#embedding-multiple-documents-in-one-file","title":"Embedding Multiple Documents in One File","text":"<p>It is possible to place more than one YAML document into a single file. This is done by prefixing a new document with <code>---</code> and ending the document with <code>...</code></p> <pre><code>\n---\ndocument: 1\n...\n---\ndocument: 2\n...\n</code></pre> <p>In many cases, either the <code>---</code> or the <code>...</code> may be omitted.</p> <p>Some files in Helm cannot contain more than one doc. If, for example, more than one document is provided inside of a <code>values.yaml</code> file, only the first will be used.</p> <p>Template files, however, may have more than one document. When this happens, the file (and all of its documents) is treated as one object during template rendering. But then the resulting YAML is split into multiple documents before it is fed to Kubernetes.</p> <p>We recommend only using multiple documents per file when it is absolutely necessary. Having multiple documents in a file can be difficult to debug.</p>"},{"location":"chart_template_guide/yaml_techniques/#yaml-is-a-superset-of-json","title":"YAML is a Superset of JSON","text":"<p>Because YAML is a superset of JSON, any valid JSON document should be valid YAML.</p> <pre><code>{\n  \"coffee\": \"yes, please\",\n  \"coffees\": [\n    \"Latte\", \"Cappuccino\", \"Espresso\"\n  ]\n}\n</code></pre> <p>The above is another way of representing this:</p> <pre><code>coffee: yes, please\ncoffees:\n- Latte\n- Cappuccino\n- Espresso\n</code></pre> <p>And the two can be mixed (with care):</p> <pre><code>coffee: \"yes, please\"\ncoffees: [ \"Latte\", \"Cappuccino\", \"Espresso\"]\n</code></pre> <p>All three of these should parse into the same internal representation.</p> <p>While this means that files such as <code>values.yaml</code> may contain JSON data, Helm does not treat the file extension <code>.json</code> as a valid suffix.</p>"},{"location":"chart_template_guide/yaml_techniques/#yaml-anchors","title":"YAML Anchors","text":"<p>The YAML spec provides a way to store a reference to a value, and later refer to that value by reference. YAML refers to this as \"anchoring\":</p> <pre><code>coffee: \"yes, please\"\nfavorite: &amp;favoriteCoffee \"Cappuccino\"\ncoffees:\n  - Latte\n  - *favoriteCoffee\n  - Espresso\n</code></pre> <p>In the above, <code>&amp;favoriteCoffee</code> sets a reference to <code>Cappuccino</code>. Later, that reference is used as <code>*favoriteCoffee</code>. So <code>coffees</code> becomes <code>Latte, Cappuccino, Espresso</code>.</p> <p>While there are a few cases where anchors are useful, there is one aspect of them that can cause subtle bugs: The first time the YAML is consumed, the reference is expanded and then discarded.</p> <p>So if we were to decode and then re-encode the example above, the resulting YAML would be:</p> <pre><code>coffee: yes, please\nfavorite: Cappuccino\ncoffees:\n- Latte\n- Cappuccino\n- Espresso\n</code></pre> <p>Because Helm and Kubernetes often read, modify, and then rewrite YAML files, the anchors will be lost.</p>"},{"location":"community/","title":"Community Guides","text":"<p>Learn here about the development process for the Helm project itself and how you can contribute.</p>"},{"location":"community/developers/","title":"Developer Guide","text":"<p>This guide explains how to set up your environment for developing on Helm.</p>"},{"location":"community/developers/#prerequisites","title":"Prerequisites","text":"<ul> <li>The latest version of Go</li> <li>A Kubernetes cluster w/ kubectl (optional)</li> <li>Git</li> </ul>"},{"location":"community/developers/#building-helm","title":"Building Helm","text":"<p>We use Make to build our programs. The simplest way to get started is:</p> <pre><code>$ make\n</code></pre> <p>If required, this will first install dependencies and validate configuration. It will then compile <code>helm</code> and place it in <code>bin/helm</code>.</p> <p>To run Helm locally, you can run <code>bin/helm</code>.</p> <ul> <li>Helm is known to run on macOS and most Linux distributions, including Alpine.</li> </ul>"},{"location":"community/developers/#running-tests","title":"Running tests","text":"<p>To run all the tests, run <code>make test</code>. As a pre-requisite, you would need to have golangci-lint installed.</p>"},{"location":"community/developers/#running-locally","title":"Running Locally","text":"<p>You can update your path and add the path of your local helm binary. In an editor open your shell config file. Add the following line making sure you replace <code>&lt;path to your binary folder&gt;</code> with your local bin directory.</p> <pre><code>export PATH=\"&lt;path to your binary folder&gt;:$PATH\"\n</code></pre> <p>This will allow you to run the locally built version of helm from your terminal.</p>"},{"location":"community/developers/#contribution-guidelines","title":"Contribution Guidelines","text":"<p>We welcome contributions. This project has set up some guidelines in order to ensure that (a) code quality remains high, (b) the project remains consistent, and (c) contributions follow the open source legal requirements. Our intent is not to burden contributors, but to build elegant and high-quality open source code so that our users will benefit.</p> <p>Make sure you have read and understood the main CONTRIBUTING guide:</p> <p>https://github.com/helm/helm/blob/main/CONTRIBUTING.md</p>"},{"location":"community/developers/#structure-of-the-code","title":"Structure of the Code","text":"<p>The code for the Helm project is organized as follows:</p> <ul> <li>The individual programs are located in <code>cmd/</code>. Code inside of <code>cmd/</code> is not   designed for library re-use.</li> <li>Shared libraries are stored in <code>pkg/</code>.</li> <li>The <code>scripts/</code> directory contains a number of utility scripts. Most of these   are used by the CI/CD pipeline.</li> </ul> <p>Go dependency management is in flux, and it is likely to change during the course of Helm's lifecycle. We encourage developers to not try to manually manage dependencies. Instead, we suggest relying upon the project's <code>Makefile</code> to do that for you. With Helm 3, it is recommended that you are on Go version 1.13 or later.</p>"},{"location":"community/developers/#writing-documentation","title":"Writing Documentation","text":"<p>Since Helm 3, documentation has been moved to its own repository. When writing new features, please write accompanying documentation and submit it to the helm-www repository.</p> <p>One exception: Helm CLI output (in English) is generated from the <code>helm</code> binary itself. See Updating the Helm CLI Reference Docs for instructions on how to generate this output. When translated, the CLI output is not generated and can be found in <code>/content/&lt;lang&gt;/docs/helm</code>.</p>"},{"location":"community/developers/#git-conventions","title":"Git Conventions","text":"<p>We use Git for our version control system. The <code>main</code> branch is the home of the current development candidate. Releases are tagged.</p> <p>We accept changes to the code via GitHub Pull Requests (PRs). One workflow for doing this is as follows:</p> <ol> <li>Fork the <code>github.com/helm/helm</code> repository into your GitHub account</li> <li><code>git clone</code> the forked repository into your desired directory</li> <li>Create a new working branch (<code>git checkout -b feat/my-feature</code>) and do your    work on that branch.</li> <li>When you are ready for us to review, push your branch to GitHub, and then    open a new pull request with us.</li> </ol> <p>For Git commit messages, we follow the Semantic Commit Messages:</p> <pre><code>fix(helm): add --foo flag to 'helm install'\n\nWhen 'helm install --foo bar' is run, this will print \"foo\" in the\noutput regardless of the outcome of the installation.\n\nCloses #1234\n</code></pre> <p>Common commit types:</p> <ul> <li>fix: Fix a bug or error</li> <li>feat: Add a new feature</li> <li>docs: Change documentation</li> <li>test: Improve testing</li> <li>ref: refactor existing code</li> </ul> <p>Common scopes:</p> <ul> <li>helm: The Helm CLI</li> <li>pkg/lint: The lint package. Follow a similar convention for any package</li> <li><code>*</code>: two or more scopes</li> </ul> <p>Read more:</p> <ul> <li>The Deis   Guidelines   were the inspiration for this section.</li> <li>Karma Runner   defines the   semantic commit message idea.</li> </ul>"},{"location":"community/developers/#go-conventions","title":"Go Conventions","text":"<p>We follow the Go coding style standards very closely. Typically, running <code>go fmt</code> will make your code beautiful for you.</p> <p>We also typically follow the conventions recommended by <code>go lint</code> and <code>gometalinter</code>. Run <code>make test-style</code> to test the style conformance.</p> <p>Read more:</p> <ul> <li>Effective Go introduces   formatting.</li> <li>The Go Wiki has a great article on   formatting.</li> </ul> <p>If you run the <code>make test</code> target, not only will unit tests be run, but so will style tests. If the <code>make test</code> target fails, even for stylistic reasons, your PR will not be considered ready for merging.</p>"},{"location":"community/history/","title":"The History of the Project","text":"<p>Helm is a graduated CNCF project.</p> <p>Helm began as what is now known as Helm Classic, a Deis project begun in 2015 and introduced at the inaugural KubeCon.</p> <p>In January of 2016, the project merged with a GCS tool called Kubernetes Deployment Manager, and the project was moved under Kubernetes. As a result of the merging of codebases, Helm 2.0 was released later that year. The key feature of Deployment Manager that survived in Helm 2 was the server-side component, renamed from DM to Tiller for the final Helm 2.0 release.</p> <p>Helm was promoted from a Kubernetes subproject to a full-fledged CNCF project in June, 2018. Helm formed a top-level governing body and several projects were subsumed under the Helm project, including Monocular, the Helm Chart Repo, Chart Museum, and later the Helm Hub.</p> <p>When the Helm 3 development cycle began, Tiller was removed, bringing Helm closer to its original vision of being a client tool. But Helm 3 continues to track releases inside of the Kubernetes cluster, making it possible for teams to work together on a common set of Helm releases. Helm 3 was released in November 2019.</p> <p>Helm graduated as a CNCF project in April 2020.</p> <p>The CNCF Artifact Hub replaced the Helm Hub in October 2020.</p>"},{"location":"community/localization/","title":"Localizing Helm Documentation","text":"<p>This guide explains how to localize the Helm documentation.</p>"},{"location":"community/localization/#getting-started","title":"Getting Started","text":"<p>Contributions for translations use the same process as contributions for documentation. Translations are supplied through pull requests to the helm-www git repository and pull requests are reviewed by the team that manages the website.</p>"},{"location":"community/localization/#two-letter-language-code","title":"Two-letter Language Code","text":"<p>Documentation is organized by the ISO 639-1 standard for the language codes. For example, the two-letter code for Korean is <code>ko</code>.</p> <p>In content and configuration you will find the language code in use. Here are 3 examples:</p> <ul> <li>In the <code>content</code> directory the language codes are the subdirectories and the   localized content for the language is in each directory. Primarily in the   <code>docs</code> subdirectory of each language code directory.</li> <li>The <code>i18n</code> directory contains a configuration file for each language with   phrases used on the website. The files are named with the pattern <code>[LANG].toml</code>   where <code>[LANG]</code> is the two letter language code.</li> <li>In the top level <code>config.toml</code> file there is configuration for navigation and   other details organized by language code.</li> </ul> <p>English, with a language code of <code>en</code>, is the default language and source for translations.</p>"},{"location":"community/localization/#fork-branch-change-pull-request","title":"Fork, Branch, Change, Pull Request","text":"<p>To contribute translations start by creating a fork of the helm-www repository on GitHub. You will start by committing the changes to your fork.</p> <p>By default your fork will be set to work on the default branch known as <code>main</code>. Please use branches to develop your changes and create pull requests. If you are unfamiliar with branches you can read about them in the GitHub documentation.</p> <p>Once you have a branch make changes to add translations and localize the content to a language.</p> <p>Note, Helm uses a Developers Certificate of Origin. All commits need to have signoff. When making a commit you can use the <code>-s</code> or <code>--signoff</code> flag to use your Git configured name and email address to signoff on the commit. More details are available in the CONTRIBUTING.md file.</p> <p>When you are ready, create a pull request with the translation back to the helm-www repository.</p> <p>Once a pull request has been created one of the maintainers will review it. Details on that process are in the CONTRIBUTING.md file.</p>"},{"location":"community/localization/#translating-content","title":"Translating Content","text":"<p>Localizing all of the Helm content is a large task. It is ok to start small. The translations can be expanded over time.</p>"},{"location":"community/localization/#starting-a-new-language","title":"Starting A New Language","text":"<p>When starting a new language there is a minimum needed. This includes:</p> <ul> <li>Adding a <code>content/[LANG]/docs</code> directory containing an <code>_index.md</code> file. This   is the top level documentation landing page.</li> <li>Creating a <code>[LANG].toml</code> file in the <code>i18n</code> directory. Initially you can copy   the <code>en.toml</code> file as a starting point.</li> <li>Adding a section for the language to the <code>config.toml</code> file to expose the new   language. An existing language section can serve as a starting point.</li> </ul>"},{"location":"community/localization/#translating","title":"Translating","text":"<p>Translated content needs to reside in the <code>content/[LANG]/docs</code> directory. It should have the same URL as the English source. For example, to translate the intro into Korean it can be useful to copy the english source like:</p> <pre><code>mkdir -p content/ko/docs/intro\ncp content/en/docs/intro/install.md content/ko/docs/intro/install.md\n</code></pre> <p>The content in the new file can then be translated into the other language.</p> <p>Do not add an untranslated copy of an English file to <code>content/[LANG]/</code>. Once a language exists on the site, any untranslated pages will redirect to English automatically. Translation takes time, and you always want to be translating the most current version of the docs, not an outdated fork.</p> <p>Make sure you remove any <code>aliases</code> lines from the header section. A line like <code>aliases: [\"/docs/using_helm/\"]</code> does not belong in the translations. Those are redirections for old links which don't exist for new pages.</p> <p>Note, translation tools can help with the process. This includes machine generated translations. Machine generated translations should be edited or otherwise reviewing for grammar and meaning by a native language speaker before publishing.</p>"},{"location":"community/localization/#navigating-between-languages","title":"Navigating Between Languages","text":"<p>The site global config.toml file is where language navigation is configured.</p> <p>To add a new language, add a new set of parameters using the two-letter language code defined above. Example:</p> <pre><code># Korean\n[languages.ko]\ntitle = \"Helm\"\ndescription = \"Helm - The Kubernetes Package Manager.\"\ncontentDir = \"content/ko\"\nlanguageName = \"\ud55c\uad6d\uc5b4 Korean\"\nweight = 1\n</code></pre>"},{"location":"community/localization/#resolving-internal-links","title":"Resolving Internal Links","text":"<p>Translated content will sometimes include links to pages that only exist in another language. This will result in site build errors. Example:</p> <pre><code>12:45:31 PM: htmltest started at 12:45:30 on app\n12:45:31 PM: ========================================================================\n12:45:31 PM: ko/docs/chart_template_guide/accessing_files/index.html\n12:45:31 PM:   hash does not exist --- ko/docs/chart_template_guide/accessing_files/index.html --&gt; #basic-example\n12:45:31 PM: \u2718\u2718\u2718 failed in 197.566561ms\n12:45:31 PM: 1 error in 212 documents\n</code></pre> <p>To resolve this, you need to check your content for internal links.</p> <ul> <li>anchor links need to reflect the translated <code>id</code> value</li> <li>internal page links need to be fixed</li> </ul> <p>For internal pages that do not exist (or have not been translated yet), the site will not build until a correction is made. As a fallback, the url can point to another language where that content does exist as follows:</p> <p><code>&lt; relref path=\"/docs/topics/library_charts.md\" lang=\"en\" &gt;</code></p> <p>See the Hugo Docs on cross references between languages for more info.</p>"},{"location":"community/related/","title":"Related Projects and Documentation","text":"<p>The Helm community has produced many extra tools, plugins, and documentation about Helm. We love to hear about these projects.</p> <p>If you have anything you'd like to add to this list, please open an issue or pull request.</p>"},{"location":"community/related/#helm-plugins","title":"Helm Plugins","text":"<ul> <li>helm-adopt - A helm v3 plugin to adopt   existing k8s resources into a new generated helm chart.</li> <li>helm-cel - Plugin that uses Common Expression Language (CEL) to validate values.</li> <li>helm-chartsnap - Snapshot testing plugin for Helm charts.</li> <li>Helm Diff - Preview <code>helm upgrade</code>   as a coloured diff</li> <li>Helm Dt - Plugin that helps distributing Helm charts across OCI registries and on Air gap environments</li> <li>Helm Dashboard - GUI for Helm, visualize releases and repositories, manifest diffs</li> <li>helm-gcs - Plugin to manage repositories   on Google Cloud Storage</li> <li>helm-git - Install charts and retrieve   values files from your Git repositories</li> <li>helm-k8comp - Plugin to create Helm   Charts from hiera using k8comp</li> <li>helm-mapkubeapis - Update helm release   metadata to replace deprecated or removed Kubernetes APIs</li> <li>helm-migrate-values - Plugin to migrate user-specified values across Helm chart versions to handle breaking schema changes in <code>values.yaml</code></li> <li>helm-monitor - Plugin to   monitor a release and rollback based on Prometheus/ElasticSearch query</li> <li>helm-release-plugin - Plugin for Release management, Update release values, pulls(re-creates) helm Charts from deployed releases, set helm release TTL.</li> <li>helm-s3 - Helm plugin that allows to   use AWS S3 as a [private] chart repository</li> <li>helm-schema-gen - Helm   Plugin that generates values yaml schema for your Helm 3 charts</li> <li>helm-secrets - Plugin to manage   and store secrets safely (based on sops)</li> <li>helm-sigstore -   Plugin for Helm to integrate the sigstore ecosystem. Search, upload and verify signed Helm charts.</li> <li>helm-tanka - A Helm plugin for   rendering Tanka/Jsonnet inside Helm charts.</li> <li>hc-unit - Plugin for unit testing   charts locally using OPA (Open Policy Agent) &amp; Rego</li> <li>helm-unittest - Plugin for unit   testing chart locally with YAML</li> <li>helm-val - A plugin to get   values from a previous release.</li> <li>helm-external-val - A plugin that fetches helm values from external sources (configMaps, Secrets, etc.)</li> <li>helm-images - Helm plugin to fetch all possible images from the chart before deployment or from a deployed release</li> <li>helm-drift - Helm plugin that identifies the configuration that has drifted from the Helm chart</li> <li>helm-tui - A light UI to manage your Helm assets without leaving the terminal</li> </ul> <p>We also encourage GitHub authors to use the helm-plugin tag on their plugin repositories.</p>"},{"location":"community/related/#additional-tools","title":"Additional Tools","text":"<p>Tools layered on top of Helm.</p> <ul> <li>Aptakube - Desktop UI for Kubernetes and Helm Releases</li> <li>Armada - Manage   prefixed releases throughout various Kubernetes namespaces, and removes   completed jobs for complex deployments</li> <li>avionix -   Python interface for generating Helm   charts and Kubernetes yaml, allowing for inheritance and less duplication of code</li> <li>Botkube - Run Helm commands directly from Slack,   Discord, Microsoft Teams, and Mattermost.</li> <li>Captain - A Helm3 Controller using   HelmRequest and Release CRD</li> <li>Chartify - Generate Helm charts from   existing Kubernetes resources.</li> <li>ChartMuseum - Helm Chart Repository   with support for Amazon S3 and Google Cloud Storage</li> <li>chart-registry - Helm Charts   Hosts on OCI Registry</li> <li>Codefresh - Kubernetes native CI/CD and management   platform with UI dashboards for managing Helm charts and releases</li> <li>\u2060Cyclops - Dynamic Kubernetes UI rendering based   on Helm charts</li> <li>Flux -   Continuous and progressive delivery from Git to Kubernetes.</li> <li>Helmfile - Helmfile is a declarative   spec for deploying helm charts</li> <li>Helmper - Helmper helps you   import Helm Charts - including all OCI artifacts(images), to your own OCI   registries. Helmper also facilitates security scanning and patching of OCI   images. Helmper utilizes Helm, Oras, Trivy, Copacetic and Buildkitd.</li> <li>Helmsman - Helmsman is a   helm-charts-as-code tool which enables   installing/upgrading/protecting/moving/deleting releases from version   controlled desired state files (described in a simple TOML format)</li> <li>HULL - This library chart provides a    ready-to-use interface for specifying all Kubernetes objects directly in the <code>values.yaml</code>.   It removes the need to write any templates for your charts and comes with many   additional features to simplify Helm chart creation and usage.</li> <li>K8Studio -   Desktop UI for Managing Kubernetes Clusters with Integrated Helm Manager.</li> <li>Konveyor Move2Kube -   Generate Helm charts for your   existing projects.</li> <li>Landscaper - \"Landscaper takes a set   of Helm Chart references with values (a desired state), and realizes this in a   Kubernetes cluster.\"</li> <li>Monocular - Web UI for Helm Chart   repositories</li> <li>Monokle - Desktop tool for creating, debugging and deploying Kubernetes resources and Helm Charts</li> <li>Orkestra - A cloud-native Release   Orchestration and Lifecycle Management (LCM) platform for a related group of   Helm releases and their subcharts</li> <li>Tanka - Grafana Tanka configures Kubernetes   resources through Jsonnet with the ability to consume Helm Charts</li> <li>Terraform Helm   Provider - The Helm   provider for HashiCorp Terraform enables lifecycle management of Helm Charts   with a declarative infrastructure-as-code syntax.  The Helm provider is often   paired the other Terraform providers, like the Kubernetes provider, to create   a common workflow across all infrastructure services.</li> <li>VIM-Kubernetes - VIM plugin   for Kubernetes and Helm</li> </ul>"},{"location":"community/related/#helm-included","title":"Helm Included","text":"<p>Platforms, distributions, and services that include Helm support.</p> <ul> <li>Kubernetic - Kubernetes Desktop Client</li> <li>Jenkins X - open source automated CI/CD for   Kubernetes which uses Helm for   promoting applications   through environments via GitOps</li> </ul>"},{"location":"community/related/#misc","title":"Misc","text":"<p>Grab bag of useful things for Chart authors and Helm users.</p> <ul> <li>Await - Docker image to \"await\" different   conditions--especially useful for init containers. More   Info</li> </ul>"},{"location":"community/release_checklist/","title":"A Maintainer's Guide to Releasing Helm","text":"<p>Time for a new Helm release! As a Helm maintainer cutting a release, you are the best person to update this release checklist should your experiences vary from what's documented here.</p> <p>All releases will be of the form vX.Y.Z where X is the major version number, Y is the minor version number and Z is the patch release number. This project strictly follows semantic versioning so following this step is critical.</p> <p>Helm announces in advance the date of its next minor release. Every effort should be made to respect the announced date.  Furthermore, when starting the release process, the date for the next release should have been selected as it will be used in the release process.</p> <p>These directions will cover initial configuration followed by the release process for three different kinds of releases:</p> <ul> <li>Major Releases - released less frequently - have breaking changes</li> <li>Minor Releases - released every 3 to 4 months - no breaking changes</li> <li>Patch Releases - released monthly - do not require all steps in this guide</li> </ul> <p>Initial Configuration</p> <ol> <li>Create the Release Branch</li> <li>Major/Minor releases: Change the Version Number in Git</li> <li>Major/Minor releases: Commit and Push the Release Branch</li> <li>Major/Minor releases: Create a Release Candidate</li> <li>Major/Minor releases: Iterate on Successive Release Candidates</li> <li>Finalize the Release</li> <li>Write the Release Notes</li> <li>PGP Sign the downloads</li> <li>Publish Release</li> <li>Update Docs</li> <li>Tell the Community</li> </ol>"},{"location":"community/release_checklist/#initial-configuration","title":"Initial Configuration","text":""},{"location":"community/release_checklist/#set-up-git-remote","title":"Set Up Git Remote","text":"<p>It is important to note that this document assumes that the git remote in your repository that corresponds to https://github.com/helm/helm is named \"upstream\". If yours is not (for example, if you've chosen to name it \"origin\" or something similar instead), be sure to adjust the listed snippets for your local environment accordingly. If you are not sure what your upstream remote is named, use a command like <code>git remote -v</code> to find out.</p> <p>If you don't have an upstream remote , you can add one using something like:</p> <pre><code>git remote add upstream git@github.com:helm/helm.git\n</code></pre>"},{"location":"community/release_checklist/#set-up-environment-variables","title":"Set Up Environment Variables","text":"<p>In this doc, we are going to reference a few environment variables as well, which you may want to set for convenience. For major/minor releases, use the following:</p> <pre><code>export RELEASE_NAME=vX.Y.0\nexport RELEASE_BRANCH_NAME=\"release-X.Y\"\nexport RELEASE_CANDIDATE_NAME=\"$RELEASE_NAME-rc.1\"\n</code></pre> <p>If you are creating a patch release, use the following instead:</p> <pre><code>export PREVIOUS_PATCH_RELEASE=vX.Y.Z\nexport RELEASE_NAME=vX.Y.Z+1\nexport RELEASE_BRANCH_NAME=\"release-X.Y\"\n</code></pre>"},{"location":"community/release_checklist/#set-up-signing-key","title":"Set Up Signing Key","text":"<p>We are also going to be adding security and verification of the release process by hashing the binaries and providing signature files. We perform this using GitHub and GPG. If you do not have GPG already setup you can follow these steps:</p> <ol> <li>Install GPG</li> <li>Generate GPG    key</li> <li>Add key to GitHub    account</li> <li>Set signing key in    Git</li> </ol> <p>Once you have a signing key you need to add it to the KEYS file at the root of the repository. The instructions for adding it to the KEYS file are in the file. If you have not done so already, you need to add your public key to the keyserver network. If you use GnuPG you can follow the instructions provided by Debian.</p>"},{"location":"community/release_checklist/#1-create-the-release-branch","title":"1. Create the Release Branch","text":""},{"location":"community/release_checklist/#majorminor-releases","title":"Major/Minor Releases","text":"<p>Major releases are for new feature additions and behavioral changes that break backwards compatibility. Minor releases are for new feature additions that do not break backwards compatibility. To create a major or minor release, start by creating a <code>release-X.Y</code> branch from main.</p> <pre><code>git fetch upstream\ngit checkout upstream/main\ngit checkout -b $RELEASE_BRANCH_NAME\n</code></pre> <p>This new branch is going to be the base for the release, which we are going to iterate upon later.</p> <p>Verify that a helm/helm milestone for the release exists on GitHub (creating it if necessary). Make sure PRs and issues for this release are in this milestone.</p> <p>For major &amp; minor releases, move on to step 2: Major/Minor releases: Change the Version Number in Git.</p>"},{"location":"community/release_checklist/#patch-releases","title":"Patch releases","text":"<p>Patch releases are a few critical cherry-picked fixes to existing releases. Start by creating a <code>release-X.Y</code> branch:</p> <pre><code>git fetch upstream\ngit checkout -b $RELEASE_BRANCH_NAME upstream/$RELEASE_BRANCH_NAME\n</code></pre> <p>From here, we can cherry-pick the commits we want to bring into the patch release:</p> <pre><code># get the commits ids we want to cherry-pick\ngit log --oneline\n# cherry-pick the commits starting from the oldest one, without including merge commits\ngit cherry-pick -x &lt;commit-id&gt;\n</code></pre> <p>After the commits have been cherry picked the release branch needs to be pushed.</p> <pre><code>git push upstream $RELEASE_BRANCH_NAME\n</code></pre> <p>Pushing the branch will cause the tests to run. Make sure they pass prior to creating the tag. This new tag is going to be the base for the patch release.</p> <p>Creating a helm/helm milestone is optional for patch releases.</p> <p>Make sure to check GitHub Actions to see that the release passed CI before proceeding. Patch releases can skip steps 2-5 and proceed to step 6 to Finalize the Release.</p>"},{"location":"community/release_checklist/#2-majorminor-releases-change-the-version-number-in-git","title":"2. Major/Minor releases: Change the Version Number in Git","text":"<p>When doing a major or minor release, make sure to update <code>internal/version/version.go</code> with the new release version.</p> <pre><code>$ git diff internal/version/version.go\ndiff --git a/internal/version/version.go b/internal/version/version.go\nindex 712aae64..c1ed191e 100644\n--- a/internal/version/version.go\n+++ b/internal/version/version.go\n@@ -30,7 +30,7 @@ var (\n        // Increment major number for new feature additions and behavioral changes.\n        // Increment minor number for bug fixes and performance enhancements.\n        // Increment patch number for critical fixes to existing releases.\n-       version = \"v3.3\"\n+       version = \"v3.4\"\n\n        // metadata is extra build time data\n        metadata = \"\"\n</code></pre> <p>In addition to updating the version within the <code>version.go</code> file, you will also need to update corresponding tests that are using that version number.</p> <ul> <li><code>cmd/helm/testdata/output/version.txt</code></li> <li><code>cmd/helm/testdata/output/version-client.txt</code></li> <li><code>cmd/helm/testdata/output/version-client-shorthand.txt</code></li> <li><code>cmd/helm/testdata/output/version-short.txt</code></li> <li><code>cmd/helm/testdata/output/version-template.txt</code></li> <li><code>pkg/chartutil/capabilities_test.go</code></li> </ul> <pre><code>git add .\ngit commit -m \"bump version to $RELEASE_NAME\"\n</code></pre> <p>This will update it for the $RELEASE_BRANCH_NAME only. You will also need to pull this change into the main branch for when the next release is being created, as in this example of 3.2 to 3.3, and add it to the milestone for the next release.</p> <pre><code># get the last commit id i.e. commit to bump the version\ngit log --format=\"%H\" -n 1\n\n# create new branch off main\ngit checkout main\ngit checkout -b bump-version-&lt;release_version&gt;\n\n# cherry pick the commit using id from first command\ngit cherry-pick -x &lt;commit-id&gt;\n\n# commit the change\ngit push origin bump-version-&lt;release-version&gt;\n</code></pre>"},{"location":"community/release_checklist/#3-majorminor-releases-commit-and-push-the-release-branch","title":"3. Major/Minor releases: Commit and Push the Release Branch","text":"<p>In order for others to start testing, we can now push the release branch upstream and start the test process.</p> <pre><code>git push upstream $RELEASE_BRANCH_NAME\n</code></pre> <p>Make sure to check GitHub Actions to see that the release passed CI before proceeding.</p> <p>If anyone is available, let others peer-review the branch before continuing to ensure that all the proper changes have been made and all of the commits for the release are there.</p>"},{"location":"community/release_checklist/#4-majorminor-releases-create-a-release-candidate","title":"4. Major/Minor releases: Create a Release Candidate","text":"<p>Now that the release branch is out and ready, it is time to start creating and iterating on release candidates.</p> <pre><code>git tag --sign --annotate \"${RELEASE_CANDIDATE_NAME}\" --message \"Helm release ${RELEASE_CANDIDATE_NAME}\"\ngit push upstream $RELEASE_CANDIDATE_NAME\n</code></pre> <p>GitHub Actions will automatically create a tagged release image and client binary to test with.</p> <p>For testers, the process to start testing after GitHub Actions finishes building the artifacts involves the following steps to grab the client:</p> <p>linux/amd64, using /bin/bash:</p> <pre><code>wget https://get.helm.sh/helm-$RELEASE_CANDIDATE_NAME-linux-amd64.tar.gz\n</code></pre> <p>darwin/amd64, using Terminal.app:</p> <pre><code>wget https://get.helm.sh/helm-$RELEASE_CANDIDATE_NAME-darwin-amd64.tar.gz\n</code></pre> <p>windows/amd64, using PowerShell:</p> <pre><code>PS C:\\&gt; Invoke-WebRequest -Uri \"https://get.helm.sh/helm-$RELEASE_CANDIDATE_NAME-windows-amd64.tar.gz\" -OutFile \"helm-$ReleaseCandidateName-windows-amd64.tar.gz\"\n</code></pre> <p>Then, unpack and move the binary to somewhere on your $PATH, or move it somewhere and add it to your $PATH (e.g. /usr/local/bin/helm for linux/macOS, C:\\Program Files\\helm\\helm.exe for Windows).</p>"},{"location":"community/release_checklist/#5-majorminor-releases-iterate-on-successive-release-candidates","title":"5. Major/Minor releases: Iterate on Successive Release Candidates","text":"<p>Spend several days explicitly investing time and resources to try and break helm in every possible way, documenting any findings pertinent to the release. This time should be spent testing and finding ways in which the release might have caused various features or upgrade environments to have issues, not coding. During this time, the release is in code freeze, and any additional code changes will be pushed out to the next release.</p> <p>During this phase, the $RELEASE_BRANCH_NAME branch will keep evolving as you will produce new release candidates. The frequency of new candidates is up to the release manager: use your best judgement taking into account the severity of reported issues, testers' availability, and the release deadline date. Generally speaking, it is better to let a release roll over the deadline than to ship a broken release.</p> <p>Each time you'll want to produce a new release candidate, you will start by adding commits to the branch by cherry-picking from main:</p> <pre><code>git cherry-pick -x &lt;commit_id&gt;\n</code></pre> <p>You will also want to push the branch to GitHub and ensure it passes CI.</p> <p>After that, tag it and notify users of the new release candidate:</p> <pre><code>export RELEASE_CANDIDATE_NAME=\"$RELEASE_NAME-rc.2\"\ngit tag --sign --annotate \"${RELEASE_CANDIDATE_NAME}\" --message \"Helm release ${RELEASE_CANDIDATE_NAME}\"\ngit push upstream $RELEASE_CANDIDATE_NAME\n</code></pre> <p>Once pushed to GitHub, check to ensure the branch with this tag builds in CI.</p> <p>From here on just repeat this process, continuously testing until you're happy with the release candidate. For a release candidate, we don't write the full notes, but you can scaffold out some release notes.</p>"},{"location":"community/release_checklist/#6-finalize-the-release","title":"6. Finalize the Release","text":"<p>When you're finally happy with the quality of a release candidate, you can move on and create the real thing. Double-check one last time to make sure everything is in order, then finally push the release tag.</p> <pre><code>git checkout $RELEASE_BRANCH_NAME\ngit tag --sign --annotate \"${RELEASE_NAME}\" --message \"Helm release ${RELEASE_NAME}\"\ngit push upstream $RELEASE_NAME\n</code></pre> <p>Verify that the release succeeded in GitHub Actions. If not, you will need to fix the release and push the release again.</p> <p>As the CI job will take some time to run, you can move on to writing release notes while you wait for it to complete.</p>"},{"location":"community/release_checklist/#7-write-the-release-notes","title":"7. Write the Release Notes","text":"<p>We will auto-generate a changelog based on the commits that occurred during a release cycle, but it is usually more beneficial to the end-user if the release notes are hand-written by a human being/marketing team/dog.</p> <p>If you're releasing a major/minor release, listing notable user-facing features is usually sufficient. For patch releases, do the same, but make note of the symptoms and who is affected.</p> <p>The release notes should include the version and planned date of the next release.</p> <p>An example release note for a minor release would look like this:</p> <pre><code>## vX.Y.Z\n\nHelm vX.Y.Z is a feature release. This release, we focused on &lt;insert focal point&gt;. Users are encouraged to upgrade for the best experience.\n\nThe community keeps growing, and we'd love to see you there!\n\n- Join the discussion in [Kubernetes Slack](https://kubernetes.slack.com):\n  - `#helm-users` for questions and just to hang out\n  - `#helm-dev` for discussing PRs, code, and bugs\n- Hang out at the Public Developer Call: Thursday, 9:30 Pacific via [Zoom](https://zoom.us/j/696660622)\n- Test, debug, and contribute charts: [Artifact Hub helm charts](https://artifacthub.io/packages/search?kind=0)\n\n## Notable Changes\n\n- Kubernetes 1.16 is now supported including new manifest apiVersions\n- Sprig was upgraded to 2.22\n\n## Installation and Upgrading\n\nDownload Helm X.Y. The common platform binaries are here:\n\n- [MacOS amd64](https://get.helm.sh/helm-vX.Y.Z-darwin-amd64.tar.gz) ([checksum](https://get.helm.sh/helm-vX.Y.Z-darwin-amd64.tar.gz.sha256sum) / CHECKSUM_VAL)\n- [Linux amd64](https://get.helm.sh/helm-vX.Y.Z-linux-amd64.tar.gz) ([checksum](https://get.helm.sh/helm-vX.Y.Z-linux-amd64.tar.gz.sha256sum) / CHECKSUM_VAL)\n- [Linux arm](https://get.helm.sh/helm-vX.Y.Z-linux-arm.tar.gz) ([checksum](https://get.helm.sh/helm-vX.Y.Z-linux-arm.tar.gz.sha256) / CHECKSUM_VAL)\n- [Linux arm64](https://get.helm.sh/helm-vX.Y.Z-linux-arm64.tar.gz) ([checksum](https://get.helm.sh/helm-vX.Y.Z-linux-arm64.tar.gz.sha256sum) / CHECKSUM_VAL)\n- [Linux i386](https://get.helm.sh/helm-vX.Y.Z-linux-386.tar.gz) ([checksum](https://get.helm.sh/helm-vX.Y.Z-linux-386.tar.gz.sha256) / CHECKSUM_VAL)\n- [Linux ppc64le](https://get.helm.sh/helm-vX.Y.Z-linux-ppc64le.tar.gz) ([checksum](https://get.helm.sh/helm-vX.Y.Z-linux-ppc64le.tar.gz.sha256sum) / CHECKSUM_VAL)\n- [Linux s390x](https://get.helm.sh/helm-vX.Y.Z-linux-s390x.tar.gz) ([checksum](https://get.helm.sh/helm-vX.Y.Z-linux-s390x.tar.gz.sha256sum) / CHECKSUM_VAL)\n- [Windows amd64](https://get.helm.sh/helm-vX.Y.Z-windows-amd64.zip) ([checksum](https://get.helm.sh/helm-vX.Y.Z-windows-amd64.zip.sha256sum) / CHECKSUM_VAL)\n\nThe [Quickstart Guide](https://docs.helm.sh/using_helm/#quickstart-guide) will get you going from there. For **upgrade instructions** or detailed installation notes, check the [install guide](https://docs.helm.sh/using_helm/#installing-helm). You can also use a [script to install](https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3) on any system with `bash`.\n\n## What's Next\n\n- vX.Y.Z+1 will contain only bug fixes and is planned for &lt;insert DATE&gt;.\n- vX.Y+1.0 is the next feature release and is planned for &lt;insert DATE&gt;. This release will focus on ...\n\n## Changelog\n\n- chore(*): bump version to v2.7.0 08c1144f5eb3e3b636d9775617287cc26e53dba4 (Adam Reese)\n- fix circle not building tags f4f932fabd197f7e6d608c8672b33a483b4b76fa (Matthew Fisher)\n</code></pre> <p>A partially completed set of release notes including the changelog can be created by running the following command:</p> <pre><code>export VERSION=\"$RELEASE_NAME\"\nexport PREVIOUS_RELEASE=vX.Y.Z\nmake clean\nmake fetch-dist\nmake release-notes\n</code></pre> <p>This will create a good baseline set of release notes to which you should just need to fill out the Notable Changes and What's next sections.</p> <p>Feel free to add your voice to the release notes; it's nice for people to think we're not all robots.</p> <p>You should also double check the URLs and checksums are correct in the auto-generated release notes.</p> <p>Once finished, go into GitHub to helm/helm releases and edit the release notes for the tagged release with the notes written here. For target branch, set to $RELEASE_BRANCH_NAME.</p> <p>It is now worth getting other people to take a look at the release notes before the release is published. Send a request out to #helm-dev for review. It is always beneficial as it can be easy to miss something.</p>"},{"location":"community/release_checklist/#8-pgp-sign-the-downloads","title":"8. PGP Sign the downloads","text":"<p>While hashes provide a signature that the content of the downloads is what it was generated, signed packages provide traceability of where the package came from.</p> <p>To do this, run the following <code>make</code> commands:</p> <pre><code>export VERSION=\"$RELEASE_NAME\"\nmake clean      # if not already run\nmake fetch-dist # if not already run\nmake sign\n</code></pre> <p>This will generate ascii armored signature files for each of the files pushed by CI.</p> <p>All of the signature files (<code>*.asc</code>) need to be uploaded to the release on GitHub (attach binaries).</p>"},{"location":"community/release_checklist/#9-publish-release","title":"9. Publish Release","text":"<p>Time to make the release official!</p> <p>After the release notes are saved on GitHub, the CI build is completed, and you've added the signature files to the release, you can hit \"Publish\" on the release. This publishes the release, listing it as \"latest\", and shows this release on the front page of the helm/helm repo.</p>"},{"location":"community/release_checklist/#10-update-docs","title":"10. Update Docs","text":"<p>The Helm website docs section lists the Helm versions for the docs. Major, minor, and patch versions need to be updated on the site. The date for the next minor release is also published on the site and must be updated. To do that create a pull request against the helm-www repository. In the <code>config.toml</code> file find the proper <code>params.versions</code> section and update the Helm version, like in this example of updating the current version.  In the same <code>config.toml</code> file, update the <code>params.nextversion</code> section.</p> <p>Close the helm/helm milestone for the release, if applicable.</p> <p>Update the version skew for major and minor releases.</p> <p>Update the release calendar here: * create an entry for the next minor release with a reminder for that day at 5pm GMT * create an entry for the RC1 of the next minor release on the Monday of the week before the planned release, with a reminder for that day at 5pm GMT</p>"},{"location":"community/release_checklist/#11-tell-the-community","title":"11. Tell the Community","text":"<p>Congratulations! You're done. Go grab yourself a $DRINK_OF_CHOICE. You've earned it.</p> <p>After enjoying a nice $DRINK_OF_CHOICE, go forth and announce the new release in Slack and on Twitter with a link to the release on GitHub.</p> <p>Optionally, write a blog post about the new release and showcase some of the new features on there!</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":"<p>This section provides help with the most common questions.</p> <p>We'd love your help making this document better. To add, correct, or remove information, file an issue or send us a pull request.</p>"},{"location":"faq/changes_since_helm2/","title":"Changes Since Helm 2","text":""},{"location":"faq/changes_since_helm2/#changes-since-helm-2","title":"Changes since Helm 2","text":"<p>Here's an exhaustive list of all the major changes introduced in Helm 3.</p>"},{"location":"faq/changes_since_helm2/#removal-of-tiller","title":"Removal of Tiller","text":"<p>During the Helm 2 development cycle, we introduced Tiller. Tiller played an important role for teams working on a shared cluster - it made it possible for multiple different operators to interact with the same set of releases.</p> <p>With role-based access controls (RBAC) enabled by default in Kubernetes 1.6, locking down Tiller for use in a production scenario became more difficult to manage. Due to the vast number of possible security policies, our stance was to provide a permissive default configuration. This allowed first-time users to start experimenting with Helm and Kubernetes without having to dive headfirst into the security controls. Unfortunately, this permissive configuration could grant a user a broad range of permissions they weren\u2019t intended to have. DevOps and SREs had to learn additional operational steps when installing Tiller into a multi-tenant cluster.</p> <p>After hearing how community members were using Helm in certain scenarios, we found that Tiller\u2019s release management system did not need to rely upon an in-cluster operator to maintain state or act as a central hub for Helm release information. Instead, we could simply fetch information from the Kubernetes API server, render the Charts client-side, and store a record of the installation in Kubernetes.</p> <p>Tiller\u2019s primary goal could be accomplished without Tiller, so one of the first decisions we made regarding Helm 3 was to completely remove Tiller.</p> <p>With Tiller gone, the security model for Helm is radically simplified. Helm 3 now supports all the modern security, identity, and authorization features of modern Kubernetes. Helm\u2019s permissions are evaluated using your kubeconfig file. Cluster administrators can restrict user permissions at whatever granularity they see fit. Releases are still recorded in-cluster, and the rest of Helm\u2019s functionality remains.</p>"},{"location":"faq/changes_since_helm2/#improved-upgrade-strategy-3-way-strategic-merge-patches","title":"Improved Upgrade Strategy: 3-way Strategic Merge Patches","text":"<p>Helm 2 used a two-way strategic merge patch. During an upgrade, it compared the most recent chart's manifest against the proposed chart's manifest (the one supplied during <code>helm upgrade</code>). It compared the differences between these two charts to determine what changes needed to be applied to the resources in Kubernetes. If changes were applied to the cluster out-of-band (such as during a <code>kubectl edit</code>), those changes were not considered. This resulted in resources being unable to roll back to its previous state: because Helm only considered the last applied chart's manifest as its current state, if there were no changes in the chart's state, the live state was left unchanged.</p> <p>In Helm 3, we now use a three-way strategic merge patch. Helm considers the old manifest, its live state, and the new manifest when generating a patch.</p>"},{"location":"faq/changes_since_helm2/#examples","title":"Examples","text":"<p>Let's go through a few common examples what this change impacts.</p>"},{"location":"faq/changes_since_helm2/#rolling-back-where-live-state-has-changed","title":"Rolling back where live state has changed","text":"<p>Your team just deployed their application to production on Kubernetes using Helm. The chart contains a Deployment object where the number of replicas is set to three:</p> <pre><code>$ helm install myapp ./myapp\n</code></pre> <p>A new developer joins the team. On their first day while observing the production cluster, a horrible coffee-spilling-on-the-keyboard accident happens and they <code>kubectl scale</code> the production deployment from three replicas down to zero.</p> <pre><code>$ kubectl scale --replicas=0 deployment/myapp\n</code></pre> <p>Another developer on your team notices that the production site is down and decides to rollback the release to its previous state:</p> <pre><code>$ helm rollback myapp\n</code></pre> <p>What happens?</p> <p>In Helm 2, it would generate a patch, comparing the old manifest against the new manifest. Because this is a rollback, it's the same manifest. Helm would determine that there is nothing to change because there is no difference between the old manifest and the new manifest. The replica count continues to stay at zero. Panic ensues.</p> <p>In Helm 3, the patch is generated using the old manifest, the live state, and the new manifest. Helm recognizes that the old state was at three, the live state is at zero and the new manifest wishes to change it back to three, so it generates a patch to change the state back to three.</p>"},{"location":"faq/changes_since_helm2/#upgrades-where-live-state-has-changed","title":"Upgrades where live state has changed","text":"<p>Many service meshes and other controller-based applications inject data into Kubernetes objects. This can be something like a sidecar, labels, or other information. Previously if you had the given manifest rendered from a Chart:</p> <pre><code>containers:\n- name: server\n  image: nginx:2.0.0\n</code></pre> <p>And the live state was modified by another application to</p> <pre><code>containers:\n- name: server\n  image: nginx:2.0.0\n- name: my-injected-sidecar\n  image: my-cool-mesh:1.0.0\n</code></pre> <p>Now, you want to upgrade the <code>nginx</code> image tag to <code>2.1.0</code>. So, you upgrade to a chart with the given manifest:</p> <pre><code>containers:\n- name: server\n  image: nginx:2.1.0\n</code></pre> <p>What happens?</p> <p>In Helm 2, Helm generates a patch of the <code>containers</code> object between the old manifest and the new manifest. The cluster's live state is not considered during the patch generation.</p> <p>The cluster's live state is modified to look like the following:</p> <pre><code>containers:\n- name: server\n  image: nginx:2.1.0\n</code></pre> <p>The sidecar pod is removed from live state. More panic ensues.</p> <p>In Helm 3, Helm generates a patch of the <code>containers</code> object between the old manifest, the live state, and the new manifest. It notices that the new manifest changes the image tag to <code>2.1.0</code>, but live state contains a sidecar container.</p> <p>The cluster's live state is modified to look like the following:</p> <pre><code>containers:\n- name: server\n  image: nginx:2.1.0\n- name: my-injected-sidecar\n  image: my-cool-mesh:1.0.0\n</code></pre>"},{"location":"faq/changes_since_helm2/#release-names-are-now-scoped-to-the-namespace","title":"Release Names are now scoped to the Namespace","text":"<p>With the removal of Tiller, the information about each release had to go somewhere. In Helm 2, this was stored in the same namespace as Tiller. In practice, this meant that once a name was used by a release, no other release could use that same name, even if it was deployed in a different namespace.</p> <p>In Helm 3, information about a particular release is now stored in the same namespace as the release itself. This means that users can now <code>helm install wordpress stable/wordpress</code> in two separate namespaces, and each can be referred with <code>helm list</code> by changing the current namespace context (e.g. <code>helm list --namespace foo</code>).</p> <p>With this greater alignment to native cluster namespaces, the <code>helm list</code> command no longer lists all releases by default. Instead, it will list only the releases in the namespace of your current kubernetes context (i.e. the namespace shown when you run <code>kubectl config view --minify</code>). It also means you must supply the <code>--all-namespaces</code> flag to <code>helm list</code> to get behaviour similar to Helm 2.</p>"},{"location":"faq/changes_since_helm2/#secrets-as-the-default-storage-driver","title":"Secrets as the default storage driver","text":"<p>In Helm 3, Secrets are now used as the default storage driver. Helm 2 used ConfigMaps by default to store release information. In Helm 2.7.0, a new storage backend that uses Secrets for storing release information was implemented, and it is now the default starting in Helm 3.</p> <p>Changing to Secrets as the Helm 3 default allows for additional security in protecting charts in conjunction with the release of Secret encryption in Kubernetes.</p> <p>Encrypting secrets at rest became available as an alpha feature in Kubernetes 1.7 and became stable as of Kubernetes 1.13. This allows users to encrypt Helm release metadata at rest, and so it is a good starting point that can be expanded later into using something like Vault.</p>"},{"location":"faq/changes_since_helm2/#go-import-path-changes","title":"Go import path changes","text":"<p>In Helm 3, Helm switched the Go import path over from <code>k8s.io/helm</code> to <code>helm.sh/helm/v3</code>. If you intend to upgrade to the Helm 3 Go client libraries, make sure to change your import paths.</p>"},{"location":"faq/changes_since_helm2/#capabilities","title":"Capabilities","text":"<p>The <code>.Capabilities</code> built-in object available during the rendering stage has been simplified.</p> <p>Built-in Objects</p>"},{"location":"faq/changes_since_helm2/#validating-chart-values-with-jsonschema","title":"Validating Chart Values with JSONSchema","text":"<p>A JSON Schema can now be imposed upon chart values. This ensures that values provided by the user follow the schema laid out by the chart maintainer, providing better error reporting when the user provides an incorrect set of values for a chart.</p> <p>Validation occurs when any of the following commands are invoked:</p> <ul> <li><code>helm install</code></li> <li><code>helm upgrade</code></li> <li><code>helm template</code></li> <li><code>helm lint</code></li> </ul> <p>See the documentation on Schema files for more information.</p>"},{"location":"faq/changes_since_helm2/#consolidation-of-requirementsyaml-into-chartyaml","title":"Consolidation of <code>requirements.yaml</code> into <code>Chart.yaml</code>","text":"<p>The Chart dependency management system moved from requirements.yaml and requirements.lock to Chart.yaml and Chart.lock. We recommend that new charts meant for Helm 3 use the new format. However, Helm 3 still understands Chart API version 1 (<code>v1</code>) and will load existing <code>requirements.yaml</code> files</p> <p>In Helm 2, this is how a <code>requirements.yaml</code> looked:</p> <pre><code>dependencies:\n- name: mariadb\n  version: 5.x.x\n  repository: https://charts.helm.sh/stable\n  condition: mariadb.enabled\n  tags:\n    - database\n</code></pre> <p>In Helm 3, the dependency is expressed the same way, but now from your <code>Chart.yaml</code>:</p> <pre><code>dependencies:\n- name: mariadb\n  version: 5.x.x\n  repository: https://charts.helm.sh/stable\n  condition: mariadb.enabled\n  tags:\n    - database\n</code></pre> <p>Charts are still downloaded and placed in the <code>charts/</code> directory, so subcharts vendored into the <code>charts/</code> directory will continue to work without modification.</p>"},{"location":"faq/changes_since_helm2/#name-or-generate-name-is-now-required-on-install","title":"Name (or --generate-name) is now required on install","text":"<p>In Helm 2, if no name was provided, an auto-generated name would be given. In production, this proved to be more of a nuisance than a helpful feature. In Helm 3, Helm will throw an error if no name is provided with <code>helm install</code>.</p> <p>For those who still wish to have a name auto-generated for you, you can use the <code>--generate-name</code> flag to create one for you.</p>"},{"location":"faq/changes_since_helm2/#pushing-charts-to-oci-registries","title":"Pushing Charts to OCI Registries","text":"<p>This is an experimental feature introduced in Helm 3. To use, set the environment variable <code>HELM_EXPERIMENTAL_OCI=1</code>.</p> <p>At a high level, a Chart Repository is a location where Charts can be stored and shared. The Helm client packs and ships Helm Charts to a Chart Repository. Simply put, a Chart Repository is a basic HTTP server that houses an index.yaml file and some packaged charts.</p> <p>While there are several benefits to the Chart Repository API meeting the most basic storage requirements, a few drawbacks have started to show:</p> <ul> <li>Chart Repositories have a very hard time abstracting most of the security   implementations required in a production environment. Having a standard API   for authentication and authorization is very important in production   scenarios.</li> <li>Helm\u2019s Chart provenance tools used for signing and verifying the integrity and   origin of a chart are an optional piece of the Chart publishing process.</li> <li>In multi-tenant scenarios, the same Chart can be uploaded by another tenant,   costing twice the storage cost to store the same content. Smarter chart   repositories have been designed to handle this, but it\u2019s not a part of the   formal specification.</li> <li>Using a single index file for search, metadata information, and fetching   Charts has made it difficult or clunky to design around in secure multi-tenant   implementations.</li> </ul> <p>Docker\u2019s Distribution project (also known as Docker Registry v2) is the successor to the Docker Registry project. Many major cloud vendors have a product offering of the Distribution project, and with so many vendors offering the same product, the Distribution project has benefited from many years of hardening, security best practices, and battle-testing.</p> <p>Please have a look at <code>helm help chart</code> and <code>helm help registry</code> for more information on how to package a chart and push it to a Docker registry.</p> <p>For more info, please see this page.</p>"},{"location":"faq/changes_since_helm2/#removal-of-helm-serve","title":"Removal of <code>helm serve</code>","text":"<p><code>helm serve</code> ran a local Chart Repository on your machine for development purposes. However, it didn't receive much uptake as a development tool and had numerous issues with its design. In the end, we decided to remove it and split it out as a plugin.</p> <p>For a similar experience to <code>helm serve</code>, have a look at the local filesystem storage option in ChartMuseum and the servecm plugin.</p>"},{"location":"faq/changes_since_helm2/#library-chart-support","title":"Library chart support","text":"<p>Helm 3 supports a class of chart called a \u201clibrary chart\u201d. This is a chart that is shared by other charts, but does not create any release artifacts of its own. A library chart\u2019s templates can only declare <code>define</code> elements. Globally scoped non-<code>define</code> content is simply ignored. This allows users to re-use and share snippets of code that can be re-used across many charts, avoiding redundancy and keeping charts DRY.</p> <p>Library charts are declared in the dependencies directive in Chart.yaml, and are installed and managed like any other chart.</p> <pre><code>dependencies:\n  - name: mylib\n    version: 1.x.x\n    repository: quay.io\n</code></pre> <p>We\u2019re very excited to see the use cases this feature opens up for chart developers, as well as any best practices that arise from consuming library charts.</p>"},{"location":"faq/changes_since_helm2/#chartyaml-apiversion-bump","title":"Chart.yaml apiVersion bump","text":"<p>With the introduction of library chart support and the consolidation of requirements.yaml into Chart.yaml, clients that understood Helm 2's package format won't understand these new features. So, we bumped the apiVersion in Chart.yaml from <code>v1</code> to <code>v2</code>.</p> <p><code>helm create</code> now creates charts using this new format, so the default apiVersion was bumped there as well.</p> <p>Clients wishing to support both versions of Helm charts should inspect the <code>apiVersion</code> field in Chart.yaml to understand how to parse the package format.</p>"},{"location":"faq/changes_since_helm2/#xdg-base-directory-support","title":"XDG Base Directory Support","text":"<p>The XDG Base Directory Specification is a portable standard defining where configuration, data, and cached files should be stored on the filesystem.</p> <p>In Helm 2, Helm stored all this information in <code>~/.helm</code> (affectionately known as <code>helm home</code>), which could be changed by setting the <code>$HELM_HOME</code> environment variable, or by using the global flag <code>--home</code>.</p> <p>In Helm 3, Helm now respects the following environment variables as per the XDG Base Directory Specification:</p> <ul> <li><code>$XDG_CACHE_HOME</code></li> <li><code>$XDG_CONFIG_HOME</code></li> <li><code>$XDG_DATA_HOME</code></li> </ul> <p>Helm plugins are still passed <code>$HELM_HOME</code> as an alias to <code>$XDG_DATA_HOME</code> for backwards compatibility with plugins looking to use <code>$HELM_HOME</code> as a scratchpad environment.</p> <p>Several new environment variables are also passed in to the plugin's environment to accommodate this change:</p> <ul> <li><code>$HELM_PATH_CACHE</code> for the cache path</li> <li><code>$HELM_PATH_CONFIG</code> for the config path</li> <li><code>$HELM_PATH_DATA</code> for the data path</li> </ul> <p>Helm plugins looking to support Helm 3 should consider using these new environment variables instead.</p>"},{"location":"faq/changes_since_helm2/#cli-command-renames","title":"CLI Command Renames","text":"<p>In order to better align the verbiage from other package managers, <code>helm delete</code> was re-named to <code>helm uninstall</code>. <code>helm delete</code> is still retained as an alias to <code>helm uninstall</code>, so either form can be used.</p> <p>In Helm 2, in order to purge the release ledger, the <code>--purge</code> flag had to be provided. This functionality is now enabled by default. To retain the previous behavior, use <code>helm uninstall --keep-history</code>.</p> <p>Additionally, several other commands were re-named to accommodate the same conventions:</p> <ul> <li><code>helm inspect</code> -&gt; <code>helm show</code></li> <li><code>helm fetch</code> -&gt; <code>helm pull</code></li> </ul> <p>These commands have also retained their older verbs as aliases, so you can continue to use them in either form.</p>"},{"location":"faq/changes_since_helm2/#automatically-creating-namespaces","title":"Automatically creating namespaces","text":"<p>When creating a release in a namespace that does not exist, Helm 2 created the namespace.  Helm 3 follows the behavior of other Kubernetes tooling and returns an error if the namespace does not exist.  Helm 3 will create the namespace if you explicitly specify <code>--create-namespace</code> flag.</p>"},{"location":"faq/changes_since_helm2/#what-happened-to-chartapiversion","title":"What happened to .Chart.ApiVersion?","text":"<p>Helm follows the typical convention for CamelCasing which is to capitalize an acronym. We have done this elsewhere in the code, such as with <code>.Capabilities.APIVersions.Has</code>. In Helm v3, we corrected <code>.Chart.ApiVersion</code> to follow this pattern, renaming it to <code>.Chart.APIVersion</code>.</p>"},{"location":"faq/installing/","title":"Installing","text":""},{"location":"faq/installing/#installing","title":"Installing","text":""},{"location":"faq/installing/#why-arent-there-native-packages-of-helm-for-fedora-and-other-linux-distros","title":"Why aren't there native packages of Helm for Fedora and other Linux distros?","text":"<p>The Helm project does not maintain packages for operating systems and environments. The Helm community may provide native packages and if the Helm project is made aware of them they will be listed. This is how the Homebrew formula was started and listed. If you're interested in maintaining a package, we'd love it.</p>"},{"location":"faq/installing/#why-do-you-provide-a-curl-bash-script","title":"Why do you provide a <code>curl ...|bash</code> script?","text":"<p>There is a script in our repository (<code>scripts/get-helm-3</code>) that can be executed as a <code>curl ..|bash</code> script. The transfers are all protected by HTTPS, and the script does some auditing of the packages it fetches. However, the script has all the usual dangers of any shell script.</p> <p>We provide it because it is useful, but we suggest that users carefully read the script first. What we'd really like, though, are better packaged releases of Helm.</p>"},{"location":"faq/installing/#how-do-i-put-the-helm-client-files-somewhere-other-than-their-defaults","title":"How do I put the Helm client files somewhere other than their defaults?","text":"<p>Helm uses the XDG structure for storing files. There are environment variables you can use to override these locations:</p> <ul> <li><code>$XDG_CACHE_HOME</code>: set an alternative location for storing cached files.</li> <li><code>$XDG_CONFIG_HOME</code>: set an alternative location for storing Helm   configuration.</li> <li><code>$XDG_DATA_HOME</code>: set an alternative location for storing Helm data.</li> </ul> <p>Note that if you have existing repositories, you will need to re-add them with <code>helm repo add...</code>.</p>"},{"location":"faq/troubleshooting/","title":"Troubleshooting","text":""},{"location":"faq/troubleshooting/#troubleshooting","title":"Troubleshooting","text":""},{"location":"faq/troubleshooting/#i-am-getting-a-warning-about-unable-to-get-an-update-from-the-stable-chart-repository","title":"I am getting a warning about \"Unable to get an update from the \"stable\" chart repository\"","text":"<p>Run <code>helm repo list</code>. If it shows your <code>stable</code> repository pointing to a <code>storage.googleapis.com</code> URL, you will need to update that repository. On November 13, 2020, the Helm Charts repo became unsupported after a year-long deprecation. An archive has been made available at <code>https://charts.helm.sh/stable</code> but will no longer receive updates. </p> <p>You can run the following command to fix your repository:</p> <pre><code>$ helm repo add stable https://charts.helm.sh/stable --force-update  \n</code></pre> <p>The same goes for the <code>incubator</code> repository, which has an archive available at https://charts.helm.sh/incubator. You can run the following command to repair it:</p> <pre><code>$ helm repo add incubator https://charts.helm.sh/incubator --force-update  \n</code></pre>"},{"location":"faq/troubleshooting/#i-am-getting-the-warning-warning-kubernetes-chartsstoragegoogleapiscom-is-deprecated-for-stable-and-will-be-deleted-nov-13-2020","title":"I am getting the warning 'WARNING: \"kubernetes-charts.storage.googleapis.com\" is deprecated for \"stable\" and will be deleted Nov. 13, 2020.'","text":"<p>The old Google helm chart repository has been replaced by a new Helm chart repository.</p> <p>Run the following command to permanently fix this:</p> <pre><code>$ helm repo add stable https://charts.helm.sh/stable --force-update  \n</code></pre> <p>If you get a similar error for <code>incubator</code>, run this command:</p> <pre><code>$ helm repo add incubator https://charts.helm.sh/incubator --force-update  \n</code></pre>"},{"location":"faq/troubleshooting/#when-i-add-a-helm-repo-i-get-the-error-error-repo-httpskubernetes-chartsstoragegoogleapiscom-is-no-longer-available","title":"When I add a Helm repo, I get the error 'Error: Repo \"https://kubernetes-charts.storage.googleapis.com\" is no longer available'","text":"<p>The Helm Chart repositories are no longer supported after a year-long deprecation period.  Archives for these repositories are available at <code>https://charts.helm.sh/stable</code> and <code>https://charts.helm.sh/incubator</code>, however they will no longer receive updates. The command <code>helm repo add</code> will not let you add the old URLs unless you specify <code>--use-deprecated-repos</code>.</p>"},{"location":"faq/troubleshooting/#on-gke-google-container-engine-i-get-no-ssh-tunnels-currently-open","title":"On GKE (Google Container Engine) I get \"No SSH tunnels currently open\"","text":"<pre><code>Error: Error forwarding ports: error upgrading connection: No SSH tunnels currently open. Were the targets able to accept an ssh-key for user \"gke-[redacted]\"?\n</code></pre> <p>Another variation of the error message is:</p> <pre><code>Unable to connect to the server: x509: certificate signed by unknown authority\n</code></pre> <p>The issue is that your local Kubernetes config file must have the correct credentials.</p> <p>When you create a cluster on GKE, it will give you credentials, including SSL certificates and certificate authorities. These need to be stored in a Kubernetes config file (Default: <code>~/.kube/config</code>) so that <code>kubectl</code> and <code>helm</code> can access them.</p>"},{"location":"faq/troubleshooting/#after-migration-from-helm-2-helm-list-shows-only-some-or-none-of-my-releases","title":"After migration from Helm 2, <code>helm list</code> shows only some (or none) of my releases","text":"<p>It is likely that you have missed the fact that Helm 3 now uses cluster namespaces throughout to scope releases. This means that for all commands referencing a release you must either:</p> <ul> <li>rely on the current namespace in the active kubernetes context (as described   by the <code>kubectl config view --minify</code> command),</li> <li>specify the correct namespace using the <code>--namespace</code>/<code>-n</code> flag, or</li> <li>for the <code>helm list</code> command, specify the <code>--all-namespaces</code>/<code>-A</code> flag</li> </ul> <p>This applies to <code>helm ls</code>, <code>helm uninstall</code>, and all other <code>helm</code> commands referencing a release.</p>"},{"location":"faq/troubleshooting/#on-macos-the-file-etcmdns_debug-is-accessed-why","title":"On macOS, the file <code>/etc/.mdns_debug</code> is accessed. Why?","text":"<p>We are aware of a case on macOS where Helm will try to access a file named <code>/etc/.mdns_debug</code>. If the file exists, Helm holds the file handle open while it executes.</p> <p>This is caused by macOS's MDNS library. It attempts to load that file to read debugging settings (if enabled). The file handle probably should not be held open, and this issue has been reported to Apple. However, it is macOS, not Helm, that causes this behavior.</p> <p>If you do not want Helm to load this file, you may be able to compile Helm to as a static library that does not use the host network stack. Doing so will inflate the binary size of Helm, but will prevent the file from being open.</p> <p>This issue was originally flagged as a potential security problem. But it has since been determined that there is no flaw or vulnerability caused by this behavior.</p>"},{"location":"faq/troubleshooting/#helm-repo-add-fails-when-it-used-to-work","title":"helm repo add fails when it used to work","text":"<p>In helm 3.3.1 and before, the command <code>helm repo add &lt;reponame&gt; &lt;url&gt;</code> will give no output if you attempt to add a repo which already exists. The flag <code>--no-update</code> would raise an error if the repo was already registered.</p> <p>In helm 3.3.2 and beyond, an attempt to add an existing repo will error:</p> <p><code>Error: repository name (reponame) already exists, please specify a different name</code></p> <p>The default behavior is now reversed. <code>--no-update</code> is now ignored, while if you want to replace (overwrite) an existing repo, you can use <code>--force-update</code>.</p> <p>This is due to a breaking change for a security fix as explained in the Helm 3.3.2 release notes.</p>"},{"location":"faq/troubleshooting/#enabling-kubernetes-client-logging","title":"Enabling Kubernetes client logging","text":"<p>Printing log messages for debugging the Kubernetes client can be enabled using the klog flags. Using the <code>-v</code> flag to set verbosity level will be enough for most cases.</p> <p>For example:</p> <pre><code>helm list -v 6\n</code></pre>"},{"location":"faq/troubleshooting/#tiller-installations-stopped-working-and-access-is-denied","title":"Tiller installations stopped working and access is denied","text":"<p>Helm releases used to be available from https://storage.googleapis.com/kubernetes-helm/. As explained in \"Announcing get.helm.sh\", the official location changed in June 2019. GitHub Container Registry makes all the old Tiller images available.</p> <p>If you are trying to download older versions of Helm from the storage bucket you used in the past, you may find that they are missing:</p> <pre><code>&lt;Error&gt;\n    &lt;Code&gt;AccessDenied&lt;/Code&gt;\n    &lt;Message&gt;Access denied.&lt;/Message&gt;\n    &lt;Details&gt;Anonymous caller does not have storage.objects.get access to the Google Cloud Storage object.&lt;/Details&gt;\n&lt;/Error&gt;\n</code></pre> <p>The legacy Tiller image location began the removal of images in August 2021. We have made these images available at the GitHub Container Registry location. For example, to download version v2.17.0, replace:</p> <p><code>https://storage.googleapis.com/kubernetes-helm/helm-v2.17.0-linux-amd64.tar.gz</code></p> <p>with:</p> <p><code>https://get.helm.sh/helm-v2.17.0-linux-amd64.tar.gz</code></p> <p>To initialize with Helm v2.17.0:</p> <p><code>helm init \u2014upgrade</code></p> <p>Or if a different version is needed, use the --tiller-image flag to override the default location and install a specific Helm v2 version:</p> <p><code>helm init --tiller-image ghcr.io/helm/tiller:v2.16.9</code></p> <p>Note: The Helm maintainers recommend migration to a currently-supported version of Helm. Helm v2.17.0 was the final release of Helm v2; Helm v2 is unsupported since November 2020, as detailed in Helm 2 and the Charts Project Are Now Unsupported. Many CVEs have been flagged against Helm since then, and those exploits are patched in Helm v3 but will never be patched in Helm v2. See the current list of published Helm advisories and make a plan to migrate to Helm v3 today.</p>"},{"location":"faq/uninstalling/","title":"Uninstalling","text":""},{"location":"faq/uninstalling/#uninstalling","title":"Uninstalling","text":""},{"location":"faq/uninstalling/#i-want-to-delete-my-local-helm-where-are-all-its-files","title":"I want to delete my local Helm. Where are all its files?","text":"<p>Along with the <code>helm</code> binary, Helm stores some files in the following locations:</p> <ul> <li>$XDG_CACHE_HOME</li> <li>$XDG_CONFIG_HOME</li> <li>$XDG_DATA_HOME</li> </ul> <p>The following table gives the default folder for each of these, by OS:</p> Operating System Cache Path Configuration Path Data Path Linux <code>$HOME/.cache/helm</code> <code>$HOME/.config/helm</code> <code>$HOME/.local/share/helm</code> macOS <code>$HOME/Library/Caches/helm</code> <code>$HOME/Library/Preferences/helm</code> <code>$HOME/Library/helm</code> Windows <code>%TEMP%\\helm</code> <code>%APPDATA%\\helm</code> <code>%APPDATA%\\helm</code>"},{"location":"glossary/","title":"Glossary","text":""},{"location":"glossary/#chart","title":"Chart","text":"<p>A Helm package that contains information sufficient for installing a set of Kubernetes resources into a Kubernetes cluster.</p> <p>Charts contain a <code>Chart.yaml</code> file as well as templates, default values (<code>values.yaml</code>), and dependencies.</p> <p>Charts are developed in a well-defined directory structure, and then packaged into an archive format called a chart archive.</p>"},{"location":"glossary/#chart-archive","title":"Chart Archive","text":"<p>A chart archive is a tarred and gzipped (and optionally signed) chart.</p>"},{"location":"glossary/#chart-dependency-subcharts","title":"Chart Dependency (Subcharts)","text":"<p>Charts may depend upon other charts. There are two ways a dependency may occur:</p> <ul> <li>Soft dependency: A chart may simply not function without another chart being   installed in a cluster. Helm does not provide tooling for this case. In this   case, dependencies may be managed separately.</li> <li>Hard dependency: A chart may contain (inside of its <code>charts/</code> directory)   another chart upon which it depends. In this case, installing the chart will   install all of its dependencies. In this case, a chart and its dependencies   are managed as a collection.</li> </ul> <p>When a chart is packaged (via <code>helm package</code>) all of its hard dependencies are bundled with it.</p>"},{"location":"glossary/#chart-version","title":"Chart Version","text":"<p>Charts are versioned according to the SemVer 2 spec. A version number is required on every chart.</p>"},{"location":"glossary/#chartyaml","title":"Chart.yaml","text":"<p>Information about a chart is stored in a special file called <code>Chart.yaml</code>. Every chart must have this file.</p>"},{"location":"glossary/#helm-and-helm","title":"Helm (and helm)","text":"<p>Helm is the package manager for Kubernetes. As an operating system package manager makes it easy to install tools on an OS, Helm makes it easy to install applications and resources into Kubernetes clusters.</p> <p>While Helm is the name of the project, the command line client is also named <code>helm</code>. By convention, when speaking of the project, Helm is capitalized. When speaking of the client, helm is in lowercase.</p>"},{"location":"glossary/#helm-configuration-files-xdg","title":"Helm Configuration Files (XDG)","text":"<p>Helm stores its configuration files in XDG directories. These directories are created the first time <code>helm</code> is run.</p>"},{"location":"glossary/#kube-config-kubeconfig","title":"Kube Config (KUBECONFIG)","text":"<p>The Helm client learns about Kubernetes clusters by using files in the Kube config file format. By default, Helm attempts to find this file in the place where <code>kubectl</code> creates it (<code>$HOME/.kube/config</code>).</p>"},{"location":"glossary/#lint-linting","title":"Lint (Linting)","text":"<p>To lint a chart is to validate that it follows the conventions and requirements of the Helm chart standard. Helm provides tools to do this, notably the <code>helm lint</code> command.</p>"},{"location":"glossary/#provenance-provenance-file","title":"Provenance (Provenance file)","text":"<p>Helm charts may be accompanied by a provenance file which provides information about where the chart came from and what it contains.</p> <p>Provenance files are one part of the Helm security story. A provenance contains a cryptographic hash of the chart archive file, the Chart.yaml data, and a signature block (an OpenPGP \"clearsign\" block). When coupled with a keychain, this provides chart users with the ability to:</p> <ul> <li>Validate that a chart was signed by a trusted party</li> <li>Validate that the chart file has not been tampered with</li> <li>Validate the contents of a chart metadata (<code>Chart.yaml</code>)</li> <li>Quickly match a chart to its provenance data</li> </ul> <p>Provenance files have the <code>.prov</code> extension, and can be served from a chart repository server or any other HTTP server.</p>"},{"location":"glossary/#release","title":"Release","text":"<p>When a chart is installed, the Helm library creates a release to track that installation.</p> <p>A single chart may be installed many times into the same cluster, and create many different releases. For example, one can install three PostgreSQL databases by running <code>helm install</code> three times with a different release name.</p>"},{"location":"glossary/#release-number-release-version","title":"Release Number (Release Version)","text":"<p>A single release can be updated multiple times. A sequential counter is used to track releases as they change. After a first <code>helm install</code>, a release will have release number 1. Each time a release is upgraded or rolled back, the release number will be incremented.</p>"},{"location":"glossary/#rollback","title":"Rollback","text":"<p>A release can be upgraded to a newer chart or configuration. But since release history is stored, a release can also be rolled back to a previous release number. This is done with the <code>helm rollback</code> command.</p> <p>Importantly, a rolled back release will receive a new release number.</p> Operation Release Number install release 1 upgrade release 2 upgrade release 3 rollback 1 release 4 (but running the same config as release 1) <p>The above table illustrates how release numbers increment across install, upgrade, and rollback.</p>"},{"location":"glossary/#helm-library-or-sdk","title":"Helm Library (or SDK)","text":"<p>The Helm Library (or SDK) refers to the Go code that interacts directly with the Kubernetes API server to install, upgrade, query, and remove Kubernetes resources. It can be imported into a project to use Helm as a client library instead of a CLI.</p>"},{"location":"glossary/#repository-repo-chart-repository","title":"Repository (Repo, Chart Repository)","text":"<p>Helm charts may be stored on dedicated HTTP servers called chart repositories (repositories, or just repos).</p> <p>A chart repository server is a simple HTTP server that can serve an <code>index.yaml</code> file that describes a batch of charts, and provides information on where each chart can be downloaded from. (Many chart repositories serve the charts as well as the <code>index.yaml</code> file.)</p> <p>A Helm client can point to zero or more chart repositories. By default, Helm clients are not configured with any chart repositories. Chart repositories can be added at any time using the <code>helm repo add</code> command.</p>"},{"location":"glossary/#chart-registry-oci-based-registry","title":"Chart Registry (OCI-based Registry)","text":"<p>A Helm Chart Registry is an OCI-based storage and distribution system that is used to host and share Helm chart packages. For more information, see the Helm documentation on registries.</p>"},{"location":"glossary/#values-values-files-valuesyaml","title":"Values (Values Files, values.yaml)","text":"<p>Values provide a way to override template defaults with your own information.</p> <p>Helm Charts are \"parameterized\", which means the chart developer may expose configuration that can be overridden at installation time. For example, a chart may expose a <code>username</code> field that allows setting a user name for a service.</p> <p>These exposed variables are called values in Helm parlance.</p> <p>Values can be set during <code>helm install</code> and <code>helm upgrade</code> operations, either by passing them in directly, or by using a <code>values.yaml</code> file.</p>"},{"location":"helm/","title":"Helm Commands","text":"<p>Here you\u2019ll find the list of CLI commands for Helm, with help info on their usage.</p>"},{"location":"helm/helm/","title":"Helm","text":""},{"location":"helm/helm/#helm","title":"helm","text":"<p>The Helm package manager for Kubernetes.</p>"},{"location":"helm/helm/#synopsis","title":"Synopsis","text":"<p>The Kubernetes package manager</p> <p>Common actions for Helm:</p> <ul> <li>helm search:    search for charts</li> <li>helm pull:      download a chart to your local directory to view</li> <li>helm install:   upload the chart to Kubernetes</li> <li>helm list:      list releases of charts</li> </ul> <p>Environment variables:</p> Name Description $HELM_CACHE_HOME set an alternative location for storing cached files. $HELM_CONFIG_HOME set an alternative location for storing Helm configuration. $HELM_DATA_HOME set an alternative location for storing Helm data. $HELM_DEBUG indicate whether or not Helm is running in Debug mode $HELM_DRIVER set the backend storage driver. Values are: configmap, secret, memory, sql. $HELM_DRIVER_SQL_CONNECTION_STRING set the connection string the SQL storage driver should use. $HELM_MAX_HISTORY set the maximum number of helm release history. $HELM_NAMESPACE set the namespace used for the helm operations. $HELM_NO_PLUGINS disable plugins. Set HELM_NO_PLUGINS=1 to disable plugins. $HELM_PLUGINS set the path to the plugins directory $HELM_REGISTRY_CONFIG set the path to the registry config file. $HELM_REPOSITORY_CACHE set the path to the repository cache directory $HELM_REPOSITORY_CONFIG set the path to the repositories file. $KUBECONFIG set an alternative Kubernetes configuration file (default \"~/.kube/config\") $HELM_KUBEAPISERVER set the Kubernetes API Server Endpoint for authentication $HELM_KUBECAFILE set the Kubernetes certificate authority file. $HELM_KUBEASGROUPS set the Groups to use for impersonation using a comma-separated list. $HELM_KUBEASUSER set the Username to impersonate for the operation. $HELM_KUBECONTEXT set the name of the kubeconfig context. $HELM_KUBETOKEN set the Bearer KubeToken used for authentication. $HELM_KUBEINSECURE_SKIP_TLS_VERIFY indicate if the Kubernetes API server's certificate validation should be skipped (insecure) $HELM_KUBETLS_SERVER_NAME set the server name used to validate the Kubernetes API server certificate $HELM_BURST_LIMIT set the default burst limit in the case the server contains many CRDs (default 100, -1 to disable) $HELM_QPS set the Queries Per Second in cases where a high number of calls exceed the option for higher burst values <p>Helm stores cache, configuration, and data based on the following configuration order:</p> <ul> <li>If a HELM_*_HOME environment variable is set, it will be used</li> <li>Otherwise, on systems supporting the XDG base directory specification, the XDG variables will be used</li> <li>When no other location is set a default location will be used based on the operating system</li> </ul> <p>By default, the default directories depend on the Operating System. The defaults are listed below:</p> Operating System Cache Path Configuration Path Data Path Linux $HOME/.cache/helm $HOME/.config/helm $HOME/.local/share/helm macOS $HOME/Library/Caches/helm $HOME/Library/Preferences/helm $HOME/Library/helm Windows %TEMP%\\helm %APPDATA%\\helm %APPDATA%\\helm"},{"location":"helm/helm/#options","title":"Options","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n  -h, --help                            help for helm\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm/#see-also","title":"SEE ALSO","text":"<ul> <li>helm completion  - generate autocompletion scripts for the specified shell</li> <li>helm create  - create a new chart with the given name</li> <li>helm dependency  - manage a chart's dependencies</li> <li>helm env    - helm client environment information</li> <li>helm get    - download extended information of a named release</li> <li>helm history    - fetch release history</li> <li>helm install    - install a chart</li> <li>helm lint  - examine a chart for possible issues</li> <li>helm list  - list releases</li> <li>helm package    - package a chart directory into a chart archive</li> <li>helm plugin  - install, list, or uninstall Helm plugins</li> <li>helm pull  - download a chart from a repository and (optionally) unpack it in local directory</li> <li>helm push  - push a chart to remote</li> <li>helm registry  - login to or logout from a registry</li> <li>helm repo  - add, list, remove, update, and index chart repositories</li> <li>helm rollback  - roll back a release to a previous revision</li> <li>helm search  - search for a keyword in charts</li> <li>helm show  - show information of a chart</li> <li>helm status  - display the status of the named release</li> <li>helm template  - locally render templates</li> <li>helm test  - run tests for a release</li> <li>helm uninstall    - uninstall a release</li> <li>helm upgrade    - upgrade a release</li> <li>helm verify  - verify that a chart at the given path has been signed and is valid</li> <li>helm version    - print the client version information</li> </ul>"},{"location":"helm/helm/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_completion/","title":"Helm Completion","text":""},{"location":"helm/helm_completion/#helm-completion","title":"helm completion","text":"<p>generate autocompletion scripts for the specified shell</p>"},{"location":"helm/helm_completion/#synopsis","title":"Synopsis","text":"<p>Generate autocompletion scripts for Helm for the specified shell.</p>"},{"location":"helm/helm_completion/#options","title":"Options","text":"<pre><code>  -h, --help   help for completion\n</code></pre>"},{"location":"helm/helm_completion/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_completion/#see-also","title":"SEE ALSO","text":"<ul> <li>helm    - The Helm package manager for Kubernetes.</li> <li>helm completion bash    - generate autocompletion script for bash</li> <li>helm completion fish    - generate autocompletion script for fish</li> <li>helm completion powershell    - generate autocompletion script for powershell</li> <li>helm completion zsh  - generate autocompletion script for zsh</li> </ul>"},{"location":"helm/helm_completion/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_completion_bash/","title":"Helm Completion Bash","text":""},{"location":"helm/helm_completion_bash/#helm-completion-bash","title":"helm completion bash","text":"<p>generate autocompletion script for bash</p>"},{"location":"helm/helm_completion_bash/#synopsis","title":"Synopsis","text":"<p>Generate the autocompletion script for Helm for the bash shell.</p> <p>To load completions in your current shell session:</p> <pre><code>source &lt;(helm completion bash)\n</code></pre> <p>To load completions for every new session, execute once: - Linux:</p> <pre><code>  helm completion bash &gt; /etc/bash_completion.d/helm\n</code></pre> <ul> <li> <p>MacOS:</p> <p>helm completion bash &gt; /usr/local/etc/bash_completion.d/helm</p> </li> </ul> <pre><code>helm completion bash [flags]\n</code></pre>"},{"location":"helm/helm_completion_bash/#options","title":"Options","text":"<pre><code>  -h, --help              help for bash\n      --no-descriptions   disable completion descriptions\n</code></pre>"},{"location":"helm/helm_completion_bash/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_completion_bash/#see-also","title":"SEE ALSO","text":"<ul> <li>helm completion  - generate autocompletion scripts for the specified shell</li> </ul>"},{"location":"helm/helm_completion_bash/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_completion_fish/","title":"Helm Completion Fish","text":""},{"location":"helm/helm_completion_fish/#helm-completion-fish","title":"helm completion fish","text":"<p>generate autocompletion script for fish</p>"},{"location":"helm/helm_completion_fish/#synopsis","title":"Synopsis","text":"<p>Generate the autocompletion script for Helm for the fish shell.</p> <p>To load completions in your current shell session:</p> <pre><code>helm completion fish | source\n</code></pre> <p>To load completions for every new session, execute once:</p> <pre><code>helm completion fish &gt; ~/.config/fish/completions/helm.fish\n</code></pre> <p>You will need to start a new shell for this setup to take effect.</p> <pre><code>helm completion fish [flags]\n</code></pre>"},{"location":"helm/helm_completion_fish/#options","title":"Options","text":"<pre><code>  -h, --help              help for fish\n      --no-descriptions   disable completion descriptions\n</code></pre>"},{"location":"helm/helm_completion_fish/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_completion_fish/#see-also","title":"SEE ALSO","text":"<ul> <li>helm completion  - generate autocompletion scripts for the specified shell</li> </ul>"},{"location":"helm/helm_completion_fish/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_completion_powershell/","title":"Helm Completion Powershell","text":""},{"location":"helm/helm_completion_powershell/#helm-completion-powershell","title":"helm completion powershell","text":"<p>generate autocompletion script for powershell</p>"},{"location":"helm/helm_completion_powershell/#synopsis","title":"Synopsis","text":"<p>Generate the autocompletion script for powershell.</p> <p>To load completions in your current shell session: PS C:&gt; helm completion powershell | Out-String | Invoke-Expression</p> <p>To load completions for every new session, add the output of the above command to your powershell profile.</p> <pre><code>helm completion powershell [flags]\n</code></pre>"},{"location":"helm/helm_completion_powershell/#options","title":"Options","text":"<pre><code>  -h, --help              help for powershell\n      --no-descriptions   disable completion descriptions\n</code></pre>"},{"location":"helm/helm_completion_powershell/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_completion_powershell/#see-also","title":"SEE ALSO","text":"<ul> <li>helm completion  - generate autocompletion scripts for the specified shell</li> </ul>"},{"location":"helm/helm_completion_powershell/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_completion_zsh/","title":"Helm Completion Zsh","text":""},{"location":"helm/helm_completion_zsh/#helm-completion-zsh","title":"helm completion zsh","text":"<p>generate autocompletion script for zsh</p>"},{"location":"helm/helm_completion_zsh/#synopsis","title":"Synopsis","text":"<p>Generate the autocompletion script for Helm for the zsh shell.</p> <p>To load completions in your current shell session:</p> <pre><code>source &lt;(helm completion zsh)\n</code></pre> <p>To load completions for every new session, execute once:</p> <pre><code>helm completion zsh &gt; \"${fpath[1]}/_helm\"\n</code></pre> <pre><code>helm completion zsh [flags]\n</code></pre>"},{"location":"helm/helm_completion_zsh/#options","title":"Options","text":"<pre><code>  -h, --help              help for zsh\n      --no-descriptions   disable completion descriptions\n</code></pre>"},{"location":"helm/helm_completion_zsh/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_completion_zsh/#see-also","title":"SEE ALSO","text":"<ul> <li>helm completion  - generate autocompletion scripts for the specified shell</li> </ul>"},{"location":"helm/helm_completion_zsh/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_create/","title":"Helm Create","text":""},{"location":"helm/helm_create/#helm-create","title":"helm create","text":"<p>create a new chart with the given name</p>"},{"location":"helm/helm_create/#synopsis","title":"Synopsis","text":"<p>This command creates a chart directory along with the common files and directories used in a chart.</p> <p>For example, 'helm create foo' will create a directory structure that looks something like this:</p> <pre><code>foo/\n\u251c\u2500\u2500 .helmignore   # Contains patterns to ignore when packaging Helm charts.\n\u251c\u2500\u2500 Chart.yaml    # Information about your chart\n\u251c\u2500\u2500 values.yaml   # The default values for your templates\n\u251c\u2500\u2500 charts/       # Charts that this chart depends on\n\u2514\u2500\u2500 templates/    # The template files\n    \u2514\u2500\u2500 tests/    # The test files\n</code></pre> <p>'helm create' takes a path for an argument. If directories in the given path do not exist, Helm will attempt to create them as it goes. If the given destination exists and there are files in that directory, conflicting files will be overwritten, but other files will be left alone.</p> <pre><code>helm create NAME [flags]\n</code></pre>"},{"location":"helm/helm_create/#options","title":"Options","text":"<pre><code>  -h, --help             help for create\n  -p, --starter string   the name or absolute path to Helm starter scaffold\n</code></pre>"},{"location":"helm/helm_create/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_create/#see-also","title":"SEE ALSO","text":"<ul> <li>helm    - The Helm package manager for Kubernetes.</li> </ul>"},{"location":"helm/helm_create/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_delete/","title":"Helm delete","text":""},{"location":"helm/helm_delete/#helm-delete","title":"helm delete","text":"<p>This command has been renamed. Please refer instead to helm uninstall.</p>"},{"location":"helm/helm_dependency/","title":"Helm Dependency","text":""},{"location":"helm/helm_dependency/#helm-dependency","title":"helm dependency","text":"<p>manage a chart's dependencies</p>"},{"location":"helm/helm_dependency/#synopsis","title":"Synopsis","text":"<p>Manage the dependencies of a chart.</p> <p>Helm charts store their dependencies in 'charts/'. For chart developers, it is often easier to manage dependencies in 'Chart.yaml' which declares all dependencies.</p> <p>The dependency commands operate on that file, making it easy to synchronize between the desired dependencies and the actual dependencies stored in the 'charts/' directory.</p> <p>For example, this Chart.yaml declares two dependencies:</p> <pre><code># Chart.yaml\ndependencies:\n- name: nginx\n  version: \"1.2.3\"\n  repository: \"https://example.com/charts\"\n- name: memcached\n  version: \"3.2.1\"\n  repository: \"https://another.example.com/charts\"\n</code></pre> <p>The 'name' should be the name of a chart, where that name must match the name in that chart's 'Chart.yaml' file.</p> <p>The 'version' field should contain a semantic version or version range.</p> <p>The 'repository' URL should point to a Chart Repository. Helm expects that by appending '/index.yaml' to the URL, it should be able to retrieve the chart repository's index. Note: 'repository' can be an alias. The alias must start with 'alias:' or '@'.</p> <p>Starting from 2.2.0, repository can be defined as the path to the directory of the dependency charts stored locally. The path should start with a prefix of \"file://\". For example,</p> <pre><code># Chart.yaml\ndependencies:\n- name: nginx\n  version: \"1.2.3\"\n  repository: \"file://../dependency_chart/nginx\"\n</code></pre> <p>If the dependency chart is retrieved locally, it is not required to have the repository added to helm by \"helm add repo\". Version matching is also supported for this case.</p>"},{"location":"helm/helm_dependency/#options","title":"Options","text":"<pre><code>  -h, --help   help for dependency\n</code></pre>"},{"location":"helm/helm_dependency/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_dependency/#see-also","title":"SEE ALSO","text":"<ul> <li>helm    - The Helm package manager for Kubernetes.</li> <li>helm dependency build  - rebuild the charts/ directory based on the Chart.lock file</li> <li>helm dependency list    - list the dependencies for the given chart</li> <li>helm dependency update    - update charts/ based on the contents of Chart.yaml</li> </ul>"},{"location":"helm/helm_dependency/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_dependency_build/","title":"Helm Dependency Build","text":""},{"location":"helm/helm_dependency_build/#helm-dependency-build","title":"helm dependency build","text":"<p>rebuild the charts/ directory based on the Chart.lock file</p>"},{"location":"helm/helm_dependency_build/#synopsis","title":"Synopsis","text":"<p>Build out the charts/ directory from the Chart.lock file.</p> <p>Build is used to reconstruct a chart's dependencies to the state specified in the lock file. This will not re-negotiate dependencies, as 'helm dependency update' does.</p> <p>If no lock file is found, 'helm dependency build' will mirror the behavior of 'helm dependency update'.</p> <pre><code>helm dependency build CHART [flags]\n</code></pre>"},{"location":"helm/helm_dependency_build/#options","title":"Options","text":"<pre><code>      --ca-file string             verify certificates of HTTPS-enabled servers using this CA bundle\n      --cert-file string           identify HTTPS client using this SSL certificate file\n  -h, --help                       help for build\n      --insecure-skip-tls-verify   skip tls certificate checks for the chart download\n      --key-file string            identify HTTPS client using this SSL key file\n      --keyring string             keyring containing public keys (default \"~/.gnupg/pubring.gpg\")\n      --password string            chart repository password where to locate the requested chart\n      --plain-http                 use insecure HTTP connections for the chart download\n      --skip-refresh               do not refresh the local repository cache\n      --username string            chart repository username where to locate the requested chart\n      --verify                     verify the packages against signatures\n</code></pre>"},{"location":"helm/helm_dependency_build/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_dependency_build/#see-also","title":"SEE ALSO","text":"<ul> <li>helm dependency  - manage a chart's dependencies</li> </ul>"},{"location":"helm/helm_dependency_build/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_dependency_list/","title":"Helm Dependency List","text":""},{"location":"helm/helm_dependency_list/#helm-dependency-list","title":"helm dependency list","text":"<p>list the dependencies for the given chart</p>"},{"location":"helm/helm_dependency_list/#synopsis","title":"Synopsis","text":"<p>List all of the dependencies declared in a chart.</p> <p>This can take chart archives and chart directories as input. It will not alter the contents of a chart.</p> <p>This will produce an error if the chart cannot be loaded.</p> <pre><code>helm dependency list CHART [flags]\n</code></pre>"},{"location":"helm/helm_dependency_list/#options","title":"Options","text":"<pre><code>  -h, --help                 help for list\n      --max-col-width uint   maximum column width for output table (default 80)\n</code></pre>"},{"location":"helm/helm_dependency_list/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_dependency_list/#see-also","title":"SEE ALSO","text":"<ul> <li>helm dependency  - manage a chart's dependencies</li> </ul>"},{"location":"helm/helm_dependency_list/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_dependency_update/","title":"Helm Dependency Update","text":""},{"location":"helm/helm_dependency_update/#helm-dependency-update","title":"helm dependency update","text":"<p>update charts/ based on the contents of Chart.yaml</p>"},{"location":"helm/helm_dependency_update/#synopsis","title":"Synopsis","text":"<p>Update the on-disk dependencies to mirror Chart.yaml.</p> <p>This command verifies that the required charts, as expressed in 'Chart.yaml', are present in 'charts/' and are at an acceptable version. It will pull down the latest charts that satisfy the dependencies, and clean up old dependencies.</p> <p>On successful update, this will generate a lock file that can be used to rebuild the dependencies to an exact version.</p> <p>Dependencies are not required to be represented in 'Chart.yaml'. For that reason, an update command will not remove charts unless they are (a) present in the Chart.yaml file, but (b) at the wrong version.</p> <pre><code>helm dependency update CHART [flags]\n</code></pre>"},{"location":"helm/helm_dependency_update/#options","title":"Options","text":"<pre><code>      --ca-file string             verify certificates of HTTPS-enabled servers using this CA bundle\n      --cert-file string           identify HTTPS client using this SSL certificate file\n  -h, --help                       help for update\n      --insecure-skip-tls-verify   skip tls certificate checks for the chart download\n      --key-file string            identify HTTPS client using this SSL key file\n      --keyring string             keyring containing public keys (default \"~/.gnupg/pubring.gpg\")\n      --password string            chart repository password where to locate the requested chart\n      --plain-http                 use insecure HTTP connections for the chart download\n      --skip-refresh               do not refresh the local repository cache\n      --username string            chart repository username where to locate the requested chart\n      --verify                     verify the packages against signatures\n</code></pre>"},{"location":"helm/helm_dependency_update/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_dependency_update/#see-also","title":"SEE ALSO","text":"<ul> <li>helm dependency  - manage a chart's dependencies</li> </ul>"},{"location":"helm/helm_dependency_update/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_env/","title":"Helm Env","text":""},{"location":"helm/helm_env/#helm-env","title":"helm env","text":"<p>helm client environment information</p>"},{"location":"helm/helm_env/#synopsis","title":"Synopsis","text":"<p>Env prints out all the environment information in use by Helm.</p> <pre><code>helm env [flags]\n</code></pre>"},{"location":"helm/helm_env/#options","title":"Options","text":"<pre><code>  -h, --help   help for env\n</code></pre>"},{"location":"helm/helm_env/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_env/#see-also","title":"SEE ALSO","text":"<ul> <li>helm    - The Helm package manager for Kubernetes.</li> </ul>"},{"location":"helm/helm_env/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_get/","title":"Helm Get","text":""},{"location":"helm/helm_get/#helm-get","title":"helm get","text":"<p>download extended information of a named release</p>"},{"location":"helm/helm_get/#synopsis","title":"Synopsis","text":"<p>This command consists of multiple subcommands which can be used to get extended information about the release, including:</p> <ul> <li>The values used to generate the release</li> <li>The generated manifest file</li> <li>The notes provided by the chart of the release</li> <li>The hooks associated with the release</li> <li>The metadata of the release</li> </ul>"},{"location":"helm/helm_get/#options","title":"Options","text":"<pre><code>  -h, --help   help for get\n</code></pre>"},{"location":"helm/helm_get/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_get/#see-also","title":"SEE ALSO","text":"<ul> <li>helm    - The Helm package manager for Kubernetes.</li> <li>helm get all    - download all information for a named release</li> <li>helm get hooks    - download all hooks for a named release</li> <li>helm get manifest  - download the manifest for a named release</li> <li>helm get metadata  - This command fetches metadata for a given release</li> <li>helm get notes    - download the notes for a named release</li> <li>helm get values  - download the values file for a named release</li> </ul>"},{"location":"helm/helm_get/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_get_all/","title":"Helm Get All","text":""},{"location":"helm/helm_get_all/#helm-get-all","title":"helm get all","text":"<p>download all information for a named release</p>"},{"location":"helm/helm_get_all/#synopsis","title":"Synopsis","text":"<p>This command prints a human readable collection of information about the notes, hooks, supplied values, and generated manifest file of the given release.</p> <pre><code>helm get all RELEASE_NAME [flags]\n</code></pre>"},{"location":"helm/helm_get_all/#options","title":"Options","text":"<pre><code>  -h, --help              help for all\n      --revision int      get the named release with revision\n      --template string   go template for formatting the output, eg: {{.Release.Name}}\n</code></pre>"},{"location":"helm/helm_get_all/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_get_all/#see-also","title":"SEE ALSO","text":"<ul> <li>helm get    - download extended information of a named release</li> </ul>"},{"location":"helm/helm_get_all/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_get_hooks/","title":"Helm Get Hooks","text":""},{"location":"helm/helm_get_hooks/#helm-get-hooks","title":"helm get hooks","text":"<p>download all hooks for a named release</p>"},{"location":"helm/helm_get_hooks/#synopsis","title":"Synopsis","text":"<p>This command downloads hooks for a given release.</p> <p>Hooks are formatted in YAML and separated by the YAML '---\\n' separator.</p> <pre><code>helm get hooks RELEASE_NAME [flags]\n</code></pre>"},{"location":"helm/helm_get_hooks/#options","title":"Options","text":"<pre><code>  -h, --help           help for hooks\n      --revision int   get the named release with revision\n</code></pre>"},{"location":"helm/helm_get_hooks/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_get_hooks/#see-also","title":"SEE ALSO","text":"<ul> <li>helm get    - download extended information of a named release</li> </ul>"},{"location":"helm/helm_get_hooks/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_get_manifest/","title":"Helm Get Manifest","text":""},{"location":"helm/helm_get_manifest/#helm-get-manifest","title":"helm get manifest","text":"<p>download the manifest for a named release</p>"},{"location":"helm/helm_get_manifest/#synopsis","title":"Synopsis","text":"<p>This command fetches the generated manifest for a given release.</p> <p>A manifest is a YAML-encoded representation of the Kubernetes resources that were generated from this release's chart(s). If a chart is dependent on other charts, those resources will also be included in the manifest.</p> <pre><code>helm get manifest RELEASE_NAME [flags]\n</code></pre>"},{"location":"helm/helm_get_manifest/#options","title":"Options","text":"<pre><code>  -h, --help           help for manifest\n      --revision int   get the named release with revision\n</code></pre>"},{"location":"helm/helm_get_manifest/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_get_manifest/#see-also","title":"SEE ALSO","text":"<ul> <li>helm get    - download extended information of a named release</li> </ul>"},{"location":"helm/helm_get_manifest/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_get_metadata/","title":"Helm Get Metadata","text":""},{"location":"helm/helm_get_metadata/#helm-get-metadata","title":"helm get metadata","text":"<p>This command fetches metadata for a given release</p> <pre><code>helm get metadata RELEASE_NAME [flags]\n</code></pre>"},{"location":"helm/helm_get_metadata/#options","title":"Options","text":"<pre><code>  -h, --help            help for metadata\n  -o, --output format   prints the output in the specified format. Allowed values: table, json, yaml (default table)\n      --revision int    specify release revision\n</code></pre>"},{"location":"helm/helm_get_metadata/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_get_metadata/#see-also","title":"SEE ALSO","text":"<ul> <li>helm get    - download extended information of a named release</li> </ul>"},{"location":"helm/helm_get_metadata/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_get_notes/","title":"Helm Get Notes","text":""},{"location":"helm/helm_get_notes/#helm-get-notes","title":"helm get notes","text":"<p>download the notes for a named release</p>"},{"location":"helm/helm_get_notes/#synopsis","title":"Synopsis","text":"<p>This command shows notes provided by the chart of a named release.</p> <pre><code>helm get notes RELEASE_NAME [flags]\n</code></pre>"},{"location":"helm/helm_get_notes/#options","title":"Options","text":"<pre><code>  -h, --help           help for notes\n      --revision int   get the named release with revision\n</code></pre>"},{"location":"helm/helm_get_notes/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_get_notes/#see-also","title":"SEE ALSO","text":"<ul> <li>helm get    - download extended information of a named release</li> </ul>"},{"location":"helm/helm_get_notes/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_get_values/","title":"Helm Get Values","text":""},{"location":"helm/helm_get_values/#helm-get-values","title":"helm get values","text":"<p>download the values file for a named release</p>"},{"location":"helm/helm_get_values/#synopsis","title":"Synopsis","text":"<p>This command downloads a values file for a given release.</p> <pre><code>helm get values RELEASE_NAME [flags]\n</code></pre>"},{"location":"helm/helm_get_values/#options","title":"Options","text":"<pre><code>  -a, --all             dump all (computed) values\n  -h, --help            help for values\n  -o, --output format   prints the output in the specified format. Allowed values: table, json, yaml (default table)\n      --revision int    get the named release with revision\n</code></pre>"},{"location":"helm/helm_get_values/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_get_values/#see-also","title":"SEE ALSO","text":"<ul> <li>helm get    - download extended information of a named release</li> </ul>"},{"location":"helm/helm_get_values/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_history/","title":"Helm History","text":""},{"location":"helm/helm_history/#helm-history","title":"helm history","text":"<p>fetch release history</p>"},{"location":"helm/helm_history/#synopsis","title":"Synopsis","text":"<p>History prints historical revisions for a given release.</p> <p>A default maximum of 256 revisions will be returned. Setting '--max' configures the maximum length of the revision list returned.</p> <p>The historical release set is printed as a formatted table, e.g:</p> <pre><code>$ helm history angry-bird\nREVISION    UPDATED                     STATUS          CHART             APP VERSION     DESCRIPTION\n1           Mon Oct 3 10:15:13 2016     superseded      alpine-0.1.0      1.0             Initial install\n2           Mon Oct 3 10:15:13 2016     superseded      alpine-0.1.0      1.0             Upgraded successfully\n3           Mon Oct 3 10:15:13 2016     superseded      alpine-0.1.0      1.0             Rolled back to 2\n4           Mon Oct 3 10:15:13 2016     deployed        alpine-0.1.0      1.0             Upgraded successfully\n</code></pre> <pre><code>helm history RELEASE_NAME [flags]\n</code></pre>"},{"location":"helm/helm_history/#options","title":"Options","text":"<pre><code>  -h, --help            help for history\n      --max int         maximum number of revision to include in history (default 256)\n  -o, --output format   prints the output in the specified format. Allowed values: table, json, yaml (default table)\n</code></pre>"},{"location":"helm/helm_history/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_history/#see-also","title":"SEE ALSO","text":"<ul> <li>helm    - The Helm package manager for Kubernetes.</li> </ul>"},{"location":"helm/helm_history/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_init/","title":"Helm init","text":""},{"location":"helm/helm_init/#helm-init","title":"helm init","text":"<p>This command does not exist in Helm 3, following the removal of Tiller. You no longer need to install Tiller in your cluster in order to use Helm.</p> <p>If you are using Helm 2, go to v2.helm.sh to view the Helm Init documentation.</p>"},{"location":"helm/helm_inspect/","title":"Helm inspect","text":""},{"location":"helm/helm_inspect/#helm-inspect","title":"helm inspect","text":"<p>This command has been renamed. Please refer instead to helm show.</p>"},{"location":"helm/helm_install/","title":"Helm Install","text":""},{"location":"helm/helm_install/#helm-install","title":"helm install","text":"<p>install a chart</p>"},{"location":"helm/helm_install/#synopsis","title":"Synopsis","text":"<p>This command installs a chart archive.</p> <p>The install argument must be a chart reference, a path to a packaged chart, a path to an unpacked chart directory or a URL.</p> <p>To override values in a chart, use either the '--values' flag and pass in a file or use the '--set' flag and pass configuration from the command line, to force a string value use '--set-string'. You can use '--set-file' to set individual values from a file when the value itself is too long for the command line or is dynamically generated. You can also use '--set-json' to set json values (scalars/objects/arrays) from the command line.</p> <pre><code>$ helm install -f myvalues.yaml myredis ./redis\n</code></pre> <p>or</p> <pre><code>$ helm install --set name=prod myredis ./redis\n</code></pre> <p>or</p> <pre><code>$ helm install --set-string long_int=1234567890 myredis ./redis\n</code></pre> <p>or</p> <pre><code>$ helm install --set-file my_script=dothings.sh myredis ./redis\n</code></pre> <p>or</p> <pre><code>$ helm install --set-json 'master.sidecars=[{\"name\":\"sidecar\",\"image\":\"myImage\",\"imagePullPolicy\":\"Always\",\"ports\":[{\"name\":\"portname\",\"containerPort\":1234}]}]' myredis ./redis\n</code></pre> <p>You can specify the '--values'/'-f' flag multiple times. The priority will be given to the last (right-most) file specified. For example, if both myvalues.yaml and override.yaml contained a key called 'Test', the value set in override.yaml would take precedence:</p> <pre><code>$ helm install -f myvalues.yaml -f override.yaml  myredis ./redis\n</code></pre> <p>You can specify the '--set' flag multiple times. The priority will be given to the last (right-most) set specified. For example, if both 'bar' and 'newbar' values are set for a key called 'foo', the 'newbar' value would take precedence:</p> <pre><code>$ helm install --set foo=bar --set foo=newbar  myredis ./redis\n</code></pre> <p>Similarly, in the following example 'foo' is set to '[\"four\"]':</p> <pre><code>$ helm install --set-json='foo=[\"one\", \"two\", \"three\"]' --set-json='foo=[\"four\"]' myredis ./redis\n</code></pre> <p>And in the following example, 'foo' is set to '{\"key1\":\"value1\",\"key2\":\"bar\"}':</p> <pre><code>$ helm install --set-json='foo={\"key1\":\"value1\",\"key2\":\"value2\"}' --set-json='foo.key2=\"bar\"' myredis ./redis\n</code></pre> <p>To check the generated manifests of a release without installing the chart, the --debug and --dry-run flags can be combined.</p> <p>The --dry-run flag will output all generated chart manifests, including Secrets which can contain sensitive values. To hide Kubernetes Secrets use the --hide-secret flag. Please carefully consider how and when these flags are used.</p> <p>If --verify is set, the chart MUST have a provenance file, and the provenance file MUST pass all verification steps.</p> <p>There are six different ways you can express the chart you want to install:</p> <ol> <li>By chart reference: helm install mymaria example/mariadb</li> <li>By path to a packaged chart: helm install mynginx ./nginx-1.2.3.tgz</li> <li>By path to an unpacked chart directory: helm install mynginx ./nginx</li> <li>By absolute URL: helm install mynginx https://example.com/charts/nginx-1.2.3.tgz</li> <li>By chart reference and repo url: helm install --repo https://example.com/charts/ mynginx nginx</li> <li>By OCI registries: helm install mynginx --version 1.2.3 oci://example.com/charts/nginx</li> </ol> <p>CHART REFERENCES</p> <p>A chart reference is a convenient way of referencing a chart in a chart repository.</p> <p>When you use a chart reference with a repo prefix ('example/mariadb'), Helm will look in the local configuration for a chart repository named 'example', and will then look for a chart in that repository whose name is 'mariadb'. It will install the latest stable version of that chart until you specify '--devel' flag to also include development version (alpha, beta, and release candidate releases), or supply a version number with the '--version' flag.</p> <p>To see the list of chart repositories, use 'helm repo list'. To search for charts in a repository, use 'helm search'.</p> <pre><code>helm install [NAME] [CHART] [flags]\n</code></pre>"},{"location":"helm/helm_install/#options","title":"Options","text":"<pre><code>      --atomic                                     if set, the installation process deletes the installation on failure. The --wait flag will be set automatically if --atomic is used\n      --ca-file string                             verify certificates of HTTPS-enabled servers using this CA bundle\n      --cert-file string                           identify HTTPS client using this SSL certificate file\n      --create-namespace                           create the release namespace if not present\n      --dependency-update                          update dependencies if they are missing before installing the chart\n      --description string                         add a custom description\n      --devel                                      use development versions, too. Equivalent to version '&gt;0.0.0-0'. If --version is set, this is ignored\n      --disable-openapi-validation                 if set, the installation process will not validate rendered templates against the Kubernetes OpenAPI Schema\n      --dry-run string[=\"client\"]                  simulate an install. If --dry-run is set with no option being specified or as '--dry-run=client', it will not attempt cluster connections. Setting '--dry-run=server' allows attempting cluster connections.\n      --enable-dns                                 enable DNS lookups when rendering templates\n      --force                                      force resource updates through a replacement strategy\n  -g, --generate-name                              generate the name (and omit the NAME parameter)\n  -h, --help                                       help for install\n      --hide-notes                                 if set, do not show notes in install output. Does not affect presence in chart metadata\n      --hide-secret                                hide Kubernetes Secrets when also using the --dry-run flag\n      --insecure-skip-tls-verify                   skip tls certificate checks for the chart download\n      --key-file string                            identify HTTPS client using this SSL key file\n      --keyring string                             location of public keys used for verification (default \"~/.gnupg/pubring.gpg\")\n  -l, --labels stringToString                      Labels that would be added to release metadata. Should be divided by comma. (default [])\n      --name-template string                       specify template used to name the release\n      --no-hooks                                   prevent hooks from running during install\n  -o, --output format                              prints the output in the specified format. Allowed values: table, json, yaml (default table)\n      --pass-credentials                           pass credentials to all domains\n      --password string                            chart repository password where to locate the requested chart\n      --plain-http                                 use insecure HTTP connections for the chart download\n      --post-renderer postRendererString           the path to an executable to be used for post rendering. If it exists in $PATH, the binary will be used, otherwise it will try to look for the executable at the given path\n      --post-renderer-args postRendererArgsSlice   an argument to the post-renderer (can specify multiple) (default [])\n      --render-subchart-notes                      if set, render subchart notes along with the parent\n      --replace                                    re-use the given name, only if that name is a deleted release which remains in the history. This is unsafe in production\n      --repo string                                chart repository url where to locate the requested chart\n      --set stringArray                            set values on the command line (can specify multiple or separate values with commas: key1=val1,key2=val2)\n      --set-file stringArray                       set values from respective files specified via the command line (can specify multiple or separate values with commas: key1=path1,key2=path2)\n      --set-json stringArray                       set JSON values on the command line (can specify multiple or separate values with commas: key1=jsonval1,key2=jsonval2)\n      --set-literal stringArray                    set a literal STRING value on the command line\n      --set-string stringArray                     set STRING values on the command line (can specify multiple or separate values with commas: key1=val1,key2=val2)\n      --skip-crds                                  if set, no CRDs will be installed. By default, CRDs are installed if not already present\n      --skip-schema-validation                     if set, disables JSON schema validation\n      --take-ownership                             if set, install will ignore the check for helm annotations and take ownership of the existing resources\n      --timeout duration                           time to wait for any individual Kubernetes operation (like Jobs for hooks) (default 5m0s)\n      --username string                            chart repository username where to locate the requested chart\n  -f, --values strings                             specify values in a YAML file or a URL (can specify multiple)\n      --verify                                     verify the package before using it\n      --version string                             specify a version constraint for the chart version to use. This constraint can be a specific tag (e.g. 1.1.1) or it may reference a valid range (e.g. ^2.0.0). If this is not specified, the latest version is used\n      --wait                                       if set, will wait until all Pods, PVCs, Services, and minimum number of Pods of a Deployment, StatefulSet, or ReplicaSet are in a ready state before marking the release as successful. It will wait for as long as --timeout\n      --wait-for-jobs                              if set and --wait enabled, will wait until all Jobs have been completed before marking the release as successful. It will wait for as long as --timeout\n</code></pre>"},{"location":"helm/helm_install/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_install/#see-also","title":"SEE ALSO","text":"<ul> <li>helm    - The Helm package manager for Kubernetes.</li> </ul>"},{"location":"helm/helm_install/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_lint/","title":"Helm Lint","text":""},{"location":"helm/helm_lint/#helm-lint","title":"helm lint","text":"<p>examine a chart for possible issues</p>"},{"location":"helm/helm_lint/#synopsis","title":"Synopsis","text":"<p>This command takes a path to a chart and runs a series of tests to verify that the chart is well-formed.</p> <p>If the linter encounters things that will cause the chart to fail installation, it will emit [ERROR] messages. If it encounters issues that break with convention or recommendation, it will emit [WARNING] messages.</p> <pre><code>helm lint PATH [flags]\n</code></pre>"},{"location":"helm/helm_lint/#options","title":"Options","text":"<pre><code>  -h, --help                      help for lint\n      --kube-version string       Kubernetes version used for capabilities and deprecation checks\n      --quiet                     print only warnings and errors\n      --set stringArray           set values on the command line (can specify multiple or separate values with commas: key1=val1,key2=val2)\n      --set-file stringArray      set values from respective files specified via the command line (can specify multiple or separate values with commas: key1=path1,key2=path2)\n      --set-json stringArray      set JSON values on the command line (can specify multiple or separate values with commas: key1=jsonval1,key2=jsonval2)\n      --set-literal stringArray   set a literal STRING value on the command line\n      --set-string stringArray    set STRING values on the command line (can specify multiple or separate values with commas: key1=val1,key2=val2)\n      --skip-schema-validation    if set, disables JSON schema validation\n      --strict                    fail on lint warnings\n  -f, --values strings            specify values in a YAML file or a URL (can specify multiple)\n      --with-subcharts            lint dependent charts\n</code></pre>"},{"location":"helm/helm_lint/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_lint/#see-also","title":"SEE ALSO","text":"<ul> <li>helm    - The Helm package manager for Kubernetes.</li> </ul>"},{"location":"helm/helm_lint/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_list/","title":"Helm List","text":""},{"location":"helm/helm_list/#helm-list","title":"helm list","text":"<p>list releases</p>"},{"location":"helm/helm_list/#synopsis","title":"Synopsis","text":"<p>This command lists all of the releases for a specified namespace (uses current namespace context if namespace not specified).</p> <p>By default, it lists only releases that are deployed or failed. Flags like '--uninstalled' and '--all' will alter this behavior. Such flags can be combined: '--uninstalled --failed'.</p> <p>By default, items are sorted alphabetically. Use the '-d' flag to sort by release date.</p> <p>If the --filter flag is provided, it will be treated as a filter. Filters are regular expressions (Perl compatible) that are applied to the list of releases. Only items that match the filter will be returned.</p> <pre><code>$ helm list --filter 'ara[a-z]+'\nNAME                UPDATED                                  CHART\nmaudlin-arachnid    2020-06-18 14:17:46.125134977 +0000 UTC  alpine-0.1.0\n</code></pre> <p>If no results are found, 'helm list' will exit 0, but with no output (or in the case of no '-q' flag, only headers).</p> <p>By default, up to 256 items may be returned. To limit this, use the '--max' flag. Setting '--max' to 0 will not return all results. Rather, it will return the server's default, which may be much higher than 256. Pairing the '--max' flag with the '--offset' flag allows you to page through results.</p> <pre><code>helm list [flags]\n</code></pre>"},{"location":"helm/helm_list/#options","title":"Options","text":"<pre><code>  -a, --all                  show all releases without any filter applied\n  -A, --all-namespaces       list releases across all namespaces\n  -d, --date                 sort by release date\n      --deployed             show deployed releases. If no other is specified, this will be automatically enabled\n      --failed               show failed releases\n  -f, --filter string        a regular expression (Perl compatible). Any releases that match the expression will be included in the results\n  -h, --help                 help for list\n  -m, --max int              maximum number of releases to fetch (default 256)\n      --no-headers           don't print headers when using the default output format\n      --offset int           next release index in the list, used to offset from start value\n  -o, --output format        prints the output in the specified format. Allowed values: table, json, yaml (default table)\n      --pending              show pending releases\n  -r, --reverse              reverse the sort order\n  -l, --selector string      Selector (label query) to filter on, supports '=', '==', and '!='.(e.g. -l key1=value1,key2=value2). Works only for secret(default) and configmap storage backends.\n  -q, --short                output short (quiet) listing format\n      --superseded           show superseded releases\n      --time-format string   format time using golang time formatter. Example: --time-format \"2006-01-02 15:04:05Z0700\"\n      --uninstalled          show uninstalled releases (if 'helm uninstall --keep-history' was used)\n      --uninstalling         show releases that are currently being uninstalled\n</code></pre>"},{"location":"helm/helm_list/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_list/#see-also","title":"SEE ALSO","text":"<ul> <li>helm    - The Helm package manager for Kubernetes.</li> </ul>"},{"location":"helm/helm_list/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_package/","title":"Helm Package","text":""},{"location":"helm/helm_package/#helm-package","title":"helm package","text":"<p>package a chart directory into a chart archive</p>"},{"location":"helm/helm_package/#synopsis","title":"Synopsis","text":"<p>This command packages a chart into a versioned chart archive file. If a path is given, this will look at that path for a chart (which must contain a Chart.yaml file) and then package that directory.</p> <p>Versioned chart archives are used by Helm package repositories.</p> <p>To sign a chart, use the '--sign' flag. In most cases, you should also provide '--keyring path/to/secret/keys' and '--key keyname'.</p> <p>$ helm package --sign ./mychart --key mykey --keyring ~/.gnupg/secring.gpg</p> <p>If '--keyring' is not specified, Helm usually defaults to the public keyring unless your environment is otherwise configured.</p> <pre><code>helm package [CHART_PATH] [...] [flags]\n</code></pre>"},{"location":"helm/helm_package/#options","title":"Options","text":"<pre><code>      --app-version string         set the appVersion on the chart to this version\n      --ca-file string             verify certificates of HTTPS-enabled servers using this CA bundle\n      --cert-file string           identify HTTPS client using this SSL certificate file\n  -u, --dependency-update          update dependencies from \"Chart.yaml\" to dir \"charts/\" before packaging\n  -d, --destination string         location to write the chart. (default \".\")\n  -h, --help                       help for package\n      --insecure-skip-tls-verify   skip tls certificate checks for the chart download\n      --key string                 name of the key to use when signing. Used if --sign is true\n      --key-file string            identify HTTPS client using this SSL key file\n      --keyring string             location of a public keyring (default \"~/.gnupg/pubring.gpg\")\n      --passphrase-file string     location of a file which contains the passphrase for the signing key. Use \"-\" in order to read from stdin.\n      --password string            chart repository password where to locate the requested chart\n      --plain-http                 use insecure HTTP connections for the chart download\n      --sign                       use a PGP private key to sign this package\n      --username string            chart repository username where to locate the requested chart\n      --version string             set the version on the chart to this semver version\n</code></pre>"},{"location":"helm/helm_package/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_package/#see-also","title":"SEE ALSO","text":"<ul> <li>helm    - The Helm package manager for Kubernetes.</li> </ul>"},{"location":"helm/helm_package/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_plugin/","title":"Helm Plugin","text":""},{"location":"helm/helm_plugin/#helm-plugin","title":"helm plugin","text":"<p>install, list, or uninstall Helm plugins</p>"},{"location":"helm/helm_plugin/#synopsis","title":"Synopsis","text":"<p>Manage client-side Helm plugins.</p>"},{"location":"helm/helm_plugin/#options","title":"Options","text":"<pre><code>  -h, --help   help for plugin\n</code></pre>"},{"location":"helm/helm_plugin/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_plugin/#see-also","title":"SEE ALSO","text":"<ul> <li>helm    - The Helm package manager for Kubernetes.</li> <li>helm plugin install  - install a Helm plugin</li> <li>helm plugin list    - list installed Helm plugins</li> <li>helm plugin uninstall  - uninstall one or more Helm plugins</li> <li>helm plugin update    - update one or more Helm plugins</li> </ul>"},{"location":"helm/helm_plugin/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_plugin_install/","title":"Helm Plugin Install","text":""},{"location":"helm/helm_plugin_install/#helm-plugin-install","title":"helm plugin install","text":"<p>install a Helm plugin</p>"},{"location":"helm/helm_plugin_install/#synopsis","title":"Synopsis","text":"<p>This command allows you to install a plugin from a url to a VCS repo or a local path.</p> <pre><code>helm plugin install [options] &lt;path|url&gt; [flags]\n</code></pre>"},{"location":"helm/helm_plugin_install/#options","title":"Options","text":"<pre><code>  -h, --help             help for install\n      --version string   specify a version constraint. If this is not specified, the latest version is installed\n</code></pre>"},{"location":"helm/helm_plugin_install/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_plugin_install/#see-also","title":"SEE ALSO","text":"<ul> <li>helm plugin  - install, list, or uninstall Helm plugins</li> </ul>"},{"location":"helm/helm_plugin_install/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_plugin_list/","title":"Helm Plugin List","text":""},{"location":"helm/helm_plugin_list/#helm-plugin-list","title":"helm plugin list","text":"<p>list installed Helm plugins</p> <pre><code>helm plugin list [flags]\n</code></pre>"},{"location":"helm/helm_plugin_list/#options","title":"Options","text":"<pre><code>  -h, --help   help for list\n</code></pre>"},{"location":"helm/helm_plugin_list/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_plugin_list/#see-also","title":"SEE ALSO","text":"<ul> <li>helm plugin  - install, list, or uninstall Helm plugins</li> </ul>"},{"location":"helm/helm_plugin_list/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_plugin_uninstall/","title":"Helm Plugin Uninstall","text":""},{"location":"helm/helm_plugin_uninstall/#helm-plugin-uninstall","title":"helm plugin uninstall","text":"<p>uninstall one or more Helm plugins</p> <pre><code>helm plugin uninstall &lt;plugin&gt;... [flags]\n</code></pre>"},{"location":"helm/helm_plugin_uninstall/#options","title":"Options","text":"<pre><code>  -h, --help   help for uninstall\n</code></pre>"},{"location":"helm/helm_plugin_uninstall/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_plugin_uninstall/#see-also","title":"SEE ALSO","text":"<ul> <li>helm plugin  - install, list, or uninstall Helm plugins</li> </ul>"},{"location":"helm/helm_plugin_uninstall/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_plugin_update/","title":"Helm Plugin Update","text":""},{"location":"helm/helm_plugin_update/#helm-plugin-update","title":"helm plugin update","text":"<p>update one or more Helm plugins</p> <pre><code>helm plugin update &lt;plugin&gt;... [flags]\n</code></pre>"},{"location":"helm/helm_plugin_update/#options","title":"Options","text":"<pre><code>  -h, --help   help for update\n</code></pre>"},{"location":"helm/helm_plugin_update/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_plugin_update/#see-also","title":"SEE ALSO","text":"<ul> <li>helm plugin  - install, list, or uninstall Helm plugins</li> </ul>"},{"location":"helm/helm_plugin_update/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_pull/","title":"Helm Pull","text":""},{"location":"helm/helm_pull/#helm-pull","title":"helm pull","text":"<p>download a chart from a repository and (optionally) unpack it in local directory</p>"},{"location":"helm/helm_pull/#synopsis","title":"Synopsis","text":"<p>Retrieve a package from a package repository, and download it locally.</p> <p>This is useful for fetching packages to inspect, modify, or repackage. It can also be used to perform cryptographic verification of a chart without installing the chart.</p> <p>There are options for unpacking the chart after download. This will create a directory for the chart and uncompress into that directory.</p> <p>If the --verify flag is specified, the requested chart MUST have a provenance file, and MUST pass the verification process. Failure in any part of this will result in an error, and the chart will not be saved locally.</p> <pre><code>helm pull [chart URL | repo/chartname] [...] [flags]\n</code></pre>"},{"location":"helm/helm_pull/#options","title":"Options","text":"<pre><code>      --ca-file string             verify certificates of HTTPS-enabled servers using this CA bundle\n      --cert-file string           identify HTTPS client using this SSL certificate file\n  -d, --destination string         location to write the chart. If this and untardir are specified, untardir is appended to this (default \".\")\n      --devel                      use development versions, too. Equivalent to version '&gt;0.0.0-0'. If --version is set, this is ignored.\n  -h, --help                       help for pull\n      --insecure-skip-tls-verify   skip tls certificate checks for the chart download\n      --key-file string            identify HTTPS client using this SSL key file\n      --keyring string             location of public keys used for verification (default \"~/.gnupg/pubring.gpg\")\n      --pass-credentials           pass credentials to all domains\n      --password string            chart repository password where to locate the requested chart\n      --plain-http                 use insecure HTTP connections for the chart download\n      --prov                       fetch the provenance file, but don't perform verification\n      --repo string                chart repository url where to locate the requested chart\n      --untar                      if set to true, will untar the chart after downloading it\n      --untardir string            if untar is specified, this flag specifies the name of the directory into which the chart is expanded (default \".\")\n      --username string            chart repository username where to locate the requested chart\n      --verify                     verify the package before using it\n      --version string             specify a version constraint for the chart version to use. This constraint can be a specific tag (e.g. 1.1.1) or it may reference a valid range (e.g. ^2.0.0). If this is not specified, the latest version is used\n</code></pre>"},{"location":"helm/helm_pull/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_pull/#see-also","title":"SEE ALSO","text":"<ul> <li>helm    - The Helm package manager for Kubernetes.</li> </ul>"},{"location":"helm/helm_pull/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_push/","title":"Helm Push","text":""},{"location":"helm/helm_push/#helm-push","title":"helm push","text":"<p>push a chart to remote</p>"},{"location":"helm/helm_push/#synopsis","title":"Synopsis","text":"<p>Upload a chart to a registry.</p> <p>If the chart has an associated provenance file, it will also be uploaded.</p> <pre><code>helm push [chart] [remote] [flags]\n</code></pre>"},{"location":"helm/helm_push/#options","title":"Options","text":"<pre><code>      --ca-file string             verify certificates of HTTPS-enabled servers using this CA bundle\n      --cert-file string           identify registry client using this SSL certificate file\n  -h, --help                       help for push\n      --insecure-skip-tls-verify   skip tls certificate checks for the chart upload\n      --key-file string            identify registry client using this SSL key file\n      --password string            chart repository password where to locate the requested chart\n      --plain-http                 use insecure HTTP connections for the chart upload\n      --username string            chart repository username where to locate the requested chart\n</code></pre>"},{"location":"helm/helm_push/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_push/#see-also","title":"SEE ALSO","text":"<ul> <li>helm    - The Helm package manager for Kubernetes.</li> </ul>"},{"location":"helm/helm_push/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_registry/","title":"Helm Registry","text":""},{"location":"helm/helm_registry/#helm-registry","title":"helm registry","text":"<p>login to or logout from a registry</p>"},{"location":"helm/helm_registry/#synopsis","title":"Synopsis","text":"<p>This command consists of multiple subcommands to interact with registries.</p>"},{"location":"helm/helm_registry/#options","title":"Options","text":"<pre><code>  -h, --help   help for registry\n</code></pre>"},{"location":"helm/helm_registry/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_registry/#see-also","title":"SEE ALSO","text":"<ul> <li>helm    - The Helm package manager for Kubernetes.</li> <li>helm registry login  - login to a registry</li> <li>helm registry logout    - logout from a registry</li> </ul>"},{"location":"helm/helm_registry/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_registry_login/","title":"Helm Registry Login","text":""},{"location":"helm/helm_registry_login/#helm-registry-login","title":"helm registry login","text":"<p>login to a registry</p>"},{"location":"helm/helm_registry_login/#synopsis","title":"Synopsis","text":"<p>Authenticate to a remote registry.</p> <pre><code>helm registry login [host] [flags]\n</code></pre>"},{"location":"helm/helm_registry_login/#options","title":"Options","text":"<pre><code>      --ca-file string     verify certificates of HTTPS-enabled servers using this CA bundle\n      --cert-file string   identify registry client using this SSL certificate file\n  -h, --help               help for login\n      --insecure           allow connections to TLS registry without certs\n      --key-file string    identify registry client using this SSL key file\n  -p, --password string    registry password or identity token\n      --password-stdin     read password or identity token from stdin\n  -u, --username string    registry username\n</code></pre>"},{"location":"helm/helm_registry_login/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_registry_login/#see-also","title":"SEE ALSO","text":"<ul> <li>helm registry  - login to or logout from a registry</li> </ul>"},{"location":"helm/helm_registry_login/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_registry_logout/","title":"Helm Registry Logout","text":""},{"location":"helm/helm_registry_logout/#helm-registry-logout","title":"helm registry logout","text":"<p>logout from a registry</p>"},{"location":"helm/helm_registry_logout/#synopsis","title":"Synopsis","text":"<p>Remove credentials stored for a remote registry.</p> <pre><code>helm registry logout [host] [flags]\n</code></pre>"},{"location":"helm/helm_registry_logout/#options","title":"Options","text":"<pre><code>  -h, --help   help for logout\n</code></pre>"},{"location":"helm/helm_registry_logout/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_registry_logout/#see-also","title":"SEE ALSO","text":"<ul> <li>helm registry  - login to or logout from a registry</li> </ul>"},{"location":"helm/helm_registry_logout/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_repo/","title":"Helm Repo","text":""},{"location":"helm/helm_repo/#helm-repo","title":"helm repo","text":"<p>add, list, remove, update, and index chart repositories</p>"},{"location":"helm/helm_repo/#synopsis","title":"Synopsis","text":"<p>This command consists of multiple subcommands to interact with chart repositories.</p> <p>It can be used to add, remove, list, and index chart repositories.</p>"},{"location":"helm/helm_repo/#options","title":"Options","text":"<pre><code>  -h, --help   help for repo\n</code></pre>"},{"location":"helm/helm_repo/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_repo/#see-also","title":"SEE ALSO","text":"<ul> <li>helm    - The Helm package manager for Kubernetes.</li> <li>helm repo add  - add a chart repository</li> <li>helm repo index  - generate an index file given a directory containing packaged charts</li> <li>helm repo list    - list chart repositories</li> <li>helm repo remove    - remove one or more chart repositories</li> <li>helm repo update    - update information of available charts locally from chart repositories</li> </ul>"},{"location":"helm/helm_repo/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_repo_add/","title":"Helm Repo Add","text":""},{"location":"helm/helm_repo_add/#helm-repo-add","title":"helm repo add","text":"<p>add a chart repository</p> <pre><code>helm repo add [NAME] [URL] [flags]\n</code></pre>"},{"location":"helm/helm_repo_add/#options","title":"Options","text":"<pre><code>      --allow-deprecated-repos     by default, this command will not allow adding official repos that have been permanently deleted. This disables that behavior\n      --ca-file string             verify certificates of HTTPS-enabled servers using this CA bundle\n      --cert-file string           identify HTTPS client using this SSL certificate file\n      --force-update               replace (overwrite) the repo if it already exists\n  -h, --help                       help for add\n      --insecure-skip-tls-verify   skip tls certificate checks for the repository\n      --key-file string            identify HTTPS client using this SSL key file\n      --no-update                  Ignored. Formerly, it would disabled forced updates. It is deprecated by force-update.\n      --pass-credentials           pass credentials to all domains\n      --password string            chart repository password\n      --password-stdin             read chart repository password from stdin\n      --username string            chart repository username\n</code></pre>"},{"location":"helm/helm_repo_add/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_repo_add/#see-also","title":"SEE ALSO","text":"<ul> <li>helm repo  - add, list, remove, update, and index chart repositories</li> </ul>"},{"location":"helm/helm_repo_add/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_repo_index/","title":"Helm Repo Index","text":""},{"location":"helm/helm_repo_index/#helm-repo-index","title":"helm repo index","text":"<p>generate an index file given a directory containing packaged charts</p>"},{"location":"helm/helm_repo_index/#synopsis","title":"Synopsis","text":"<p>Read the current directory, generate an index file based on the charts found and write the result to 'index.yaml' in the current directory.</p> <p>This tool is used for creating an 'index.yaml' file for a chart repository. To set an absolute URL to the charts, use '--url' flag.</p> <p>To merge the generated index with an existing index file, use the '--merge' flag. In this case, the charts found in the current directory will be merged into the index passed in with --merge, with local charts taking priority over existing charts.</p> <pre><code>helm repo index [DIR] [flags]\n</code></pre>"},{"location":"helm/helm_repo_index/#options","title":"Options","text":"<pre><code>  -h, --help           help for index\n      --json           output in JSON format\n      --merge string   merge the generated index into the given index\n      --url string     url of chart repository\n</code></pre>"},{"location":"helm/helm_repo_index/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_repo_index/#see-also","title":"SEE ALSO","text":"<ul> <li>helm repo  - add, list, remove, update, and index chart repositories</li> </ul>"},{"location":"helm/helm_repo_index/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_repo_list/","title":"Helm Repo List","text":""},{"location":"helm/helm_repo_list/#helm-repo-list","title":"helm repo list","text":"<p>list chart repositories</p> <pre><code>helm repo list [flags]\n</code></pre>"},{"location":"helm/helm_repo_list/#options","title":"Options","text":"<pre><code>  -h, --help            help for list\n  -o, --output format   prints the output in the specified format. Allowed values: table, json, yaml (default table)\n</code></pre>"},{"location":"helm/helm_repo_list/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_repo_list/#see-also","title":"SEE ALSO","text":"<ul> <li>helm repo  - add, list, remove, update, and index chart repositories</li> </ul>"},{"location":"helm/helm_repo_list/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_repo_remove/","title":"Helm Repo Remove","text":""},{"location":"helm/helm_repo_remove/#helm-repo-remove","title":"helm repo remove","text":"<p>remove one or more chart repositories</p> <pre><code>helm repo remove [REPO1 [REPO2 ...]] [flags]\n</code></pre>"},{"location":"helm/helm_repo_remove/#options","title":"Options","text":"<pre><code>  -h, --help   help for remove\n</code></pre>"},{"location":"helm/helm_repo_remove/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_repo_remove/#see-also","title":"SEE ALSO","text":"<ul> <li>helm repo  - add, list, remove, update, and index chart repositories</li> </ul>"},{"location":"helm/helm_repo_remove/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_repo_update/","title":"Helm Repo Update","text":""},{"location":"helm/helm_repo_update/#helm-repo-update","title":"helm repo update","text":"<p>update information of available charts locally from chart repositories</p>"},{"location":"helm/helm_repo_update/#synopsis","title":"Synopsis","text":"<p>Update gets the latest information about charts from the respective chart repositories. Information is cached locally, where it is used by commands like 'helm search'.</p> <p>You can optionally specify a list of repositories you want to update.     $ helm repo update  ... To update all the repositories, use 'helm repo update'. <pre><code>helm repo update [REPO1 [REPO2 ...]] [flags]\n</code></pre>"},{"location":"helm/helm_repo_update/#options","title":"Options","text":"<pre><code>      --fail-on-repo-update-fail   update fails if any of the repository updates fail\n  -h, --help                       help for update\n</code></pre>"},{"location":"helm/helm_repo_update/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_repo_update/#see-also","title":"SEE ALSO","text":"<ul> <li>helm repo  - add, list, remove, update, and index chart repositories</li> </ul>"},{"location":"helm/helm_repo_update/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_rollback/","title":"Helm Rollback","text":""},{"location":"helm/helm_rollback/#helm-rollback","title":"helm rollback","text":"<p>roll back a release to a previous revision</p>"},{"location":"helm/helm_rollback/#synopsis","title":"Synopsis","text":"<p>This command rolls back a release to a previous revision.</p> <p>The first argument of the rollback command is the name of a release, and the second is a revision (version) number. If this argument is omitted or set to 0, it will roll back to the previous release.</p> <p>To see revision numbers, run 'helm history RELEASE'.</p> <pre><code>helm rollback &lt;RELEASE&gt; [REVISION] [flags]\n</code></pre>"},{"location":"helm/helm_rollback/#options","title":"Options","text":"<pre><code>      --cleanup-on-fail    allow deletion of new resources created in this rollback when rollback fails\n      --dry-run            simulate a rollback\n      --force              force resource update through delete/recreate if needed\n  -h, --help               help for rollback\n      --history-max int    limit the maximum number of revisions saved per release. Use 0 for no limit (default 10)\n      --no-hooks           prevent hooks from running during rollback\n      --recreate-pods      performs pods restart for the resource if applicable\n      --timeout duration   time to wait for any individual Kubernetes operation (like Jobs for hooks) (default 5m0s)\n      --wait               if set, will wait until all Pods, PVCs, Services, and minimum number of Pods of a Deployment, StatefulSet, or ReplicaSet are in a ready state before marking the release as successful. It will wait for as long as --timeout\n      --wait-for-jobs      if set and --wait enabled, will wait until all Jobs have been completed before marking the release as successful. It will wait for as long as --timeout\n</code></pre>"},{"location":"helm/helm_rollback/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_rollback/#see-also","title":"SEE ALSO","text":"<ul> <li>helm    - The Helm package manager for Kubernetes.</li> </ul>"},{"location":"helm/helm_rollback/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_search/","title":"Helm Search","text":""},{"location":"helm/helm_search/#helm-search","title":"helm search","text":"<p>search for a keyword in charts</p>"},{"location":"helm/helm_search/#synopsis","title":"Synopsis","text":"<p>Search provides the ability to search for Helm charts in the various places they can be stored including the Artifact Hub and repositories you have added. Use search subcommands to search different locations for charts.</p>"},{"location":"helm/helm_search/#options","title":"Options","text":"<pre><code>  -h, --help   help for search\n</code></pre>"},{"location":"helm/helm_search/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_search/#see-also","title":"SEE ALSO","text":"<ul> <li>helm    - The Helm package manager for Kubernetes.</li> <li>helm search hub  - search for charts in the Artifact Hub or your own hub instance</li> <li>helm search repo    - search repositories for a keyword in charts</li> </ul>"},{"location":"helm/helm_search/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_search_hub/","title":"Helm Search Hub","text":""},{"location":"helm/helm_search_hub/#helm-search-hub","title":"helm search hub","text":"<p>search for charts in the Artifact Hub or your own hub instance</p>"},{"location":"helm/helm_search_hub/#synopsis","title":"Synopsis","text":"<p>Search for Helm charts in the Artifact Hub or your own hub instance.</p> <p>Artifact Hub is a web-based application that enables finding, installing, and publishing packages and configurations for CNCF projects, including publicly available distributed charts Helm charts. It is a Cloud Native Computing Foundation sandbox project. You can browse the hub at https://artifacthub.io/</p> <p>The [KEYWORD] argument accepts either a keyword string, or quoted string of rich query options. For rich query options documentation, see https://artifacthub.github.io/hub/api/?urls.primaryName=Monocular%20compatible%20search%20API#/Monocular/get_api_chartsvc_v1_charts_search</p> <p>Previous versions of Helm used an instance of Monocular as the default 'endpoint', so for backwards compatibility Artifact Hub is compatible with the Monocular search API. Similarly, when setting the 'endpoint' flag, the specified endpoint must also be implement a Monocular compatible search API endpoint. Note that when specifying a Monocular instance as the 'endpoint', rich queries are not supported. For API details, see https://github.com/helm/monocular</p> <pre><code>helm search hub [KEYWORD] [flags]\n</code></pre>"},{"location":"helm/helm_search_hub/#options","title":"Options","text":"<pre><code>      --endpoint string      Hub instance to query for charts (default \"https://hub.helm.sh\")\n      --fail-on-no-result    search fails if no results are found\n  -h, --help                 help for hub\n      --list-repo-url        print charts repository URL\n      --max-col-width uint   maximum column width for output table (default 50)\n  -o, --output format        prints the output in the specified format. Allowed values: table, json, yaml (default table)\n</code></pre>"},{"location":"helm/helm_search_hub/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_search_hub/#see-also","title":"SEE ALSO","text":"<ul> <li>helm search  - search for a keyword in charts</li> </ul>"},{"location":"helm/helm_search_hub/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_search_repo/","title":"Helm Search Repo","text":""},{"location":"helm/helm_search_repo/#helm-search-repo","title":"helm search repo","text":"<p>search repositories for a keyword in charts</p>"},{"location":"helm/helm_search_repo/#synopsis","title":"Synopsis","text":"<p>Search reads through all of the repositories configured on the system, and looks for matches. Search of these repositories uses the metadata stored on the system.</p> <p>It will display the latest stable versions of the charts found. If you specify the --devel flag, the output will include pre-release versions. If you want to search using a version constraint, use --version.</p> <p>Examples:</p> <pre><code># Search for stable release versions matching the keyword \"nginx\"\n$ helm search repo nginx\n\n# Search for release versions matching the keyword \"nginx\", including pre-release versions\n$ helm search repo nginx --devel\n\n# Search for the latest stable release for nginx-ingress with a major version of 1\n$ helm search repo nginx-ingress --version ^1.0.0\n</code></pre> <p>Repositories are managed with 'helm repo' commands.</p> <pre><code>helm search repo [keyword] [flags]\n</code></pre>"},{"location":"helm/helm_search_repo/#options","title":"Options","text":"<pre><code>      --devel                use development versions (alpha, beta, and release candidate releases), too. Equivalent to version '&gt;0.0.0-0'. If --version is set, this is ignored\n      --fail-on-no-result    search fails if no results are found\n  -h, --help                 help for repo\n      --max-col-width uint   maximum column width for output table (default 50)\n  -o, --output format        prints the output in the specified format. Allowed values: table, json, yaml (default table)\n  -r, --regexp               use regular expressions for searching repositories you have added\n      --version string       search using semantic versioning constraints on repositories you have added\n  -l, --versions             show the long listing, with each version of each chart on its own line, for repositories you have added\n</code></pre>"},{"location":"helm/helm_search_repo/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_search_repo/#see-also","title":"SEE ALSO","text":"<ul> <li>helm search  - search for a keyword in charts</li> </ul>"},{"location":"helm/helm_search_repo/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_show/","title":"Helm Show","text":""},{"location":"helm/helm_show/#helm-show","title":"helm show","text":"<p>show information of a chart</p>"},{"location":"helm/helm_show/#synopsis","title":"Synopsis","text":"<p>This command consists of multiple subcommands to display information about a chart</p>"},{"location":"helm/helm_show/#options","title":"Options","text":"<pre><code>  -h, --help   help for show\n</code></pre>"},{"location":"helm/helm_show/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_show/#see-also","title":"SEE ALSO","text":"<ul> <li>helm    - The Helm package manager for Kubernetes.</li> <li>helm show all  - show all information of the chart</li> <li>helm show chart  - show the chart's definition</li> <li>helm show crds    - show the chart's CRDs</li> <li>helm show readme    - show the chart's README</li> <li>helm show values    - show the chart's values</li> </ul>"},{"location":"helm/helm_show/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_show_all/","title":"Helm Show All","text":""},{"location":"helm/helm_show_all/#helm-show-all","title":"helm show all","text":"<p>show all information of the chart</p>"},{"location":"helm/helm_show_all/#synopsis","title":"Synopsis","text":"<p>This command inspects a chart (directory, file, or URL) and displays all its content (values.yaml, Chart.yaml, README)</p> <pre><code>helm show all [CHART] [flags]\n</code></pre>"},{"location":"helm/helm_show_all/#options","title":"Options","text":"<pre><code>      --ca-file string             verify certificates of HTTPS-enabled servers using this CA bundle\n      --cert-file string           identify HTTPS client using this SSL certificate file\n      --devel                      use development versions, too. Equivalent to version '&gt;0.0.0-0'. If --version is set, this is ignored\n  -h, --help                       help for all\n      --insecure-skip-tls-verify   skip tls certificate checks for the chart download\n      --key-file string            identify HTTPS client using this SSL key file\n      --keyring string             location of public keys used for verification (default \"~/.gnupg/pubring.gpg\")\n      --pass-credentials           pass credentials to all domains\n      --password string            chart repository password where to locate the requested chart\n      --plain-http                 use insecure HTTP connections for the chart download\n      --repo string                chart repository url where to locate the requested chart\n      --username string            chart repository username where to locate the requested chart\n      --verify                     verify the package before using it\n      --version string             specify a version constraint for the chart version to use. This constraint can be a specific tag (e.g. 1.1.1) or it may reference a valid range (e.g. ^2.0.0). If this is not specified, the latest version is used\n</code></pre>"},{"location":"helm/helm_show_all/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_show_all/#see-also","title":"SEE ALSO","text":"<ul> <li>helm show  - show information of a chart</li> </ul>"},{"location":"helm/helm_show_all/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_show_chart/","title":"Helm Show Chart","text":""},{"location":"helm/helm_show_chart/#helm-show-chart","title":"helm show chart","text":"<p>show the chart's definition</p>"},{"location":"helm/helm_show_chart/#synopsis","title":"Synopsis","text":"<p>This command inspects a chart (directory, file, or URL) and displays the contents of the Chart.yaml file</p> <pre><code>helm show chart [CHART] [flags]\n</code></pre>"},{"location":"helm/helm_show_chart/#options","title":"Options","text":"<pre><code>      --ca-file string             verify certificates of HTTPS-enabled servers using this CA bundle\n      --cert-file string           identify HTTPS client using this SSL certificate file\n      --devel                      use development versions, too. Equivalent to version '&gt;0.0.0-0'. If --version is set, this is ignored\n  -h, --help                       help for chart\n      --insecure-skip-tls-verify   skip tls certificate checks for the chart download\n      --key-file string            identify HTTPS client using this SSL key file\n      --keyring string             location of public keys used for verification (default \"~/.gnupg/pubring.gpg\")\n      --pass-credentials           pass credentials to all domains\n      --password string            chart repository password where to locate the requested chart\n      --plain-http                 use insecure HTTP connections for the chart download\n      --repo string                chart repository url where to locate the requested chart\n      --username string            chart repository username where to locate the requested chart\n      --verify                     verify the package before using it\n      --version string             specify a version constraint for the chart version to use. This constraint can be a specific tag (e.g. 1.1.1) or it may reference a valid range (e.g. ^2.0.0). If this is not specified, the latest version is used\n</code></pre>"},{"location":"helm/helm_show_chart/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_show_chart/#see-also","title":"SEE ALSO","text":"<ul> <li>helm show  - show information of a chart</li> </ul>"},{"location":"helm/helm_show_chart/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_show_crds/","title":"Helm Show Crds","text":""},{"location":"helm/helm_show_crds/#helm-show-crds","title":"helm show crds","text":"<p>show the chart's CRDs</p>"},{"location":"helm/helm_show_crds/#synopsis","title":"Synopsis","text":"<p>This command inspects a chart (directory, file, or URL) and displays the contents of the CustomResourceDefinition files</p> <pre><code>helm show crds [CHART] [flags]\n</code></pre>"},{"location":"helm/helm_show_crds/#options","title":"Options","text":"<pre><code>      --ca-file string             verify certificates of HTTPS-enabled servers using this CA bundle\n      --cert-file string           identify HTTPS client using this SSL certificate file\n      --devel                      use development versions, too. Equivalent to version '&gt;0.0.0-0'. If --version is set, this is ignored\n  -h, --help                       help for crds\n      --insecure-skip-tls-verify   skip tls certificate checks for the chart download\n      --key-file string            identify HTTPS client using this SSL key file\n      --keyring string             location of public keys used for verification (default \"~/.gnupg/pubring.gpg\")\n      --pass-credentials           pass credentials to all domains\n      --password string            chart repository password where to locate the requested chart\n      --plain-http                 use insecure HTTP connections for the chart download\n      --repo string                chart repository url where to locate the requested chart\n      --username string            chart repository username where to locate the requested chart\n      --verify                     verify the package before using it\n      --version string             specify a version constraint for the chart version to use. This constraint can be a specific tag (e.g. 1.1.1) or it may reference a valid range (e.g. ^2.0.0). If this is not specified, the latest version is used\n</code></pre>"},{"location":"helm/helm_show_crds/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_show_crds/#see-also","title":"SEE ALSO","text":"<ul> <li>helm show  - show information of a chart</li> </ul>"},{"location":"helm/helm_show_crds/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_show_readme/","title":"Helm Show Readme","text":""},{"location":"helm/helm_show_readme/#helm-show-readme","title":"helm show readme","text":"<p>show the chart's README</p>"},{"location":"helm/helm_show_readme/#synopsis","title":"Synopsis","text":"<p>This command inspects a chart (directory, file, or URL) and displays the contents of the README file</p> <pre><code>helm show readme [CHART] [flags]\n</code></pre>"},{"location":"helm/helm_show_readme/#options","title":"Options","text":"<pre><code>      --ca-file string             verify certificates of HTTPS-enabled servers using this CA bundle\n      --cert-file string           identify HTTPS client using this SSL certificate file\n      --devel                      use development versions, too. Equivalent to version '&gt;0.0.0-0'. If --version is set, this is ignored\n  -h, --help                       help for readme\n      --insecure-skip-tls-verify   skip tls certificate checks for the chart download\n      --key-file string            identify HTTPS client using this SSL key file\n      --keyring string             location of public keys used for verification (default \"~/.gnupg/pubring.gpg\")\n      --pass-credentials           pass credentials to all domains\n      --password string            chart repository password where to locate the requested chart\n      --plain-http                 use insecure HTTP connections for the chart download\n      --repo string                chart repository url where to locate the requested chart\n      --username string            chart repository username where to locate the requested chart\n      --verify                     verify the package before using it\n      --version string             specify a version constraint for the chart version to use. This constraint can be a specific tag (e.g. 1.1.1) or it may reference a valid range (e.g. ^2.0.0). If this is not specified, the latest version is used\n</code></pre>"},{"location":"helm/helm_show_readme/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_show_readme/#see-also","title":"SEE ALSO","text":"<ul> <li>helm show  - show information of a chart</li> </ul>"},{"location":"helm/helm_show_readme/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_show_values/","title":"Helm Show Values","text":""},{"location":"helm/helm_show_values/#helm-show-values","title":"helm show values","text":"<p>show the chart's values</p>"},{"location":"helm/helm_show_values/#synopsis","title":"Synopsis","text":"<p>This command inspects a chart (directory, file, or URL) and displays the contents of the values.yaml file</p> <pre><code>helm show values [CHART] [flags]\n</code></pre>"},{"location":"helm/helm_show_values/#options","title":"Options","text":"<pre><code>      --ca-file string             verify certificates of HTTPS-enabled servers using this CA bundle\n      --cert-file string           identify HTTPS client using this SSL certificate file\n      --devel                      use development versions, too. Equivalent to version '&gt;0.0.0-0'. If --version is set, this is ignored\n  -h, --help                       help for values\n      --insecure-skip-tls-verify   skip tls certificate checks for the chart download\n      --jsonpath string            supply a JSONPath expression to filter the output\n      --key-file string            identify HTTPS client using this SSL key file\n      --keyring string             location of public keys used for verification (default \"~/.gnupg/pubring.gpg\")\n      --pass-credentials           pass credentials to all domains\n      --password string            chart repository password where to locate the requested chart\n      --plain-http                 use insecure HTTP connections for the chart download\n      --repo string                chart repository url where to locate the requested chart\n      --username string            chart repository username where to locate the requested chart\n      --verify                     verify the package before using it\n      --version string             specify a version constraint for the chart version to use. This constraint can be a specific tag (e.g. 1.1.1) or it may reference a valid range (e.g. ^2.0.0). If this is not specified, the latest version is used\n</code></pre>"},{"location":"helm/helm_show_values/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_show_values/#see-also","title":"SEE ALSO","text":"<ul> <li>helm show  - show information of a chart</li> </ul>"},{"location":"helm/helm_show_values/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_status/","title":"Helm Status","text":""},{"location":"helm/helm_status/#helm-status","title":"helm status","text":"<p>display the status of the named release</p>"},{"location":"helm/helm_status/#synopsis","title":"Synopsis","text":"<p>This command shows the status of a named release. The status consists of: - last deployment time - k8s namespace in which the release lives - state of the release (can be: unknown, deployed, uninstalled, superseded, failed, uninstalling, pending-install, pending-upgrade or pending-rollback) - revision of the release - description of the release (can be completion message or error message, need to enable --show-desc) - list of resources that this release consists of (need to enable --show-resources) - details on last test suite run, if applicable - additional notes provided by the chart</p> <pre><code>helm status RELEASE_NAME [flags]\n</code></pre>"},{"location":"helm/helm_status/#options","title":"Options","text":"<pre><code>  -h, --help             help for status\n  -o, --output format    prints the output in the specified format. Allowed values: table, json, yaml (default table)\n      --revision int     if set, display the status of the named release with revision\n      --show-desc        if set, display the description message of the named release\n      --show-resources   if set, display the resources of the named release\n</code></pre>"},{"location":"helm/helm_status/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_status/#see-also","title":"SEE ALSO","text":"<ul> <li>helm    - The Helm package manager for Kubernetes.</li> </ul>"},{"location":"helm/helm_status/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_template/","title":"Helm Template","text":""},{"location":"helm/helm_template/#helm-template","title":"helm template","text":"<p>locally render templates</p>"},{"location":"helm/helm_template/#synopsis","title":"Synopsis","text":"<p>Render chart templates locally and display the output.</p> <p>Any values that would normally be looked up or retrieved in-cluster will be faked locally. Additionally, none of the server-side testing of chart validity (e.g. whether an API is supported) is done.</p> <pre><code>helm template [NAME] [CHART] [flags]\n</code></pre>"},{"location":"helm/helm_template/#options","title":"Options","text":"<pre><code>  -a, --api-versions strings                       Kubernetes api versions used for Capabilities.APIVersions\n      --atomic                                     if set, the installation process deletes the installation on failure. The --wait flag will be set automatically if --atomic is used\n      --ca-file string                             verify certificates of HTTPS-enabled servers using this CA bundle\n      --cert-file string                           identify HTTPS client using this SSL certificate file\n      --create-namespace                           create the release namespace if not present\n      --dependency-update                          update dependencies if they are missing before installing the chart\n      --description string                         add a custom description\n      --devel                                      use development versions, too. Equivalent to version '&gt;0.0.0-0'. If --version is set, this is ignored\n      --disable-openapi-validation                 if set, the installation process will not validate rendered templates against the Kubernetes OpenAPI Schema\n      --dry-run string[=\"client\"]                  simulate an install. If --dry-run is set with no option being specified or as '--dry-run=client', it will not attempt cluster connections. Setting '--dry-run=server' allows attempting cluster connections.\n      --enable-dns                                 enable DNS lookups when rendering templates\n      --force                                      force resource updates through a replacement strategy\n  -g, --generate-name                              generate the name (and omit the NAME parameter)\n  -h, --help                                       help for template\n      --hide-notes                                 if set, do not show notes in install output. Does not affect presence in chart metadata\n      --include-crds                               include CRDs in the templated output\n      --insecure-skip-tls-verify                   skip tls certificate checks for the chart download\n      --is-upgrade                                 set .Release.IsUpgrade instead of .Release.IsInstall\n      --key-file string                            identify HTTPS client using this SSL key file\n      --keyring string                             location of public keys used for verification (default \"~/.gnupg/pubring.gpg\")\n      --kube-version string                        Kubernetes version used for Capabilities.KubeVersion\n  -l, --labels stringToString                      Labels that would be added to release metadata. Should be divided by comma. (default [])\n      --name-template string                       specify template used to name the release\n      --no-hooks                                   prevent hooks from running during install\n      --output-dir string                          writes the executed templates to files in output-dir instead of stdout\n      --pass-credentials                           pass credentials to all domains\n      --password string                            chart repository password where to locate the requested chart\n      --plain-http                                 use insecure HTTP connections for the chart download\n      --post-renderer postRendererString           the path to an executable to be used for post rendering. If it exists in $PATH, the binary will be used, otherwise it will try to look for the executable at the given path\n      --post-renderer-args postRendererArgsSlice   an argument to the post-renderer (can specify multiple) (default [])\n      --release-name                               use release name in the output-dir path.\n      --render-subchart-notes                      if set, render subchart notes along with the parent\n      --replace                                    re-use the given name, only if that name is a deleted release which remains in the history. This is unsafe in production\n      --repo string                                chart repository url where to locate the requested chart\n      --set stringArray                            set values on the command line (can specify multiple or separate values with commas: key1=val1,key2=val2)\n      --set-file stringArray                       set values from respective files specified via the command line (can specify multiple or separate values with commas: key1=path1,key2=path2)\n      --set-json stringArray                       set JSON values on the command line (can specify multiple or separate values with commas: key1=jsonval1,key2=jsonval2)\n      --set-literal stringArray                    set a literal STRING value on the command line\n      --set-string stringArray                     set STRING values on the command line (can specify multiple or separate values with commas: key1=val1,key2=val2)\n  -s, --show-only stringArray                      only show manifests rendered from the given templates\n      --skip-crds                                  if set, no CRDs will be installed. By default, CRDs are installed if not already present\n      --skip-schema-validation                     if set, disables JSON schema validation\n      --skip-tests                                 skip tests from templated output\n      --take-ownership                             if set, install will ignore the check for helm annotations and take ownership of the existing resources\n      --timeout duration                           time to wait for any individual Kubernetes operation (like Jobs for hooks) (default 5m0s)\n      --username string                            chart repository username where to locate the requested chart\n      --validate                                   validate your manifests against the Kubernetes cluster you are currently pointing at. This is the same validation performed on an install\n  -f, --values strings                             specify values in a YAML file or a URL (can specify multiple)\n      --verify                                     verify the package before using it\n      --version string                             specify a version constraint for the chart version to use. This constraint can be a specific tag (e.g. 1.1.1) or it may reference a valid range (e.g. ^2.0.0). If this is not specified, the latest version is used\n      --wait                                       if set, will wait until all Pods, PVCs, Services, and minimum number of Pods of a Deployment, StatefulSet, or ReplicaSet are in a ready state before marking the release as successful. It will wait for as long as --timeout\n      --wait-for-jobs                              if set and --wait enabled, will wait until all Jobs have been completed before marking the release as successful. It will wait for as long as --timeout\n</code></pre>"},{"location":"helm/helm_template/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_template/#see-also","title":"SEE ALSO","text":"<ul> <li>helm    - The Helm package manager for Kubernetes.</li> </ul>"},{"location":"helm/helm_template/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_test/","title":"Helm Test","text":""},{"location":"helm/helm_test/#helm-test","title":"helm test","text":"<p>run tests for a release</p>"},{"location":"helm/helm_test/#synopsis","title":"Synopsis","text":"<p>The test command runs the tests for a release.</p> <p>The argument this command takes is the name of a deployed release. The tests to be run are defined in the chart that was installed.</p> <pre><code>helm test [RELEASE] [flags]\n</code></pre>"},{"location":"helm/helm_test/#options","title":"Options","text":"<pre><code>      --filter strings     specify tests by attribute (currently \"name\") using attribute=value syntax or '!attribute=value' to exclude a test (can specify multiple or separate values with commas: name=test1,name=test2)\n  -h, --help               help for test\n      --hide-notes         if set, do not show notes in test output. Does not affect presence in chart metadata\n      --logs               dump the logs from test pods (this runs after all tests are complete, but before any cleanup)\n      --timeout duration   time to wait for any individual Kubernetes operation (like Jobs for hooks) (default 5m0s)\n</code></pre>"},{"location":"helm/helm_test/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_test/#see-also","title":"SEE ALSO","text":"<ul> <li>helm    - The Helm package manager for Kubernetes.</li> </ul>"},{"location":"helm/helm_test/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_uninstall/","title":"Helm Uninstall","text":""},{"location":"helm/helm_uninstall/#helm-uninstall","title":"helm uninstall","text":"<p>uninstall a release</p>"},{"location":"helm/helm_uninstall/#synopsis","title":"Synopsis","text":"<p>This command takes a release name and uninstalls the release.</p> <p>It removes all of the resources associated with the last release of the chart as well as the release history, freeing it up for future use.</p> <p>Use the '--dry-run' flag to see which releases will be uninstalled without actually uninstalling them.</p> <pre><code>helm uninstall RELEASE_NAME [...] [flags]\n</code></pre>"},{"location":"helm/helm_uninstall/#options","title":"Options","text":"<pre><code>      --cascade string       Must be \"background\", \"orphan\", or \"foreground\". Selects the deletion cascading strategy for the dependents. Defaults to background. (default \"background\")\n      --description string   add a custom description\n      --dry-run              simulate a uninstall\n  -h, --help                 help for uninstall\n      --ignore-not-found     Treat \"release not found\" as a successful uninstall\n      --keep-history         remove all associated resources and mark the release as deleted, but retain the release history\n      --no-hooks             prevent hooks from running during uninstallation\n      --timeout duration     time to wait for any individual Kubernetes operation (like Jobs for hooks) (default 5m0s)\n      --wait                 if set, will wait until all the resources are deleted before returning. It will wait for as long as --timeout\n</code></pre>"},{"location":"helm/helm_uninstall/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_uninstall/#see-also","title":"SEE ALSO","text":"<ul> <li>helm    - The Helm package manager for Kubernetes.</li> </ul>"},{"location":"helm/helm_uninstall/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_upgrade/","title":"Helm Upgrade","text":""},{"location":"helm/helm_upgrade/#helm-upgrade","title":"helm upgrade","text":"<p>upgrade a release</p>"},{"location":"helm/helm_upgrade/#synopsis","title":"Synopsis","text":"<p>This command upgrades a release to a new version of a chart.</p> <p>The upgrade arguments must be a release and chart. The chart argument can be either: a chart reference('example/mariadb'), a path to a chart directory, a packaged chart, or a fully qualified URL. For chart references, the latest version will be specified unless the '--version' flag is set.</p> <p>To override values in a chart, use either the '--values' flag and pass in a file or use the '--set' flag and pass configuration from the command line, to force string values, use '--set-string'. You can use '--set-file' to set individual values from a file when the value itself is too long for the command line or is dynamically generated. You can also use '--set-json' to set json values (scalars/objects/arrays) from the command line.</p> <p>You can specify the '--values'/'-f' flag multiple times. The priority will be given to the last (right-most) file specified. For example, if both myvalues.yaml and override.yaml contained a key called 'Test', the value set in override.yaml would take precedence:</p> <pre><code>$ helm upgrade -f myvalues.yaml -f override.yaml redis ./redis\n</code></pre> <p>You can specify the '--set' flag multiple times. The priority will be given to the last (right-most) set specified. For example, if both 'bar' and 'newbar' values are set for a key called 'foo', the 'newbar' value would take precedence:</p> <pre><code>$ helm upgrade --set foo=bar --set foo=newbar redis ./redis\n</code></pre> <p>You can update the values for an existing release with this command as well via the '--reuse-values' flag. The 'RELEASE' and 'CHART' arguments should be set to the original parameters, and existing values will be merged with any values set via '--values'/'-f' or '--set' flags. Priority is given to new values.</p> <pre><code>$ helm upgrade --reuse-values --set foo=bar --set foo=newbar redis ./redis\n</code></pre> <p>The --dry-run flag will output all generated chart manifests, including Secrets which can contain sensitive values. To hide Kubernetes Secrets use the --hide-secret flag. Please carefully consider how and when these flags are used.</p> <pre><code>helm upgrade [RELEASE] [CHART] [flags]\n</code></pre>"},{"location":"helm/helm_upgrade/#options","title":"Options","text":"<pre><code>      --atomic                                     if set, upgrade process rolls back changes made in case of failed upgrade. The --wait flag will be set automatically if --atomic is used\n      --ca-file string                             verify certificates of HTTPS-enabled servers using this CA bundle\n      --cert-file string                           identify HTTPS client using this SSL certificate file\n      --cleanup-on-fail                            allow deletion of new resources created in this upgrade when upgrade fails\n      --create-namespace                           if --install is set, create the release namespace if not present\n      --dependency-update                          update dependencies if they are missing before installing the chart\n      --description string                         add a custom description\n      --devel                                      use development versions, too. Equivalent to version '&gt;0.0.0-0'. If --version is set, this is ignored\n      --disable-openapi-validation                 if set, the upgrade process will not validate rendered templates against the Kubernetes OpenAPI Schema\n      --dry-run string[=\"client\"]                  simulate an install. If --dry-run is set with no option being specified or as '--dry-run=client', it will not attempt cluster connections. Setting '--dry-run=server' allows attempting cluster connections.\n      --enable-dns                                 enable DNS lookups when rendering templates\n      --force                                      force resource updates through a replacement strategy\n  -h, --help                                       help for upgrade\n      --hide-notes                                 if set, do not show notes in upgrade output. Does not affect presence in chart metadata\n      --hide-secret                                hide Kubernetes Secrets when also using the --dry-run flag\n      --history-max int                            limit the maximum number of revisions saved per release. Use 0 for no limit (default 10)\n      --insecure-skip-tls-verify                   skip tls certificate checks for the chart download\n  -i, --install                                    if a release by this name doesn't already exist, run an install\n      --key-file string                            identify HTTPS client using this SSL key file\n      --keyring string                             location of public keys used for verification (default \"~/.gnupg/pubring.gpg\")\n  -l, --labels stringToString                      Labels that would be added to release metadata. Should be separated by comma. Original release labels will be merged with upgrade labels. You can unset label using null. (default [])\n      --no-hooks                                   disable pre/post upgrade hooks\n  -o, --output format                              prints the output in the specified format. Allowed values: table, json, yaml (default table)\n      --pass-credentials                           pass credentials to all domains\n      --password string                            chart repository password where to locate the requested chart\n      --plain-http                                 use insecure HTTP connections for the chart download\n      --post-renderer postRendererString           the path to an executable to be used for post rendering. If it exists in $PATH, the binary will be used, otherwise it will try to look for the executable at the given path\n      --post-renderer-args postRendererArgsSlice   an argument to the post-renderer (can specify multiple) (default [])\n      --render-subchart-notes                      if set, render subchart notes along with the parent\n      --repo string                                chart repository url where to locate the requested chart\n      --reset-then-reuse-values                    when upgrading, reset the values to the ones built into the chart, apply the last release's values and merge in any overrides from the command line via --set and -f. If '--reset-values' or '--reuse-values' is specified, this is ignored\n      --reset-values                               when upgrading, reset the values to the ones built into the chart\n      --reuse-values                               when upgrading, reuse the last release's values and merge in any overrides from the command line via --set and -f. If '--reset-values' is specified, this is ignored\n      --set stringArray                            set values on the command line (can specify multiple or separate values with commas: key1=val1,key2=val2)\n      --set-file stringArray                       set values from respective files specified via the command line (can specify multiple or separate values with commas: key1=path1,key2=path2)\n      --set-json stringArray                       set JSON values on the command line (can specify multiple or separate values with commas: key1=jsonval1,key2=jsonval2)\n      --set-literal stringArray                    set a literal STRING value on the command line\n      --set-string stringArray                     set STRING values on the command line (can specify multiple or separate values with commas: key1=val1,key2=val2)\n      --skip-crds                                  if set, no CRDs will be installed when an upgrade is performed with install flag enabled. By default, CRDs are installed if not already present, when an upgrade is performed with install flag enabled\n      --skip-schema-validation                     if set, disables JSON schema validation\n      --take-ownership                             if set, upgrade will ignore the check for helm annotations and take ownership of the existing resources\n      --timeout duration                           time to wait for any individual Kubernetes operation (like Jobs for hooks) (default 5m0s)\n      --username string                            chart repository username where to locate the requested chart\n  -f, --values strings                             specify values in a YAML file or a URL (can specify multiple)\n      --verify                                     verify the package before using it\n      --version string                             specify a version constraint for the chart version to use. This constraint can be a specific tag (e.g. 1.1.1) or it may reference a valid range (e.g. ^2.0.0). If this is not specified, the latest version is used\n      --wait                                       if set, will wait until all Pods, PVCs, Services, and minimum number of Pods of a Deployment, StatefulSet, or ReplicaSet are in a ready state before marking the release as successful. It will wait for as long as --timeout\n      --wait-for-jobs                              if set and --wait enabled, will wait until all Jobs have been completed before marking the release as successful. It will wait for as long as --timeout\n</code></pre>"},{"location":"helm/helm_upgrade/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_upgrade/#see-also","title":"SEE ALSO","text":"<ul> <li>helm    - The Helm package manager for Kubernetes.</li> </ul>"},{"location":"helm/helm_upgrade/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_verify/","title":"Helm Verify","text":""},{"location":"helm/helm_verify/#helm-verify","title":"helm verify","text":"<p>verify that a chart at the given path has been signed and is valid</p>"},{"location":"helm/helm_verify/#synopsis","title":"Synopsis","text":"<p>Verify that the given chart has a valid provenance file.</p> <p>Provenance files provide cryptographic verification that a chart has not been tampered with, and was packaged by a trusted provider.</p> <p>This command can be used to verify a local chart. Several other commands provide '--verify' flags that run the same validation. To generate a signed package, use the 'helm package --sign' command.</p> <pre><code>helm verify PATH [flags]\n</code></pre>"},{"location":"helm/helm_verify/#options","title":"Options","text":"<pre><code>  -h, --help             help for verify\n      --keyring string   keyring containing public keys (default \"~/.gnupg/pubring.gpg\")\n</code></pre>"},{"location":"helm/helm_verify/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_verify/#see-also","title":"SEE ALSO","text":"<ul> <li>helm    - The Helm package manager for Kubernetes.</li> </ul>"},{"location":"helm/helm_verify/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"helm/helm_version/","title":"Helm Version","text":""},{"location":"helm/helm_version/#helm-version","title":"helm version","text":"<p>print the client version information</p>"},{"location":"helm/helm_version/#synopsis","title":"Synopsis","text":"<p>Show the version for Helm.</p> <p>This will print a representation the version of Helm. The output will look something like this:</p> <p>version.BuildInfo{Version:\"v3.2.1\", GitCommit:\"fe51cd1e31e6a202cba7dead9552a6d418ded79a\", GitTreeState:\"clean\", GoVersion:\"go1.13.10\"}</p> <ul> <li>Version is the semantic version of the release.</li> <li>GitCommit is the SHA for the commit that this version was built from.</li> <li>GitTreeState is \"clean\" if there are no local code changes when this binary was   built, and \"dirty\" if the binary was built from locally modified code.</li> <li>GoVersion is the version of Go that was used to compile Helm.</li> </ul> <p>When using the --template flag the following properties are available to use in the template:</p> <ul> <li>.Version contains the semantic version of Helm</li> <li>.GitCommit is the git commit</li> <li>.GitTreeState is the state of the git tree when Helm was built</li> <li>.GoVersion contains the version of Go that Helm was compiled with</li> </ul> <p>For example, --template='Version: {{.Version}}' outputs 'Version: v3.2.1'.</p> <pre><code>helm version [flags]\n</code></pre>"},{"location":"helm/helm_version/#options","title":"Options","text":"<pre><code>  -h, --help              help for version\n      --short             print the version number\n      --template string   template for version string format\n</code></pre>"},{"location":"helm/helm_version/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --burst-limit int                 client-side default throttling limit (default 100)\n      --debug                           enable verbose output\n      --kube-apiserver string           the address and the port for the Kubernetes API server\n      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-user string             username to impersonate for the operation\n      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection\n      --kube-context string             name of the kubeconfig context to use\n      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --kube-token string               bearer token used for authentication\n      --kubeconfig string               path to the kubeconfig file\n  -n, --namespace string                namespace scope for this request\n      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting\n      --registry-config string          path to the registry config file (default \"~/.config/helm/registry/config.json\")\n      --repository-cache string         path to the directory containing cached repository indexes (default \"~/.cache/helm/repository\")\n      --repository-config string        path to the file containing repository names and URLs (default \"~/.config/helm/repositories.yaml\")\n</code></pre>"},{"location":"helm/helm_version/#see-also","title":"SEE ALSO","text":"<ul> <li>helm    - The Helm package manager for Kubernetes.</li> </ul>"},{"location":"helm/helm_version/#auto-generated-by-spf13cobra-on-15-jan-2025","title":"Auto generated by spf13/cobra on 15-Jan-2025","text":""},{"location":"howto/","title":"How-to Guides","text":"<p>Here you\u2019ll find short answers to \u201cHow do I\u2026.?\u201d types of questions. These how-to guides don\u2019t cover topics in depth \u2013 you\u2019ll find that material in the Topic Guides. However, these guides will help you quickly accomplish common tasks.</p>"},{"location":"howto/chart_releaser_action/","title":"Chart Releaser Action to Automate GitHub Page Charts","text":"<p>This guide describes how to use Chart Releaser Action to automate releasing charts through GitHub pages.  Chart Releaser Action is a GitHub Action workflow to turn a GitHub project into a self-hosted Helm chart repo, using helm/chart-releaser CLI tool.</p>"},{"location":"howto/chart_releaser_action/#repository-changes","title":"Repository Changes","text":"<p>Create a Git repository under your GitHub organization.  You could give the name of the repository as <code>helm-charts</code>, though other names are also acceptable.  The sources of all the charts can be placed under the <code>main</code> branch.  The charts should be placed under <code>/charts</code> directory at the top-level of the directory tree.</p> <p>There should be another branch named <code>gh-pages</code> to publish the charts.  The changes to that branch will be automatically created by the Chart Releaser Action described here.  However, you can create that <code>gh-branch</code> and add <code>README.md</code> file, which is going to be visible to the users visiting the page.</p> <p>You can add instruction in the <code>README.md</code> for charts installation like this (replace <code>&lt;alias&gt;</code>, <code>&lt;orgname&gt;</code>, and <code>&lt;chart-name&gt;</code>):</p> <pre><code>## Usage\n\n[Helm](https://helm.sh) must be installed to use the charts.  Please refer to\nHelm's [documentation](https://helm.sh/docs) to get started.\n\nOnce Helm has been set up correctly, add the repo as follows:\n\n  helm repo add &lt;alias&gt; https://&lt;orgname&gt;.github.io/helm-charts\n\nIf you had already added this repo earlier, run `helm repo update` to retrieve\nthe latest versions of the packages.  You can then run `helm search repo\n&lt;alias&gt;` to see the charts.\n\nTo install the &lt;chart-name&gt; chart:\n\n    helm install my-&lt;chart-name&gt; &lt;alias&gt;/&lt;chart-name&gt;\n\nTo uninstall the chart:\n\n    helm uninstall my-&lt;chart-name&gt;\n</code></pre> <p>The charts will be published to a website with URL like this:</p> <pre><code>https://&lt;orgname&gt;.github.io/helm-charts\n</code></pre>"},{"location":"howto/chart_releaser_action/#github-actions-workflow","title":"GitHub Actions Workflow","text":"<p>Create GitHub Actions workflow file in the <code>main</code> branch at <code>.github/workflows/release.yml</code></p> <pre><code>name: Release Charts\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  release:\n    permissions:\n      contents: write\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n        with:\n          fetch-depth: 0\n\n      - name: Configure Git\n        run: |\n          git config user.name \"$GITHUB_ACTOR\"\n          git config user.email \"$GITHUB_ACTOR@users.noreply.github.com\"\n\n      - name: Run chart-releaser\n        uses: helm/chart-releaser-action@v1.6.0\n        env:\n          CR_TOKEN: \"${{ secrets.GITHUB_TOKEN }}\"\n</code></pre> <p>The above configuration uses @helm/chart-releaser-action to turn your GitHub project into a self-hosted Helm chart repo.  It does this - during every push to main - by checking each chart in your project, and whenever there's a new chart version, creates a corresponding GitHub release named for the chart version, adds Helm chart artifacts to the release, and creates or updates an <code>index.yaml</code> file with metadata about those releases, which is then hosted on GitHub pages.</p> <p>The Chart Releaser Action version number used in the above example is <code>v1.6.0</code>. You can change it to the latest available version.</p> <p>Note: The Chart Releaser Action is almost always used in tandem with the Helm Testing Action and Kind Action.</p>"},{"location":"howto/chart_repository_sync_example/","title":"Syncing Your Chart Repository","text":"<p>Note: This example is specifically for a Google Cloud Storage (GCS) bucket which serves a chart repository.</p>"},{"location":"howto/chart_repository_sync_example/#prerequisites","title":"Prerequisites","text":"<ul> <li>Install the gsutil tool. We   rely heavily on the gsutil rsync functionality</li> <li>Be sure to have access to the Helm binary</li> <li>Optional: We recommend you set object   versioning   on your GCS bucket in case you accidentally delete something.</li> </ul>"},{"location":"howto/chart_repository_sync_example/#set-up-a-local-chart-repository-directory","title":"Set up a local chart repository directory","text":"<p>Create a local directory like we did in the chart repository guide, and place your packaged charts in that directory.</p> <p>For example:</p> <pre><code>$ mkdir fantastic-charts\n$ mv alpine-0.1.0.tgz fantastic-charts/\n</code></pre>"},{"location":"howto/chart_repository_sync_example/#generate-an-updated-indexyaml","title":"Generate an updated index.yaml","text":"<p>Use Helm to generate an updated index.yaml file by passing in the directory path and the url of the remote repository to the <code>helm repo index</code> command like this:</p> <pre><code>$ helm repo index fantastic-charts/ --url https://fantastic-charts.storage.googleapis.com\n</code></pre> <p>This will generate an updated index.yaml file and place it in the <code>fantastic-charts/</code> directory.</p>"},{"location":"howto/chart_repository_sync_example/#sync-your-local-and-remote-chart-repositories","title":"Sync your local and remote chart repositories","text":"<p>Upload the contents of the directory to your GCS bucket by running <code>scripts/sync-repo.sh</code> and pass in the local directory name and the GCS bucket name.</p> <p>For example:</p> <pre><code>$ pwd\n/Users/me/code/go/src/helm.sh/helm\n$ scripts/sync-repo.sh fantastic-charts/ fantastic-charts\nGetting ready to sync your local directory (fantastic-charts/) to a remote repository at gs://fantastic-charts\nVerifying Prerequisites....\nThumbs up! Looks like you have gsutil. Let's continue.\nBuilding synchronization state...\nStarting synchronization\nWould copy file://fantastic-charts/alpine-0.1.0.tgz to gs://fantastic-charts/alpine-0.1.0.tgz\nWould copy file://fantastic-charts/index.yaml to gs://fantastic-charts/index.yaml\nAre you sure you would like to continue with these changes?? [y/N]} y\nBuilding synchronization state...\nStarting synchronization\nCopying file://fantastic-charts/alpine-0.1.0.tgz [Content-Type=application/x-tar]...\nUploading   gs://fantastic-charts/alpine-0.1.0.tgz:              740 B/740 B\nCopying file://fantastic-charts/index.yaml [Content-Type=application/octet-stream]...\nUploading   gs://fantastic-charts/index.yaml:                    347 B/347 B\nCongratulations your remote chart repository now matches the contents of fantastic-charts/\n</code></pre>"},{"location":"howto/chart_repository_sync_example/#updating-your-chart-repository","title":"Updating your chart repository","text":"<p>You'll want to keep a local copy of the contents of your chart repository or use <code>gsutil rsync</code> to copy the contents of your remote chart repository to a local directory.</p> <p>For example:</p> <pre><code>$ gsutil rsync -d -n gs://bucket-name local-dir/    # the -n flag does a dry run\nBuilding synchronization state...\nStarting synchronization\nWould copy gs://bucket-name/alpine-0.1.0.tgz to file://local-dir/alpine-0.1.0.tgz\nWould copy gs://bucket-name/index.yaml to file://local-dir/index.yaml\n\n$ gsutil rsync -d gs://bucket-name local-dir/       # performs the copy actions\nBuilding synchronization state...\nStarting synchronization\nCopying gs://bucket-name/alpine-0.1.0.tgz...\nDownloading file://local-dir/alpine-0.1.0.tgz:                        740 B/740 B\nCopying gs://bucket-name/index.yaml...\nDownloading file://local-dir/index.yaml:                              346 B/346 B\n</code></pre> <p>Helpful Links: * Documentation on gsutil   rsync * The Chart Repository Guide * Documentation on object versioning and concurrency   control   in Google Cloud Storage</p>"},{"location":"howto/charts_tips_and_tricks/","title":"Chart Development Tips and Tricks","text":"<p>This guide covers some of the tips and tricks Helm chart developers have learned while building production-quality charts.</p>"},{"location":"howto/charts_tips_and_tricks/#know-your-template-functions","title":"Know Your Template Functions","text":"<p>Helm uses Go templates for templating your resource files. While Go ships several built-in functions, we have added many others.</p> <p>First, we added all of the functions in the Sprig library, except <code>env</code> and <code>expandenv</code>, for security reasons.</p> <p>We also added two special template functions: <code>include</code> and <code>required</code>. The <code>include</code> function allows you to bring in another template, and then pass the results to other template functions.</p> <p>For example, this template snippet includes a template called <code>mytpl</code>, then lowercases the result, then wraps that in double quotes.</p> <pre><code>value: {{ include \"mytpl\" . | lower | quote }}\n</code></pre> <p>The <code>required</code> function allows you to declare a particular values entry as required for template rendering.  If the value is empty, the template rendering will fail with a user submitted error message.</p> <p>The following example of the <code>required</code> function declares an entry for <code>.Values.who</code> is required, and will print an error message when that entry is missing:</p> <pre><code>value: {{ required \"A valid .Values.who entry required!\" .Values.who }}\n</code></pre>"},{"location":"howto/charts_tips_and_tricks/#quote-strings-dont-quote-integers","title":"Quote Strings, Don't Quote Integers","text":"<p>When you are working with string data, you are always safer quoting the strings than leaving them as bare words:</p> <pre><code>name: {{ .Values.MyName | quote }}\n</code></pre> <p>But when working with integers do not quote the values. That can, in many cases, cause parsing errors inside of Kubernetes.</p> <pre><code>port: {{ .Values.Port }}\n</code></pre> <p>This remark does not apply to env variables values which are expected to be string, even if they represent integers:</p> <pre><code>env:\n  - name: HOST\n    value: \"http://host\"\n  - name: PORT\n    value: \"1234\"\n</code></pre>"},{"location":"howto/charts_tips_and_tricks/#using-the-include-function","title":"Using the 'include' Function","text":"<p>Go provides a way of including one template in another using a built-in <code>template</code> directive. However, the built-in function cannot be used in Go template pipelines.</p> <p>To make it possible to include a template, and then perform an operation on that template's output, Helm has a special <code>include</code> function:</p> <pre><code>{{ include \"toYaml\" $value | indent 2 }}\n</code></pre> <p>The above includes a template called <code>toYaml</code>, passes it <code>$value</code>, and then passes the output of that template to the <code>indent</code> function.</p> <p>Because YAML ascribes significance to indentation levels and whitespace, this is one great way to include snippets of code, but handle indentation in a relevant context.</p>"},{"location":"howto/charts_tips_and_tricks/#using-the-required-function","title":"Using the 'required' function","text":"<p>Go provides a way for setting template options to control behavior when a map is indexed with a key that's not present in the map. This is typically set with <code>template.Options(\"missingkey=option\")</code>, where <code>option</code> can be <code>default</code>, <code>zero</code>, or <code>error</code>. While setting this option to error will stop execution with an error, this would apply to every missing key in the map. There may be situations where a chart developer wants to enforce this behavior for select values in the <code>values.yaml</code> file.</p> <p>The <code>required</code> function gives developers the ability to declare a value entry as required for template rendering. If the entry is empty in <code>values.yaml</code>, the template will not render and will return an error message supplied by the developer.</p> <p>For example:</p> <pre><code>{{ required \"A valid foo is required!\" .Values.foo }}\n</code></pre> <p>The above will render the template when <code>.Values.foo</code> is defined, but will fail to render and exit when <code>.Values.foo</code> is undefined.</p>"},{"location":"howto/charts_tips_and_tricks/#using-the-tpl-function","title":"Using the 'tpl' Function","text":"<p>The <code>tpl</code> function allows developers to evaluate strings as templates inside a template. This is useful to pass a template string as a value to a chart or render external configuration files. Syntax: <code>{{ tpl TEMPLATE_STRING VALUES }}</code></p> <p>Examples:</p> <pre><code># values\ntemplate: \"{{ .Values.name }}\"\nname: \"Tom\"\n\n# template\n{{ tpl .Values.template . }}\n\n# output\nTom\n</code></pre> <p>Rendering an external configuration file:</p> <pre><code># external configuration file conf/app.conf\nfirstName={{ .Values.firstName }}\nlastName={{ .Values.lastName }}\n\n# values\nfirstName: Peter\nlastName: Parker\n\n# template\n{{ tpl (.Files.Get \"conf/app.conf\") . }}\n\n# output\nfirstName=Peter\nlastName=Parker\n</code></pre>"},{"location":"howto/charts_tips_and_tricks/#creating-image-pull-secrets","title":"Creating Image Pull Secrets","text":"<p>Image pull secrets are essentially a combination of registry, username, and password.  You may need them in an application you are deploying, but to create them requires running <code>base64</code> a couple of times.  We can write a helper template to compose the Docker configuration file for use as the Secret's payload.  Here is an example:</p> <p>First, assume that the credentials are defined in the <code>values.yaml</code> file like so:</p> <pre><code>imageCredentials:\n  registry: quay.io\n  username: someone\n  password: sillyness\n  email: someone@host.com\n</code></pre> <p>We then define our helper template as follows:</p> <pre><code>{{- define \"imagePullSecret\" }}\n{{- with .Values.imageCredentials }}\n{{- printf \"{\\\"auths\\\":{\\\"%s\\\":{\\\"username\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"email\\\":\\\"%s\\\",\\\"auth\\\":\\\"%s\\\"}}}\" .registry .username .password .email (printf \"%s:%s\" .username .password | b64enc) | b64enc }}\n{{- end }}\n{{- end }}\n</code></pre> <p>Finally, we use the helper template in a larger template to create the Secret manifest:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: myregistrykey\ntype: kubernetes.io/dockerconfigjson\ndata:\n  .dockerconfigjson: {{ template \"imagePullSecret\" . }}\n</code></pre>"},{"location":"howto/charts_tips_and_tricks/#automatically-roll-deployments","title":"Automatically Roll Deployments","text":"<p>Often times ConfigMaps or Secrets are injected as configuration files in containers or there are other external dependency changes that require rolling pods. Depending on the application a restart may be required should those be updated with a subsequent <code>helm upgrade</code>, but if the deployment spec itself didn't change the application keeps running with the old configuration resulting in an inconsistent deployment.</p> <p>The <code>sha256sum</code> function can be used to ensure a deployment's annotation section is updated if another file changes:</p> <pre><code>kind: Deployment\nspec:\n  template:\n    metadata:\n      annotations:\n        checksum/config: {{ include (print $.Template.BasePath \"/configmap.yaml\") . | sha256sum }}\n[...]\n</code></pre> <p>NOTE: If you're adding this to a library chart you won't be able to access your file in <code>$.Template.BasePath</code>. Instead you can reference your definition with <code>{{ include (\"mylibchart.configmap\") . | sha256sum }}</code>.</p> <p>In the event you always want to roll your deployment, you can use a similar annotation step as above, instead replacing with a random string so it always changes and causes the deployment to roll:</p> <pre><code>kind: Deployment\nspec:\n  template:\n    metadata:\n      annotations:\n        rollme: {{ randAlphaNum 5 | quote }}\n[...]\n</code></pre> <p>Each invocation of the template function will generate a unique random string. This means that if it's necessary to sync the random strings used by multiple resources, all relevant resources will need to be in the same template file.</p> <p>Both of these methods allow your Deployment to leverage the built in update strategy logic to avoid taking downtime.</p> <p>NOTE: In the past we recommended using the <code>--recreate-pods</code> flag as another option. This flag has been marked as deprecated in Helm 3 in favor of the more declarative method above.</p>"},{"location":"howto/charts_tips_and_tricks/#tell-helm-not-to-uninstall-a-resource","title":"Tell Helm Not To Uninstall a Resource","text":"<p>Sometimes there are resources that should not be uninstalled when Helm runs a <code>helm uninstall</code>. Chart developers can add an annotation to a resource to prevent it from being uninstalled.</p> <pre><code>kind: Secret\nmetadata:\n  annotations:\n    helm.sh/resource-policy: keep\n[...]\n</code></pre> <p>The annotation <code>helm.sh/resource-policy: keep</code> instructs Helm to skip deleting this resource when a helm operation (such as <code>helm uninstall</code>, <code>helm upgrade</code> or <code>helm rollback</code>) would result in its deletion. However, this resource becomes orphaned. Helm will no longer manage it in any way. This can lead to problems if using <code>helm install --replace</code> on a release that has already been uninstalled, but has kept resources.</p>"},{"location":"howto/charts_tips_and_tricks/#using-partials-and-template-includes","title":"Using \"Partials\" and Template Includes","text":"<p>Sometimes you want to create some reusable parts in your chart, whether they're blocks or template partials. And often, it's cleaner to keep these in their own files.</p> <p>In the <code>templates/</code> directory, any file that begins with an underscore(<code>_</code>) is not expected to output a Kubernetes manifest file. So by convention, helper templates and partials are placed in a <code>_helpers.tpl</code> file.</p>"},{"location":"howto/charts_tips_and_tricks/#complex-charts-with-many-dependencies","title":"Complex Charts with Many Dependencies","text":"<p>Many of the charts in the CNCF Artifact Hub are \"building blocks\" for creating more advanced applications. But charts may be used to create instances of large-scale applications. In such cases, a single umbrella chart may have multiple subcharts, each of which functions as a piece of the whole.</p> <p>The current best practice for composing a complex application from discrete parts is to create a top-level umbrella chart that exposes the global configurations, and then use the <code>charts/</code> subdirectory to embed each of the components.</p>"},{"location":"howto/charts_tips_and_tricks/#yaml-is-a-superset-of-json","title":"YAML is a Superset of JSON","text":"<p>According to the YAML specification, YAML is a superset of JSON. That means that any valid JSON structure ought to be valid in YAML.</p> <p>This has an advantage: Sometimes template developers may find it easier to express a datastructure with a JSON-like syntax rather than deal with YAML's whitespace sensitivity.</p> <p>As a best practice, templates should follow a YAML-like syntax unless the JSON syntax substantially reduces the risk of a formatting issue.</p>"},{"location":"howto/charts_tips_and_tricks/#be-careful-with-generating-random-values","title":"Be Careful with Generating Random Values","text":"<p>There are functions in Helm that allow you to generate random data, cryptographic keys, and so on. These are fine to use. But be aware that during upgrades, templates are re-executed. When a template run generates data that differs from the last run, that will trigger an update of that resource.</p>"},{"location":"howto/charts_tips_and_tricks/#install-or-upgrade-a-release-with-one-command","title":"Install or Upgrade a Release with One Command","text":"<p>Helm provides a way to perform an install-or-upgrade as a single command. Use <code>helm upgrade</code> with the <code>--install</code> command. This will cause Helm to see if the release is already installed. If not, it will run an install. If it is, then the existing release will be upgraded.</p> <pre><code>$ helm upgrade --install &lt;release name&gt; --values &lt;values file&gt; &lt;chart directory&gt;\n</code></pre>"},{"location":"intro/","title":"Introduction to Helm","text":"<p>Are you new to Helm? This is the place to start!</p>"},{"location":"intro/CheatSheet/","title":"Cheat Sheet","text":"<p>Helm cheatsheet featuring all the necessary commands required to manage an application through Helm.</p>"},{"location":"intro/CheatSheet/#basic-interpretationscontext","title":"Basic interpretations/context","text":"<p>Chart: - It is the name of your chart in case it has been pulled and untarred. - It is / in case the repository has been added but chart not pulled. - It is the URL/Absolute path to the chart. <p>Name: - It is the name you want to give to your current helm chart installation.</p> <p>Release: - Is the name you assigned to an installation instance. </p> <p>Revision: - Is the value from the Helm history command</p> <p>Repo-name: - The name of a repository. </p> <p>DIR: - Directory name/path</p>"},{"location":"intro/CheatSheet/#chart-management","title":"Chart Management","text":"<pre><code>helm create &lt;name&gt;                      # Creates a chart directory along with the common files and directories used in a chart.\nhelm package &lt;chart-path&gt;               # Packages a chart into a versioned chart archive file.\nhelm lint &lt;chart&gt;                       # Run tests to examine a chart and identify possible issues:\nhelm show all &lt;chart&gt;                   # Inspect a chart and list its contents:\nhelm show values &lt;chart&gt;                # Displays the contents of the values.yaml file\nhelm pull &lt;chart&gt;                       # Download/pull chart \nhelm pull &lt;chart&gt; --untar=true          # If set to true, will untar the chart after downloading it\nhelm pull &lt;chart&gt; --verify              # Verify the package before using it\nhelm pull &lt;chart&gt; --version &lt;number&gt;    # Default-latest is used, specify a version constraint for the chart version to use\nhelm dependency list &lt;chart&gt;            # Display a list of a chart\u2019s dependencies:\n</code></pre>"},{"location":"intro/CheatSheet/#install-and-uninstall-apps","title":"Install and Uninstall Apps","text":"<pre><code>helm install &lt;name&gt; &lt;chart&gt;                           # Install the chart with a name\nhelm install &lt;name&gt; &lt;chart&gt; --namespace &lt;namespace&gt;   # Install the chart in a specific namespace\nhelm install &lt;name&gt; &lt;chart&gt; --set key1=val1,key2=val2 # Set values on the command line (can specify multiple or separate values with commas)\nhelm install &lt;name&gt; &lt;chart&gt; --values &lt;yaml-file/url&gt;  # Install the chart with your specified values\nhelm install &lt;name&gt; &lt;chart&gt; --dry-run --debug         # Run a test installation to validate chart (p)\nhelm install &lt;name&gt; &lt;chart&gt; --verify                  # Verify the package before using it \nhelm install &lt;name&gt; &lt;chart&gt; --dependency-update       # update dependencies if they are missing before installing the chart\nhelm uninstall &lt;name&gt;                                 # Uninstall a release\n</code></pre>"},{"location":"intro/CheatSheet/#perform-app-upgrade-and-rollback","title":"Perform App Upgrade and Rollback","text":"<pre><code>helm upgrade &lt;release&gt; &lt;chart&gt;                            # Upgrade a release\nhelm upgrade &lt;release&gt; &lt;chart&gt; --atomic                   # If set, upgrade process rolls back changes made in case of failed upgrade.\nhelm upgrade &lt;release&gt; &lt;chart&gt; --dependency-update        # update dependencies if they are missing before installing the chart\nhelm upgrade &lt;release&gt; &lt;chart&gt; --version &lt;version_number&gt; # specify a version constraint for the chart version to use\nhelm upgrade &lt;release&gt; &lt;chart&gt; --values                   # specify values in a YAML file or a URL (can specify multiple)\nhelm upgrade &lt;release&gt; &lt;chart&gt; --set key1=val1,key2=val2  # Set values on the command line (can specify multiple or separate valuese)\nhelm upgrade &lt;release&gt; &lt;chart&gt; --force                    # Force resource updates through a replacement strategy\nhelm rollback &lt;release&gt; &lt;revision&gt;                        # Roll back a release to a specific revision\nhelm rollback &lt;release&gt; &lt;revision&gt;  --cleanup-on-fail     # Allow deletion of new resources created in this rollback when rollback fails\n</code></pre>"},{"location":"intro/CheatSheet/#list-add-remove-and-update-repositories","title":"List, Add, Remove, and Update Repositories","text":"<pre><code>helm repo add &lt;repo-name&gt; &lt;url&gt;   # Add a repository from the internet:\nhelm repo list                    # List added chart repositories\nhelm repo update                  # Update information of available charts locally from chart repositories\nhelm repo remove &lt;repo_name&gt;      # Remove one or more chart repositories\nhelm repo index &lt;DIR&gt;             # Read the current directory and generate an index file based on the charts found.\nhelm repo index &lt;DIR&gt; --merge     # Merge the generated index with an existing index file\nhelm search repo &lt;keyword&gt;        # Search repositories for a keyword in charts\nhelm search hub &lt;keyword&gt;         # Search for charts in the Artifact Hub or your own hub instance\n</code></pre>"},{"location":"intro/CheatSheet/#helm-release-monitoring","title":"Helm Release monitoring","text":"<pre><code>helm list                       # Lists all of the releases for a specified namespace, uses current namespace context if namespace not specified\nhelm list --all                 # Show all releases without any filter applied, can use -a\nhelm list --all-namespaces      # List releases across all namespaces, we can use -A\nhelm list -l key1=value1,key2=value2 # Selector (label query) to filter on, supports '=', '==', and '!='\nhelm list --date                # Sort by release date\nhelm list --deployed            # Show deployed releases. If no other is specified, this will be automatically enabled\nhelm list --pending             # Show pending releases\nhelm list --failed              # Show failed releases\nhelm list --uninstalled         # Show uninstalled releases (if 'helm uninstall --keep-history' was used)\nhelm list --superseded          # Show superseded releases\nhelm list -o yaml               # Prints the output in the specified format. Allowed values: table, json, yaml (default table)\nhelm status &lt;release&gt;           # This command shows the status of a named release.\nhelm status &lt;release&gt; --revision &lt;number&gt;   # if set, display the status of the named release with revision\nhelm history &lt;release&gt;          # Historical revisions for a given release.\nhelm env                        # Env prints out all the environment information in use by Helm.\n</code></pre>"},{"location":"intro/CheatSheet/#download-release-information","title":"Download Release Information","text":"<pre><code>helm get all &lt;release&gt;      # A human readable collection of information about the notes, hooks, supplied values, and generated manifest file of the given release.\nhelm get hooks &lt;release&gt;    # This command downloads hooks for a given release. Hooks are formatted in YAML and separated by the YAML '---\\n' separator.\nhelm get manifest &lt;release&gt; # A manifest is a YAML-encoded representation of the Kubernetes resources that were generated from this release's chart(s). If a chart is dependent on other charts, those resources will also be included in the manifest.\nhelm get notes &lt;release&gt;    # Shows notes provided by the chart of a named release.\nhelm get values &lt;release&gt;   # Downloads a values file for a given release. use -o to format output\n</code></pre>"},{"location":"intro/CheatSheet/#plugin-management","title":"Plugin Management","text":"<pre><code>helm plugin install &lt;path/url&gt;      # Install plugins\nhelm plugin list                    # View a list of all installed plugins\nhelm plugin update &lt;plugin&gt;         # Update plugins\nhelm plugin uninstall &lt;plugin&gt;      # Uninstall a plugin\n</code></pre>"},{"location":"intro/install/","title":"Installing Helm","text":"<p>This guide shows how to install the Helm CLI. Helm can be installed either from source, or from pre-built binary releases.</p>"},{"location":"intro/install/#from-the-helm-project","title":"From The Helm Project","text":"<p>The Helm project provides two ways to fetch and install Helm. These are the official methods to get Helm releases. In addition to that, the Helm community provides methods to install Helm through different package managers. Installation through those methods can be found below the official methods.</p>"},{"location":"intro/install/#from-the-binary-releases","title":"From the Binary Releases","text":"<p>Every release of Helm provides binary releases for a variety of OSes. These binary versions can be manually downloaded and installed.</p> <ol> <li>Download your desired version</li> <li>Unpack it (<code>tar -zxvf helm-v3.0.0-linux-amd64.tar.gz</code>)</li> <li>Find the <code>helm</code> binary in the unpacked directory, and move it to its desired    destination (<code>mv linux-amd64/helm /usr/local/bin/helm</code>)</li> </ol> <p>From there, you should be able to run the client and add the stable chart repository: <code>helm help</code>.</p> <p>Note: Helm automated tests are performed for Linux AMD64 only during GitHub Actions builds and releases. Testing of other OSes are the responsibility of the community requesting Helm for the OS in question.</p>"},{"location":"intro/install/#from-script","title":"From Script","text":"<p>Helm now has an installer script that will automatically grab the latest version of Helm and install it locally.</p> <p>You can fetch that script, and then execute it locally. It's well documented so that you can read through it and understand what it is doing before you run it.</p> <pre><code>$ curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3\n$ chmod 700 get_helm.sh\n$ ./get_helm.sh\n</code></pre> <p>Yes, you can <code>curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash</code> if you want to live on the edge.</p>"},{"location":"intro/install/#through-package-managers","title":"Through Package Managers","text":"<p>The Helm community provides the ability to install Helm through operating system package managers. These are not supported by the Helm project and are not considered trusted 3rd parties.</p>"},{"location":"intro/install/#from-homebrew-macos","title":"From Homebrew (macOS)","text":"<p>Members of the Helm community have contributed a Helm formula build to Homebrew. This formula is generally up to date.</p> <pre><code>brew install helm\n</code></pre> <p>(Note: There is also a formula for emacs-helm, which is a different project.)</p>"},{"location":"intro/install/#from-chocolatey-windows","title":"From Chocolatey (Windows)","text":"<p>Members of the Helm community have contributed a Helm package build to Chocolatey. This package is generally up to date.</p> <pre><code>choco install kubernetes-helm\n</code></pre>"},{"location":"intro/install/#from-scoop-windows","title":"From Scoop (Windows)","text":"<p>Members of the Helm community have contributed a Helm package build to Scoop. This package is generally up to date.</p> <pre><code>scoop install helm\n</code></pre>"},{"location":"intro/install/#from-winget-windows","title":"From Winget (Windows)","text":"<p>Members of the Helm community have contributed a Helm package build to Winget. This package is generally up to date.</p> <pre><code>winget install Helm.Helm\n</code></pre>"},{"location":"intro/install/#from-apt-debianubuntu","title":"From Apt (Debian/Ubuntu)","text":"<p>Members of the Helm community have contributed a Helm package for Apt. This package is generally up to date.</p> <pre><code>curl https://baltocdn.com/helm/signing.asc | gpg --dearmor | sudo tee /usr/share/keyrings/helm.gpg &gt; /dev/null\nsudo apt-get install apt-transport-https --yes\necho \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/helm.gpg] https://baltocdn.com/helm/stable/debian/ all main\" | sudo tee /etc/apt/sources.list.d/helm-stable-debian.list\nsudo apt-get update\nsudo apt-get install helm\n</code></pre>"},{"location":"intro/install/#from-dnfyum-fedora","title":"From dnf/yum (fedora)","text":"<p>Since Fedora 35, helm is available on the official repository. You can install helm with invoking:</p> <pre><code>sudo dnf install helm\n</code></pre>"},{"location":"intro/install/#from-snap","title":"From Snap","text":"<p>The Snapcrafters community maintains the Snap version of the Helm package:</p> <pre><code>sudo snap install helm --classic\n</code></pre>"},{"location":"intro/install/#from-pkg-freebsd","title":"From pkg (FreeBSD)","text":"<p>Members of the FreeBSD community have contributed a Helm package build to the FreeBSD Ports Collection. This package is generally up to date.</p> <pre><code>pkg install helm\n</code></pre>"},{"location":"intro/install/#development-builds","title":"Development Builds","text":"<p>In addition to releases you can download or install development snapshots of Helm.</p>"},{"location":"intro/install/#from-canary-builds","title":"From Canary Builds","text":"<p>\"Canary\" builds are versions of the Helm software that are built from the latest <code>main</code> branch. They are not official releases, and may not be stable. However, they offer the opportunity to test the cutting edge features.</p> <p>Canary Helm binaries are stored at get.helm.sh. Here are links to the common builds:</p> <ul> <li>Linux AMD64</li> <li>macOS AMD64</li> <li>Experimental Windows   AMD64</li> </ul>"},{"location":"intro/install/#from-source-linux-macos","title":"From Source (Linux, macOS)","text":"<p>Building Helm from source is slightly more work, but is the best way to go if you want to test the latest (pre-release) Helm version.</p> <p>You must have a working Go environment.</p> <pre><code>$ git clone https://github.com/helm/helm.git\n$ cd helm\n$ make\n</code></pre> <p>If required, it will fetch the dependencies and cache them, and validate configuration. It will then compile <code>helm</code> and place it in <code>bin/helm</code>.</p>"},{"location":"intro/install/#conclusion","title":"Conclusion","text":"<p>In most cases, installation is as simple as getting a pre-built <code>helm</code> binary. This document covers additional cases for those who want to do more sophisticated things with Helm.</p> <p>Once you have the Helm Client successfully installed, you can move on to using Helm to manage charts and add the stable chart repository.</p>"},{"location":"intro/quickstart/","title":"Quickstart Guide","text":"<p>This guide covers how you can quickly get started using Helm.</p>"},{"location":"intro/quickstart/#prerequisites","title":"Prerequisites","text":"<p>The following prerequisites are required for a successful and properly secured use of Helm.</p> <ol> <li>A Kubernetes cluster</li> <li>Deciding what security configurations to apply to your installation, if any</li> <li>Installing and configuring Helm.</li> </ol>"},{"location":"intro/quickstart/#install-kubernetes-or-have-access-to-a-cluster","title":"Install Kubernetes or have access to a cluster","text":"<ul> <li>You must have Kubernetes installed. For the latest release of Helm, we   recommend the latest stable release of Kubernetes, which in most cases is the   second-latest minor release.</li> <li>You should also have a local configured copy of <code>kubectl</code>.</li> </ul> <p>See the Helm Version Support Policy for the maximum version skew supported between Helm and Kubernetes.</p>"},{"location":"intro/quickstart/#install-helm","title":"Install Helm","text":"<p>Download a binary release of the Helm client. You can use tools like <code>homebrew</code>, or look at the official releases page.</p> <p>For more details, or for other options, see the installation guide.</p>"},{"location":"intro/quickstart/#initialize-a-helm-chart-repository","title":"Initialize a Helm Chart Repository","text":"<p>Once you have Helm ready, you can add a chart repository. Check Artifact Hub for available Helm chart repositories.</p> <pre><code>$ helm repo add bitnami https://charts.bitnami.com/bitnami\n</code></pre> <p>Once this is installed, you will be able to list the charts you can install:</p> <pre><code>$ helm search repo bitnami\nNAME                                CHART VERSION   APP VERSION     DESCRIPTION\nbitnami/bitnami-common              0.0.9           0.0.9           DEPRECATED Chart with custom templates used in ...\nbitnami/airflow                     8.0.2           2.0.0           Apache Airflow is a platform to programmaticall...\nbitnami/apache                      8.2.3           2.4.46          Chart for Apache HTTP Server\nbitnami/aspnet-core                 1.2.3           3.1.9           ASP.NET Core is an open-source framework create...\n# ... and many more\n</code></pre>"},{"location":"intro/quickstart/#install-an-example-chart","title":"Install an Example Chart","text":"<p>To install a chart, you can run the <code>helm install</code> command. Helm has several ways to find and install a chart, but the easiest is to use the <code>bitnami</code> charts.</p> <pre><code>$ helm repo update              # Make sure we get the latest list of charts\n$ helm install bitnami/mysql --generate-name\nNAME: mysql-1612624192\nLAST DEPLOYED: Sat Feb  6 16:09:56 2021\nNAMESPACE: default\nSTATUS: deployed\nREVISION: 1\nTEST SUITE: None\nNOTES: ...\n</code></pre> <p>In the example above, the <code>bitnami/mysql</code> chart was released, and the name of our new release is <code>mysql-1612624192</code>.</p> <p>You get a simple idea of the features of this MySQL chart by running <code>helm show chart bitnami/mysql</code>. Or you could run <code>helm show all bitnami/mysql</code> to get all information about the chart.</p> <p>Whenever you install a chart, a new release is created. So one chart can be installed multiple times into the same cluster. And each can be independently managed and upgraded.</p> <p>The <code>helm install</code> command is a very powerful command with many capabilities. To learn more about it, check out the [Using Helm Guide]({{&lt; ref \"using_helm.md\"</p> <p>}})</p>"},{"location":"intro/quickstart/#learn-about-releases","title":"Learn About Releases","text":"<p>It's easy to see what has been released using Helm:</p> <pre><code>$ helm list\nNAME                NAMESPACE   REVISION    UPDATED                                 STATUS      CHART       APP VERSION\nmysql-1612624192    default     1           2021-02-06 16:09:56.283059 +0100 CET    deployed    mysql-8.3.0 8.0.23\n</code></pre> <p>The <code>helm list</code> (or <code>helm ls</code>) function will show you a list of all deployed releases.</p>"},{"location":"intro/quickstart/#uninstall-a-release","title":"Uninstall a Release","text":"<p>To uninstall a release, use the <code>helm uninstall</code> command:</p> <pre><code>$ helm uninstall mysql-1612624192\nrelease \"mysql-1612624192\" uninstalled\n</code></pre> <p>This will uninstall <code>mysql-1612624192</code> from Kubernetes, which will remove all resources associated with the release as well as the release history.</p> <p>If the flag <code>--keep-history</code> is provided, release history will be kept. You will be able to request information about that release:</p> <pre><code>$ helm status mysql-1612624192\nStatus: UNINSTALLED\n...\n</code></pre> <p>Because Helm tracks your releases even after you've uninstalled them, you can audit a cluster's history, and even undelete a release (with <code>helm rollback</code>).</p>"},{"location":"intro/quickstart/#reading-the-help-text","title":"Reading the Help Text","text":"<p>To learn more about the available Helm commands, use <code>helm help</code> or type a command followed by the <code>-h</code> flag:</p> <pre><code>$ helm get -h\n</code></pre>"},{"location":"intro/using_helm/","title":"Using Helm","text":"<p>This guide explains the basics of using Helm to manage packages on your Kubernetes cluster. It assumes that you have already installed the Helm client.</p> <p>If you are simply interested in running a few quick commands, you may wish to begin with the Quickstart Guide. This chapter covers the particulars of Helm commands, and explains how to use Helm.</p>"},{"location":"intro/using_helm/#three-big-concepts","title":"Three Big Concepts","text":"<p>A Chart is a Helm package. It contains all of the resource definitions necessary to run an application, tool, or service inside of a Kubernetes cluster. Think of it like the Kubernetes equivalent of a Homebrew formula, an Apt dpkg, or a Yum RPM file.</p> <p>A Repository is the place where charts can be collected and shared. It's like Perl's CPAN archive or the Fedora Package Database, but for Kubernetes packages.</p> <p>A Release is an instance of a chart running in a Kubernetes cluster. One chart can often be installed many times into the same cluster. And each time it is installed, a new release is created. Consider a MySQL chart. If you want two databases running in your cluster, you can install that chart twice. Each one will have its own release, which will in turn have its own release name.</p> <p>With these concepts in mind, we can now explain Helm like this:</p> <p>Helm installs charts into Kubernetes, creating a new release for each installation. And to find new charts, you can search Helm chart repositories.</p>"},{"location":"intro/using_helm/#helm-search-finding-charts","title":"'helm search': Finding Charts","text":"<p>Helm comes with a powerful search command. It can be used to search two different types of source:</p> <ul> <li><code>helm search hub</code> searches the Artifact Hub, which   lists helm charts from dozens of different repositories.</li> <li><code>helm search repo</code> searches the repositories that you have added to your local   helm client (with <code>helm repo add</code>). This search is done over local data, and   no public network connection is needed.</li> </ul> <p>You can find publicly available charts by running <code>helm search hub</code>:</p> <pre><code>$ helm search hub wordpress\nURL                                                 CHART VERSION APP VERSION DESCRIPTION\nhttps://hub.helm.sh/charts/bitnami/wordpress        7.6.7         5.2.4       Web publishing platform for building blogs and ...\nhttps://hub.helm.sh/charts/presslabs/wordpress-...  v0.6.3        v0.6.3      Presslabs WordPress Operator Helm Chart\nhttps://hub.helm.sh/charts/presslabs/wordpress-...  v0.7.1        v0.7.1      A Helm chart for deploying a WordPress site on ...\n</code></pre> <p>The above searches for all <code>wordpress</code> charts on Artifact Hub.</p> <p>With no filter, <code>helm search hub</code> shows you all of the available charts.</p> <p><code>helm search hub</code> exposes the URL to the location on artifacthub.io but not the actual Helm repo. <code>helm search hub --list-repo-url</code> exposes the actual Helm repo URL which comes in handy when you are looking to add a new repo: <code>helm repo add [NAME] [URL]</code>.</p> <p>Using <code>helm search repo</code>, you can find the names of the charts in repositories you have already added:</p> <pre><code>$ helm repo add brigade https://brigadecore.github.io/charts\n\"brigade\" has been added to your repositories\n$ helm search repo brigade\nNAME                          CHART VERSION APP VERSION DESCRIPTION\nbrigade/brigade               1.3.2         v1.2.1      Brigade provides event-driven scripting of Kube...\nbrigade/brigade-github-app    0.4.1         v0.2.1      The Brigade GitHub App, an advanced gateway for...\nbrigade/brigade-github-oauth  0.2.0         v0.20.0     The legacy OAuth GitHub Gateway for Brigade\nbrigade/brigade-k8s-gateway   0.1.0                     A Helm chart for Kubernetes\nbrigade/brigade-project       1.0.0         v1.0.0      Create a Brigade project\nbrigade/kashti                0.4.0         v0.4.0      A Helm chart for Kubernetes\n</code></pre> <p>Helm search uses a fuzzy string matching algorithm, so you can type parts of words or phrases:</p> <pre><code>$ helm search repo kash\nNAME            CHART VERSION APP VERSION DESCRIPTION\nbrigade/kashti  0.4.0         v0.4.0      A Helm chart for Kubernetes\n</code></pre> <p>Search is a good way to find available packages. Once you have found a package you want to install, you can use <code>helm install</code> to install it.</p>"},{"location":"intro/using_helm/#helm-install-installing-a-package","title":"'helm install': Installing a Package","text":"<p>To install a new package, use the <code>helm install</code> command. At its simplest, it takes two arguments: A release name that you pick, and the name of the chart you want to install.</p> <pre><code>$ helm install happy-panda bitnami/wordpress\nNAME: happy-panda\nLAST DEPLOYED: Tue Jan 26 10:27:17 2021\nNAMESPACE: default\nSTATUS: deployed\nREVISION: 1\nNOTES:\n** Please be patient while the chart is being deployed **\n\nYour WordPress site can be accessed through the following DNS name from within your cluster:\n\n    happy-panda-wordpress.default.svc.cluster.local (port 80)\n\nTo access your WordPress site from outside the cluster follow the steps below:\n\n1. Get the WordPress URL by running these commands:\n\n  NOTE: It may take a few minutes for the LoadBalancer IP to be available.\n        Watch the status with: 'kubectl get svc --namespace default -w happy-panda-wordpress'\n\n   export SERVICE_IP=$(kubectl get svc --namespace default happy-panda-wordpress --template \"{{ range (index .status.loadBalancer.ingress 0) }}{{.}}{{ end }}\")\n   echo \"WordPress URL: http://$SERVICE_IP/\"\n   echo \"WordPress Admin URL: http://$SERVICE_IP/admin\"\n\n2. Open a browser and access WordPress using the obtained URL.\n\n3. Login with the following credentials below to see your blog:\n\n  echo Username: user\n  echo Password: $(kubectl get secret --namespace default happy-panda-wordpress -o jsonpath=\"{.data.wordpress-password}\" | base64 --decode)\n</code></pre> <p>Now the <code>wordpress</code> chart is installed. Note that installing a chart creates a new release object. The release above is named <code>happy-panda</code>. (If you want Helm to generate a name for you, leave off the release name and use <code>--generate-name</code>.)</p> <p>During installation, the <code>helm</code> client will print useful information about which resources were created, what the state of the release is, and also whether there are additional configuration steps you can or should take.</p> <p>Helm installs resources in the following order:</p> <ul> <li>Namespace</li> <li>NetworkPolicy</li> <li>ResourceQuota</li> <li>LimitRange</li> <li>PodSecurityPolicy</li> <li>PodDisruptionBudget</li> <li>ServiceAccount</li> <li>Secret</li> <li>SecretList</li> <li>ConfigMap</li> <li>StorageClass</li> <li>PersistentVolume</li> <li>PersistentVolumeClaim</li> <li>CustomResourceDefinition</li> <li>ClusterRole</li> <li>ClusterRoleList</li> <li>ClusterRoleBinding</li> <li>ClusterRoleBindingList</li> <li>Role</li> <li>RoleList</li> <li>RoleBinding</li> <li>RoleBindingList</li> <li>Service</li> <li>DaemonSet</li> <li>Pod</li> <li>ReplicationController</li> <li>ReplicaSet</li> <li>Deployment</li> <li>HorizontalPodAutoscaler</li> <li>StatefulSet</li> <li>Job</li> <li>CronJob</li> <li>Ingress</li> <li>APIService</li> </ul> <p>Helm does not wait until all of the resources are running before it exits. Many charts require Docker images that are over 600MB in size, and may take a long time to install into the cluster.</p> <p>To keep track of a release's state, or to re-read configuration information, you can use <code>helm status</code>:</p> <pre><code>$ helm status happy-panda\nNAME: happy-panda\nLAST DEPLOYED: Tue Jan 26 10:27:17 2021\nNAMESPACE: default\nSTATUS: deployed\nREVISION: 1\nNOTES:\n** Please be patient while the chart is being deployed **\n\nYour WordPress site can be accessed through the following DNS name from within your cluster:\n\n    happy-panda-wordpress.default.svc.cluster.local (port 80)\n\nTo access your WordPress site from outside the cluster follow the steps below:\n\n1. Get the WordPress URL by running these commands:\n\n  NOTE: It may take a few minutes for the LoadBalancer IP to be available.\n        Watch the status with: 'kubectl get svc --namespace default -w happy-panda-wordpress'\n\n   export SERVICE_IP=$(kubectl get svc --namespace default happy-panda-wordpress --template \"{{ range (index .status.loadBalancer.ingress 0) }}{{.}}{{ end }}\")\n   echo \"WordPress URL: http://$SERVICE_IP/\"\n   echo \"WordPress Admin URL: http://$SERVICE_IP/admin\"\n\n2. Open a browser and access WordPress using the obtained URL.\n\n3. Login with the following credentials below to see your blog:\n\n  echo Username: user\n  echo Password: $(kubectl get secret --namespace default happy-panda-wordpress -o jsonpath=\"{.data.wordpress-password}\" | base64 --decode)\n</code></pre> <p>The above shows the current state of your release.</p>"},{"location":"intro/using_helm/#customizing-the-chart-before-installing","title":"Customizing the Chart Before Installing","text":"<p>Installing the way we have here will only use the default configuration options for this chart. Many times, you will want to customize the chart to use your preferred configuration.</p> <p>To see what options are configurable on a chart, use <code>helm show values</code>:</p> <pre><code>$ helm show values bitnami/wordpress\n## Global Docker image parameters\n## Please, note that this will override the image parameters, including dependencies, configured to use the global value\n## Current available global Docker image parameters: imageRegistry and imagePullSecrets\n##\n# global:\n#   imageRegistry: myRegistryName\n#   imagePullSecrets:\n#     - myRegistryKeySecretName\n#   storageClass: myStorageClass\n\n## Bitnami WordPress image version\n## ref: https://hub.docker.com/r/bitnami/wordpress/tags/\n##\nimage:\n  registry: docker.io\n  repository: bitnami/wordpress\n  tag: 5.6.0-debian-10-r35\n  [..]\n</code></pre> <p>You can then override any of these settings in a YAML formatted file, and then pass that file during installation.</p> <pre><code>$ echo '{mariadb.auth.database: user0db, mariadb.auth.username: user0}' &gt; values.yaml\n$ helm install -f values.yaml bitnami/wordpress --generate-name\n</code></pre> <p>The above will create a default MariaDB user with the name <code>user0</code>, and grant this user access to a newly created <code>user0db</code> database, but will accept all the rest of the defaults for that chart.</p> <p>There are two ways to pass configuration data during install:</p> <ul> <li><code>--values</code> (or <code>-f</code>): Specify a YAML file with overrides. This can be   specified multiple times and the rightmost file will take precedence</li> <li><code>--set</code>: Specify overrides on the command line.</li> </ul> <p>If both are used, <code>--set</code> values are merged into <code>--values</code> with higher precedence. Overrides specified with <code>--set</code> are persisted in a Secret. Values that have been <code>--set</code> can be viewed for a given release with <code>helm get values &lt;release-name&gt;</code>. Values that have been <code>--set</code> can be cleared by running <code>helm upgrade</code> with <code>--reset-values</code> specified.</p>"},{"location":"intro/using_helm/#the-format-and-limitations-of-set","title":"The Format and Limitations of <code>--set</code>","text":"<p>The <code>--set</code> option takes zero or more name/value pairs. At its simplest, it is used like this: <code>--set name=value</code>. The YAML equivalent of that is:</p> <pre><code>name: value\n</code></pre> <p>Multiple values are separated by <code>,</code> characters. So <code>--set a=b,c=d</code> becomes:</p> <pre><code>a: b\nc: d\n</code></pre> <p>More complex expressions are supported. For example, <code>--set outer.inner=value</code> is translated into this:</p> <pre><code>outer:\n  inner: value\n</code></pre> <p>Lists can be expressed by enclosing values in <code>{</code> and <code>}</code>. For example, <code>--set name={a, b, c}</code> translates to:</p> <pre><code>name:\n  - a\n  - b\n  - c\n</code></pre> <p>Certain name/key can be set to be <code>null</code> or to be an empty array <code>[]</code>. For example, <code>--set name=[],a=null</code> translates</p> <pre><code>name:\n  - a\n  - b\n  - c\na: b\n</code></pre> <p>to</p> <pre><code>name: []\na: null\n</code></pre> <p>As of Helm 2.5.0, it is possible to access list items using an array index syntax. For example, <code>--set servers[0].port=80</code> becomes:</p> <pre><code>servers:\n  - port: 80\n</code></pre> <p>Multiple values can be set this way. The line <code>--set servers[0].port=80,servers[0].host=example</code> becomes:</p> <pre><code>servers:\n  - port: 80\n    host: example\n</code></pre> <p>Sometimes you need to use special characters in your <code>--set</code> lines. You can use a backslash to escape the characters; <code>--set name=value1\\,value2</code> will become:</p> <pre><code>name: \"value1,value2\"\n</code></pre> <p>Similarly, you can escape dot sequences as well, which may come in handy when charts use the <code>toYaml</code> function to parse annotations, labels and node selectors. The syntax for <code>--set nodeSelector.\"kubernetes\\.io/role\"=master</code> becomes:</p> <pre><code>nodeSelector:\n  kubernetes.io/role: master\n</code></pre> <p>Deeply nested data structures can be difficult to express using <code>--set</code>. Chart designers are encouraged to consider the <code>--set</code> usage when designing the format of a <code>values.yaml</code> file  (read more about Values Files).</p>"},{"location":"intro/using_helm/#more-installation-methods","title":"More Installation Methods","text":"<p>The <code>helm install</code> command can install from several sources:</p> <ul> <li>A chart repository (as we've seen above)</li> <li>A local chart archive (<code>helm install foo foo-0.1.1.tgz</code>)</li> <li>An unpacked chart directory (<code>helm install foo path/to/foo</code>)</li> <li>A full URL (<code>helm install foo https://example.com/charts/foo-1.2.3.tgz</code>)</li> </ul>"},{"location":"intro/using_helm/#helm-upgrade-and-helm-rollback-upgrading-a-release-and-recovering-on-failure","title":"'helm upgrade' and 'helm rollback': Upgrading a Release, and Recovering on Failure","text":"<p>When a new version of a chart is released, or when you want to change the configuration of your release, you can use the <code>helm upgrade</code> command.</p> <p>An upgrade takes an existing release and upgrades it according to the information you provide. Because Kubernetes charts can be large and complex, Helm tries to perform the least invasive upgrade. It will only update things that have changed since the last release.</p> <pre><code>$ helm upgrade -f panda.yaml happy-panda bitnami/wordpress\n</code></pre> <p>In the above case, the <code>happy-panda</code> release is upgraded with the same chart, but with a new YAML file:</p> <pre><code>mariadb.auth.username: user1\n</code></pre> <p>We can use <code>helm get values</code> to see whether that new setting took effect.</p> <pre><code>$ helm get values happy-panda\nmariadb:\n  auth:\n    username: user1\n</code></pre> <p>The <code>helm get</code> command is a useful tool for looking at a release in the cluster. And as we can see above, it shows that our new values from <code>panda.yaml</code> were deployed to the cluster.</p> <p>Now, if something does not go as planned during a release, it is easy to roll back to a previous release using <code>helm rollback [RELEASE] [REVISION]</code>.</p> <pre><code>$ helm rollback happy-panda 1\n</code></pre> <p>The above rolls back our happy-panda to its very first release version. A release version is an incremental revision. Every time an install, upgrade, or rollback happens, the revision number is incremented by 1. The first revision number is always 1. And we can use <code>helm history [RELEASE]</code> to see revision numbers for a certain release.</p>"},{"location":"intro/using_helm/#helpful-options-for-installupgraderollback","title":"Helpful Options for Install/Upgrade/Rollback","text":"<p>There are several other helpful options you can specify for customizing the behavior of Helm during an install/upgrade/rollback. Please note that this is not a full list of cli flags. To see a description of all flags, just run <code>helm &lt;command&gt; --help</code>.</p> <ul> <li><code>--timeout</code>: A Go duration value   to wait for Kubernetes commands to complete. This defaults to <code>5m0s</code>.</li> <li><code>--wait</code>: Waits until all Pods are in a ready state, PVCs are bound,   Deployments have minimum (<code>Desired</code> minus <code>maxUnavailable</code>) Pods in ready   state and Services have an IP address (and Ingress if a <code>LoadBalancer</code>) before   marking the release as successful. It will wait for as long as the <code>--timeout</code>   value. If timeout is reached, the release will be marked as <code>FAILED</code>. Note: In   scenarios where Deployment has <code>replicas</code> set to 1 and <code>maxUnavailable</code> is not   set to 0 as part of rolling update strategy, <code>--wait</code> will return as ready as   it has satisfied the minimum Pod in ready condition.</li> <li><code>--no-hooks</code>: This skips running hooks for the command</li> <li><code>--recreate-pods</code> (only available for <code>upgrade</code> and <code>rollback</code>): This flag   will cause all pods to be recreated (with the exception of pods belonging to   deployments). (DEPRECATED in Helm 3)</li> </ul>"},{"location":"intro/using_helm/#helm-uninstall-uninstalling-a-release","title":"'helm uninstall': Uninstalling a Release","text":"<p>When it is time to uninstall a release from the cluster, use the <code>helm uninstall</code> command:</p> <pre><code>$ helm uninstall happy-panda\n</code></pre> <p>This will remove the release from the cluster. You can see all of your currently deployed releases with the <code>helm list</code> command:</p> <pre><code>$ helm list\nNAME            VERSION UPDATED                         STATUS          CHART\ninky-cat        1       Wed Sep 28 12:59:46 2016        DEPLOYED        alpine-0.1.0\n</code></pre> <p>From the output above, we can see that the <code>happy-panda</code> release was uninstalled.</p> <p>In previous versions of Helm, when a release was deleted, a record of its deletion would remain. In Helm 3, deletion removes the release record as well. If you wish to keep a deletion release record, use <code>helm uninstall --keep-history</code>. Using <code>helm list --uninstalled</code> will only show releases that were uninstalled with the <code>--keep-history</code> flag.</p> <p>The <code>helm list --all</code> flag will show you all release records that Helm has retained, including records for failed or deleted items (if <code>--keep-history</code> was specified):</p> <pre><code>$  helm list --all\nNAME            VERSION UPDATED                         STATUS          CHART\nhappy-panda     2       Wed Sep 28 12:47:54 2016        UNINSTALLED     wordpress-10.4.5.6.0\ninky-cat        1       Wed Sep 28 12:59:46 2016        DEPLOYED        alpine-0.1.0\nkindred-angelf  2       Tue Sep 27 16:16:10 2016        UNINSTALLED     alpine-0.1.0\n</code></pre> <p>Note that because releases are now deleted by default, it is no longer possible to rollback an uninstalled resource.</p>"},{"location":"intro/using_helm/#helm-repo-working-with-repositories","title":"'helm repo': Working with Repositories","text":"<p>Helm 3 no longer ships with a default chart repository. The <code>helm repo</code> command group provides commands to add, list, and remove repositories.</p> <p>You can see which repositories are configured using <code>helm repo list</code>:</p> <pre><code>$ helm repo list\nNAME            URL\nstable          https://charts.helm.sh/stable\nmumoshu         https://mumoshu.github.io/charts\n</code></pre> <p>And new repositories can be added with <code>helm repo add [NAME] [URL]</code>:</p> <pre><code>$ helm repo add dev https://example.com/dev-charts\n</code></pre> <p>Because chart repositories change frequently, at any point you can make sure your Helm client is up to date by running <code>helm repo update</code>.</p> <p>Repositories can be removed with <code>helm repo remove</code>.</p>"},{"location":"intro/using_helm/#creating-your-own-charts","title":"Creating Your Own Charts","text":"<p>The Chart Development Guide explains how to develop your own charts. But you can get started quickly by using the <code>helm create</code> command:</p> <pre><code>$ helm create deis-workflow\nCreating deis-workflow\n</code></pre> <p>Now there is a chart in <code>./deis-workflow</code>. You can edit it and create your own templates.</p> <p>As you edit your chart, you can validate that it is well-formed by running <code>helm lint</code>.</p> <p>When it's time to package the chart up for distribution, you can run the <code>helm package</code> command:</p> <pre><code>$ helm package deis-workflow\ndeis-workflow-0.1.0.tgz\n</code></pre> <p>And that chart can now easily be installed by <code>helm install</code>:</p> <pre><code>$ helm install deis-workflow ./deis-workflow-0.1.0.tgz\n...\n</code></pre> <p>Charts that are packaged can be loaded into chart repositories. See the documentation for Helm chart repositories for more details.</p>"},{"location":"intro/using_helm/#conclusion","title":"Conclusion","text":"<p>This chapter has covered the basic usage patterns of the <code>helm</code> client, including searching, installation, upgrading, and uninstalling. It has also covered useful utility commands like <code>helm status</code>, <code>helm get</code>, and <code>helm repo</code>.</p> <p>For more information on these commands, take a look at Helm's built-in help: <code>helm help</code>.</p> <p>In the next chapter, we look at the process of developing charts.</p>"},{"location":"sdk/examples/","title":"Examples","text":"<p>This document runs though a series of examples of using the Helm SDK. Intended to document various SDK functionalities.</p> <p>The final example shows <code>main.go</code> driver (link). That runs the below actions and includes necessary helper functions.</p> <p>The code for the examples lives in the helm/helm-www/sdkexamples/ directory. And is intended to be fully functional.</p>"},{"location":"sdk/examples/#actions","title":"Actions","text":""},{"location":"sdk/examples/#install-action","title":"Install Action","text":"<p>This example installs the given chart/release, for the given version and values:</p> <p>{{&lt; highlightexamplego file=\"sdkexamples/install.go\" &gt;}}</p>"},{"location":"sdk/examples/#upgrade-action","title":"Upgrade Action","text":"<p>This example upgrades the given release, with the given chart, version and values:</p> <p>{{&lt; highlightexamplego file=\"sdkexamples/upgrade.go\" &gt;}}</p>"},{"location":"sdk/examples/#uninstall-action","title":"Uninstall Action","text":"<p>This example uninstalls the given release</p> <p>{{&lt; highlightexamplego file=\"sdkexamples/uninstall.go\" &gt;}}</p>"},{"location":"sdk/examples/#list-action","title":"List Action","text":"<p>This example lists all released charts (in the currently configured namespace)</p> <p>{{&lt; highlightexamplego file=\"sdkexamples/list.go\" &gt;}}</p>"},{"location":"sdk/examples/#pull-action","title":"Pull Action","text":"<p>This example pulls a chart from an OCI repository</p> <p>{{&lt; highlightexamplego file=\"sdkexamples/pull.go\" &gt;}}</p>"},{"location":"sdk/examples/#driver","title":"Driver","text":"<p>The driver here shows the necessary auxillary functions needed for the Helm SDK actions to function. And shows the above examples in action, to pull, install, update, and uninstall the 'podinfo' chart from an OCI repository.</p> <p>{{&lt; highlightexamplego file=\"sdkexamples/main.go\" &gt;}}</p>"},{"location":"sdk/gosdk/","title":"Introduction","text":"<p>Helm's Go SDK enables custom software to leverage Helm charts and Helm's functionality for managing Kubernetes software deployment (In fact, the Helm CLI is effectively just one such tool!)</p> <p>Currently, the SDK has been functionally separated from the Helm CLI. And the SDK can (and is) used by standalone tooling. The Helm project has committed to API stability for the SDK. As a warning, the SDK has some rough edges remaining from the initial work to separate the CLI and the SDK. Which the Helm project aims to improve and over time.</p> <p>Full API documentation can be found at https://pkg.go.dev/helm.sh/helm/v3.</p> <p>A brief overview of some of the main types of packages and a simple example follows below. See the Examples section for more examples and a more full featured 'driver'.</p>"},{"location":"sdk/gosdk/#main-package-overview","title":"Main package overview","text":"<ul> <li>pkg/action:   Contains the main \u201cclient\u201d for performing Helm actions.   This is the same package that the CLI is using underneath the hood.   If you just need to perform basic Helm commands from another Go program, this package is for you</li> <li>pkg/chart, pkg/chartutil:   Methods and helpers used for loading and manipulating charts</li> <li>pkg/cli and its subpackages:   Contains all the handlers for the standard Helm environment variables and its subpackages contain output and values file handling</li> <li>pkg/release:   Defines the <code>Release</code> object and statuses</li> </ul> <p>There are many more packages besides these, so go check out the documentation for more information!</p>"},{"location":"sdk/gosdk/#simple-example","title":"Simple example","text":"<p>This is a simple example of doing a <code>helm list</code> using the Go SDK. See the Examples section for more full featured examples.</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n\n    \"helm.sh/helm/v3/pkg/action\"\n    \"helm.sh/helm/v3/pkg/cli\"\n)\n\nfunc main() {\n    settings := cli.New()\n\n    actionConfig := new(action.Configuration)\n    // You can pass an empty string instead of settings.Namespace() to list\n    // all namespaces\n    if err := actionConfig.Init(settings.RESTClientGetter(), settings.Namespace(), os.Getenv(\"HELM_DRIVER\"), log.Printf); err != nil {\n        log.Printf(\"%+v\", err)\n        os.Exit(1)\n    }\n\n    client := action.NewList(actionConfig)\n    // Only list deployed\n    client.Deployed = true\n    results, err := client.Run()\n    if err != nil {\n        log.Printf(\"%+v\", err)\n        os.Exit(1)\n    }\n\n    for _, rel := range results {\n        log.Printf(\"%+v\", rel)\n    }\n}\n\n</code></pre>"},{"location":"sdk/gosdk/#compatibility","title":"Compatibility","text":"<p>The Helm SDK explicitly follows the Helm backwards compatibility guarantees:</p> <p>https://github.com/helm/community/blob/main/hips/hip-0004.md</p> <p>That is, break changes will only be made over major versions.</p>"},{"location":"topics/","title":"Topic Guides","text":"<p>Here you\u2019ll find introductions to all the key parts of Helm you\u2019ll need or want to know.</p>"},{"location":"topics/advanced/","title":"Advanced Helm Techniques","text":"<p>This section explains various advanced features and techniques for using Helm. The information in this section is intended for \"power users\" of Helm that wish to do advanced customization and manipulation of their charts and releases. Each of these advanced features comes with their own tradeoffs and caveats, so each one must be used carefully and with deep knowledge of Helm. Or in other words, remember the Peter Parker principle</p>"},{"location":"topics/advanced/#post-rendering","title":"Post Rendering","text":"<p>Post rendering gives chart installers the ability to manually manipulate, configure, and/or validate rendered manifests before they are installed by Helm. This allows users with advanced configuration needs to be able to use tools like <code>kustomize</code> to apply configuration changes without the need to fork a public chart or requiring chart maintainers to specify every last configuration option for a piece of software. There are also use cases for injecting common tools and side cars in enterprise environments or analysis of the manifests before deployment.</p>"},{"location":"topics/advanced/#prerequisites","title":"Prerequisites","text":"<ul> <li>Helm 3.1+</li> </ul>"},{"location":"topics/advanced/#usage","title":"Usage","text":"<p>A post-renderer can be any executable that accepts rendered Kubernetes manifests on STDIN and returns valid Kubernetes manifests on STDOUT. It should return an non-0 exit code in the event of a failure. This is the only \"API\" between the two components. It allows for great flexibility in what you can do with your post-render process.</p> <p>A post renderer can be used with <code>install</code>, <code>upgrade</code>, and <code>template</code>. To use a post-renderer, use the <code>--post-renderer</code> flag with a path to the renderer executable you wish to use:</p> <pre><code>$ helm install mychart stable/wordpress --post-renderer ./path/to/executable\n</code></pre> <p>If the path does not contain any separators, it will search in $PATH, otherwise it will resolve any relative paths to a fully qualified path</p> <p>If you wish to use multiple post-renderers, call all of them in a script or together in whatever binary tool you have built. In bash, this would be as simple as <code>renderer1 | renderer2 | renderer3</code>.</p> <p>You can see an example of using <code>kustomize</code> as a post renderer here.</p>"},{"location":"topics/advanced/#caveats","title":"Caveats","text":"<p>When using post renderers, there are several important things to keep in mind. The most important of these is that when using a post-renderer, all people modifying that release MUST use the same renderer in order to have repeatable builds. This feature is purposefully built to allow any user to switch out which renderer they are using or to stop using a renderer, but this should be done deliberately to avoid accidental modification or data loss.</p> <p>One other important note is around security. If you are using a post-renderer, you should ensure it is coming from a reliable source (as is the case for any other arbitrary executable). Using non-trusted or non-verified renderers is NOT recommended as they have full access to rendered templates, which often contain secret data.</p>"},{"location":"topics/advanced/#custom-post-renderers","title":"Custom Post Renderers","text":"<p>The post render step offers even more flexibility when used in the Go SDK. Any post renderer only needs to implement the following Go interface:</p> <pre><code>type PostRenderer interface {\n    // Run expects a single buffer filled with Helm rendered manifests. It\n    // expects the modified results to be returned on a separate buffer or an\n    // error if there was an issue or failure while running the post render step\n    Run(renderedManifests *bytes.Buffer) (modifiedManifests *bytes.Buffer, err error)\n}\n</code></pre> <p>For more information on using the Go SDK, See the Go SDK section</p>"},{"location":"topics/advanced/#go-sdk","title":"Go SDK","text":"<p>Helm 3 debuted a completely restructured Go SDK for a better experience when building software and tools that leverage Helm. Full documentation can be found in the Go SDK Section.</p>"},{"location":"topics/advanced/#storage-backends","title":"Storage backends","text":"<p>Helm 3 changed the default release information storage to Secrets in the namespace of the release. Helm 2 by default stores release information as ConfigMaps in the namespace of the Tiller instance. The subsections which follow show how to configure different backends. This configuration is based on the <code>HELM_DRIVER</code> environment variable. It can be set to one of the values: <code>[configmap, secret, sql]</code>.</p>"},{"location":"topics/advanced/#configmap-storage-backend","title":"ConfigMap storage backend","text":"<p>To enable the ConfigMap backend, you'll need to set the environmental variable <code>HELM_DRIVER</code> to <code>configmap</code>.</p> <p>You can set it in a shell as follows:</p> <pre><code>export HELM_DRIVER=configmap\n</code></pre> <p>If you want to switch from the default backend to the ConfigMap backend, you'll have to do the migration for this on your own. You can retrieve release information with the following command:</p> <pre><code>kubectl get secret --all-namespaces -l \"owner=helm\"\n</code></pre> <p>PRODUCTION NOTES: The release information includes the contents of charts and values files, and therefore might contain sensitive data (like passwords, private keys, and other credentials) that needs to be protected from unauthorized access. When managing Kubernetes authorization, for instance with RBAC, it is possible to grant broader access to ConfigMap resources, while restricting access to Secret resources. For instance, the default user-facing role \"view\" grants access to most resources, but not to Secrets. Furthermore, secrets data can be configured for encrypted storage. Please keep that in mind if you decide to switch to the ConfigMap backend, as it could expose your application's sensitive data.</p>"},{"location":"topics/advanced/#sql-storage-backend","title":"SQL storage backend","text":"<p>There is a beta SQL storage backend that stores release information in an SQL database.</p> <p>Using such a storage backend is particularly useful if your release information weighs more than 1MB (in which case, it can't be stored in ConfigMaps/Secrets because of internal limits in Kubernetes' underlying etcd key-value store).</p> <p>To enable the SQL backend, you'll need to deploy a SQL database and set the environmental variable <code>HELM_DRIVER</code> to <code>sql</code>. The DB details are set with the environmental variable <code>HELM_DRIVER_SQL_CONNECTION_STRING</code>.</p> <p>You can set it in a shell as follows:</p> <pre><code>export HELM_DRIVER=sql\nexport HELM_DRIVER_SQL_CONNECTION_STRING=postgresql://helm-postgres:5432/helm?user=helm&amp;password=changeme\n</code></pre> <p>Note: Only PostgreSQL is supported at this moment.</p> <p>PRODUCTION NOTES: It is recommended to: - Make your database production ready. For PostgreSQL, refer to the Server Administration docs for more details - Enable permission management to mirror Kubernetes RBAC for release information</p> <p>If you want to switch from the default backend to the SQL backend, you'll have to do the migration for this on your own. You can retrieve release information with the following command:</p> <pre><code>kubectl get secret --all-namespaces -l \"owner=helm\"\n</code></pre>"},{"location":"topics/architecture/","title":"Helm Architecture","text":"<p>This document describes the Helm architecture at a high level.</p>"},{"location":"topics/architecture/#the-purpose-of-helm","title":"The Purpose of Helm","text":"<p>Helm is a tool for managing Kubernetes packages called charts. Helm can do the following:</p> <ul> <li>Create new charts from scratch</li> <li>Package charts into chart archive (tgz) files</li> <li>Interact with chart repositories where charts are stored</li> <li>Install and uninstall charts into an existing Kubernetes cluster</li> <li>Manage the release cycle of charts that have been installed with Helm</li> </ul> <p>For Helm, there are three important concepts:</p> <ol> <li>The chart is a bundle of information necessary to create an instance of a    Kubernetes application.</li> <li>The config contains configuration information that can be merged into a    packaged chart to create a releasable object.</li> <li>A release is a running instance of a chart, combined with a specific    config.</li> </ol>"},{"location":"topics/architecture/#components","title":"Components","text":"<p>Helm is an executable which is implemented into two distinct parts:</p> <p>The Helm Client is a command-line client for end users. The client is responsible for the following:</p> <ul> <li>Local chart development</li> <li>Managing repositories</li> <li>Managing releases</li> <li>Interfacing with the Helm library</li> <li>Sending charts to be installed</li> <li>Requesting upgrading or uninstalling of existing releases</li> </ul> <p>The Helm Library provides the logic for executing all Helm operations. It interfaces with the Kubernetes API server and provides the following capability:</p> <ul> <li>Combining a chart and configuration to build a release</li> <li>Installing charts into Kubernetes, and providing the subsequent release object</li> <li>Upgrading and uninstalling charts by interacting with Kubernetes</li> </ul> <p>The standalone Helm library encapsulates the Helm logic so that it can be leveraged by different clients.</p>"},{"location":"topics/architecture/#implementation","title":"Implementation","text":"<p>The Helm client and library is written in the Go programming language.</p> <p>The library uses the Kubernetes client library to communicate with Kubernetes. Currently, that library uses REST+JSON. It stores information in Secrets located inside of Kubernetes. It does not need its own database.</p> <p>Configuration files are, when possible, written in YAML.</p>"},{"location":"topics/chart_repository/","title":"The Chart Repository Guide","text":"<p>This section explains how to create and work with Helm chart repositories. At a high level, a chart repository is a location where packaged charts can be stored and shared.</p> <p>The distributed community Helm chart repository is located at Artifact Hub and welcomes participation. But Helm also makes it possible to create and run your own chart repository. This guide explains how to do so. If you are considering creating a chart repository, you may want to consider using an OCI registry instead.</p>"},{"location":"topics/chart_repository/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go through the Quickstart Guide</li> <li>Read through the Charts document</li> </ul>"},{"location":"topics/chart_repository/#create-a-chart-repository","title":"Create a chart repository","text":"<p>A chart repository is an HTTP server that houses an <code>index.yaml</code> file and optionally some packaged charts.  When you're ready to share your charts, the preferred way to do so is by uploading them to a chart repository.</p> <p>As of Helm 2.2.0, client-side SSL auth to a repository is supported. Other authentication protocols may be available as plugins.</p> <p>Because a chart repository can be any HTTP server that can serve YAML and tar files and can answer GET requests, you have a plethora of options when it comes down to hosting your own chart repository. For example, you can use a Google Cloud Storage (GCS) bucket, Amazon S3 bucket, GitHub Pages, or even create your own web server.</p>"},{"location":"topics/chart_repository/#the-chart-repository-structure","title":"The chart repository structure","text":"<p>A chart repository consists of packaged charts and a special file called <code>index.yaml</code> which contains an index of all of the charts in the repository. Frequently, the charts that <code>index.yaml</code> describes are also hosted on the same server, as are the provenance files.</p> <p>For example, the layout of the repository <code>https://example.com/charts</code> might look like this:</p> <pre><code>charts/\n  |\n  |- index.yaml\n  |\n  |- alpine-0.1.2.tgz\n  |\n  |- alpine-0.1.2.tgz.prov\n</code></pre> <p>In this case, the index file would contain information about one chart, the Alpine chart, and provide the download URL <code>https://example.com/charts/alpine-0.1.2.tgz</code> for that chart.</p> <p>It is not required that a chart package be located on the same server as the <code>index.yaml</code> file. However, doing so is often the easiest.</p>"},{"location":"topics/chart_repository/#the-index-file","title":"The index file","text":"<p>The index file is a yaml file called <code>index.yaml</code>. It contains some metadata about the package, including the contents of a chart's <code>Chart.yaml</code> file. A valid chart repository must have an index file. The index file contains information about each chart in the chart repository. The <code>helm repo index</code> command will generate an index file based on a given local directory that contains packaged charts.</p> <p>This is an example of an index file:</p> <pre><code>apiVersion: v1\nentries:\n  alpine:\n    - created: 2016-10-06T16:23:20.499814565-06:00\n      description: Deploy a basic Alpine Linux pod\n      digest: 99c76e403d752c84ead610644d4b1c2f2b453a74b921f422b9dcb8a7c8b559cd\n      home: https://helm.sh/helm\n      name: alpine\n      sources:\n      - https://github.com/helm/helm\n      urls:\n      - https://technosophos.github.io/tscharts/alpine-0.2.0.tgz\n      version: 0.2.0\n    - created: 2016-10-06T16:23:20.499543808-06:00\n      description: Deploy a basic Alpine Linux pod\n      digest: 515c58e5f79d8b2913a10cb400ebb6fa9c77fe813287afbacf1a0b897cd78727\n      home: https://helm.sh/helm\n      name: alpine\n      sources:\n      - https://github.com/helm/helm\n      urls:\n      - https://technosophos.github.io/tscharts/alpine-0.1.0.tgz\n      version: 0.1.0\n  nginx:\n    - created: 2016-10-06T16:23:20.499543808-06:00\n      description: Create a basic nginx HTTP server\n      digest: aaff4545f79d8b2913a10cb400ebb6fa9c77fe813287afbacf1a0b897cdffffff\n      home: https://helm.sh/helm\n      name: nginx\n      sources:\n      - https://github.com/helm/charts\n      urls:\n      - https://technosophos.github.io/tscharts/nginx-1.1.0.tgz\n      version: 1.1.0\ngenerated: 2016-10-06T16:23:20.499029981-06:00\n</code></pre>"},{"location":"topics/chart_repository/#hosting-chart-repositories","title":"Hosting Chart Repositories","text":"<p>This part shows several ways to serve a chart repository.</p>"},{"location":"topics/chart_repository/#google-cloud-storage","title":"Google Cloud Storage","text":"<p>The first step is to create your GCS bucket. We'll call ours <code>fantastic-charts</code>.</p> <p></p> <p>Next, make your bucket public by editing the bucket permissions.</p> <p></p> <p>Insert this line item to make your bucket public:</p> <p></p> <p>Congratulations, now you have an empty GCS bucket ready to serve charts!</p> <p>You may upload your chart repository using the Google Cloud Storage command line tool, or using the GCS web UI. A public GCS bucket can be accessed via simple HTTPS at this address: <code>https://bucket-name.storage.googleapis.com/</code>.</p>"},{"location":"topics/chart_repository/#cloudsmith","title":"Cloudsmith","text":"<p>You can also set up chart repositories using Cloudsmith. Read more about chart repositories with Cloudsmith here</p>"},{"location":"topics/chart_repository/#jfrog-artifactory","title":"JFrog Artifactory","text":"<p>Similarly, you can also set up chart repositories using JFrog Artifactory. Read more about chart repositories with JFrog Artifactory here</p>"},{"location":"topics/chart_repository/#github-pages-example","title":"GitHub Pages example","text":"<p>In a similar way you can create charts repository using GitHub Pages.</p> <p>GitHub allows you to serve static web pages in two different ways:</p> <ul> <li>By configuring a project to serve the contents of its <code>docs/</code> directory</li> <li>By configuring a project to serve a particular branch</li> </ul> <p>We'll take the second approach, though the first is just as easy.</p> <p>The first step will be to create your gh-pages branch.  You can do that locally as.</p> <pre><code>$ git checkout -b gh-pages\n</code></pre> <p>Or via web browser using Branch button on your GitHub repository:</p> <p></p> <p>Next, you'll want to make sure your gh-pages branch is set as GitHub Pages, click on your repo Settings and scroll down to GitHub pages section and set as per below:</p> <p></p> <p>By default Source usually gets set to gh-pages branch. If this is not set by default, then select it.</p> <p>You can use a custom domain there if you wish so.</p> <p>And check that Enforce HTTPS is ticked, so the HTTPS will be used when charts are served.</p> <p>In such setup you can use your default branch to store your charts code, and gh-pages branch as charts repository, e.g.: <code>https://USERNAME.github.io/REPONAME</code>. The demonstration TS Charts repository is accessible at <code>https://technosophos.github.io/tscharts/</code>.</p> <p>If you have decided to use GitHub pages to host the chart repository, check out Chart Releaser Action. Chart Releaser Action is a GitHub Action workflow to turn a GitHub project into a self-hosted Helm chart repo, using helm/chart-releaser CLI tool.</p>"},{"location":"topics/chart_repository/#ordinary-web-servers","title":"Ordinary web servers","text":"<p>To configure an ordinary web server to serve Helm charts, you merely need to do the following:</p> <ul> <li>Put your index and charts in a directory that the server can serve</li> <li>Make sure the <code>index.yaml</code> file can be accessed with no authentication   requirement</li> <li>Make sure <code>yaml</code> files are served with the correct content type (<code>text/yaml</code>   or <code>text/x-yaml</code>)</li> </ul> <p>For example, if you want to serve your charts out of <code>$WEBROOT/charts</code>, make sure there is a <code>charts/</code> directory in your web root, and put the index file and charts inside of that folder.</p>"},{"location":"topics/chart_repository/#chartmuseum-repository-server","title":"ChartMuseum Repository Server","text":"<p>ChartMuseum is an open-source Helm Chart Repository server written in Go (Golang), with support for cloud storage backends, including Google Cloud Storage, Amazon S3, Microsoft Azure Blob Storage, Alibaba Cloud OSS Storage, Openstack Object Storage, Oracle Cloud Infrastructure Object Storage, Baidu Cloud BOS Storage, Tencent Cloud Object Storage, DigitalOcean Spaces, Minio, and etcd.</p> <p>You can also use the ChartMuseum server to host a chart repository from a local file system.</p>"},{"location":"topics/chart_repository/#gitlab-package-registry","title":"GitLab Package Registry","text":"<p>With GitLab you can publish Helm charts in your project\u2019s Package Registry. Read more about setting up a helm package repository with GitLab here.</p>"},{"location":"topics/chart_repository/#managing-chart-repositories","title":"Managing Chart Repositories","text":"<p>Now that you have a chart repository, the last part of this guide explains how to maintain charts in that repository.</p>"},{"location":"topics/chart_repository/#store-charts-in-your-chart-repository","title":"Store charts in your chart repository","text":"<p>Now that you have a chart repository, let's upload a chart and an index file to the repository.  Charts in a chart repository must be packaged (<code>helm package chart-name/</code>) and versioned correctly (following SemVer 2 guidelines).</p> <p>These next steps compose an example workflow, but you are welcome to use whatever workflow you fancy for storing and updating charts in your chart repository.</p> <p>Once you have a packaged chart ready, create a new directory, and move your packaged chart to that directory.</p> <pre><code>$ helm package docs/examples/alpine/\n$ mkdir fantastic-charts\n$ mv alpine-0.1.0.tgz fantastic-charts/\n$ helm repo index fantastic-charts --url https://fantastic-charts.storage.googleapis.com\n</code></pre> <p>The last command takes the path of the local directory that you just created and the URL of your remote chart repository and composes an <code>index.yaml</code> file inside the given directory path.</p> <p>Now you can upload the chart and the index file to your chart repository using a sync tool or manually. If you're using Google Cloud Storage, check out this example workflow using the gsutil client. For GitHub, you can simply put the charts in the appropriate destination branch.</p>"},{"location":"topics/chart_repository/#add-new-charts-to-an-existing-repository","title":"Add new charts to an existing repository","text":"<p>Each time you want to add a new chart to your repository, you must regenerate the index. The <code>helm repo index</code> command will completely rebuild the <code>index.yaml</code> file from scratch, including only the charts that it finds locally.</p> <p>However, you can use the <code>--merge</code> flag to incrementally add new charts to an existing <code>index.yaml</code> file (a great option when working with a remote repository like GCS). Run <code>helm repo index --help</code> to learn more,</p> <p>Make sure that you upload both the revised <code>index.yaml</code> file and the chart. And if you generated a provenance file, upload that too.</p>"},{"location":"topics/chart_repository/#share-your-charts-with-others","title":"Share your charts with others","text":"<p>When you're ready to share your charts, simply let someone know what the URL of your repository is.</p> <p>From there, they will add the repository to their helm client via the <code>helm repo add [NAME] [URL]</code> command with any name they would like to use to reference the repository.</p> <pre><code>$ helm repo add fantastic-charts https://fantastic-charts.storage.googleapis.com\n$ helm repo list\nfantastic-charts    https://fantastic-charts.storage.googleapis.com\n</code></pre> <p>If the charts are backed by HTTP basic authentication, you can also supply the username and password here:</p> <pre><code>$ helm repo add fantastic-charts https://fantastic-charts.storage.googleapis.com --username my-username --password my-password\n$ helm repo list\nfantastic-charts    https://fantastic-charts.storage.googleapis.com\n</code></pre> <p>Note: A repository will not be added if it does not contain a valid <code>index.yaml</code>.</p> <p>Note: If your helm repository is e.g. using a self signed certificate, you can use <code>helm repo add --insecure-skip-tls-verify ...</code> in order to skip the CA verification.</p> <p>After that, your users will be able to search through your charts. After you've updated the repository, they can use the <code>helm repo update</code> command to get the latest chart information.</p> <p>Under the hood, the <code>helm repo add</code> and <code>helm repo update</code> commands are fetching the index.yaml file and storing them in the <code>$XDG_CACHE_HOME/helm/repository/cache/</code> directory. This is where the <code>helm search</code> function finds information about charts.</p>"},{"location":"topics/chart_tests/","title":"Chart Tests","text":"<p>A chart contains a number of Kubernetes resources and components that work together. As a chart author, you may want to write some tests that validate that your chart works as expected when it is installed. These tests also help the chart consumer understand what your chart is supposed to do.</p> <p>A test in a helm chart lives under the <code>templates/</code> directory and is a job definition that specifies a container with a given command to run. The container should exit successfully (exit 0) for a test to be considered a success. The job definition must contain the helm test hook annotation: <code>helm.sh/hook: test</code>.</p> <p>Note that until Helm v3, the job definition needed to contain one of these helm test hook annotations: <code>helm.sh/hook: test-success</code> or <code>helm.sh/hook: test-failure</code>. <code>helm.sh/hook: test-success</code> is still accepted as a backwards-compatible alternative to <code>helm.sh/hook: test</code>.</p> <p>Example tests:</p> <ul> <li>Validate that your configuration from the values.yaml file was properly   injected.</li> <li>Make sure your username and password work correctly</li> <li>Make sure an incorrect username and password does not work</li> <li>Assert that your services are up and correctly load balancing</li> <li>etc.</li> </ul> <p>You can run the pre-defined tests in Helm on a release using the command <code>helm test &lt;RELEASE_NAME&gt;</code>. For a chart consumer, this is a great way to check that their release of a chart (or application) works as expected.</p>"},{"location":"topics/chart_tests/#example-test","title":"Example Test","text":"<p>The helm create command will automatically create a number of folders and files. To try the helm test functionality, first create a demo helm chart. </p> <pre><code>$ helm create demo\n</code></pre> <p>You will now be able to see the following structure in your demo helm chart.</p> <pre><code>demo/\n  Chart.yaml\n  values.yaml\n  charts/\n  templates/\n  templates/tests/test-connection.yaml\n</code></pre> <p>In <code>demo/templates/tests/test-connection.yaml</code> you'll see a test you can try. You can see the helm test pod definition here:</p> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: \"{{ include \"demo.fullname\" . }}-test-connection\"\n  labels:\n    {{- include \"demo.labels\" . | nindent 4 }}\n  annotations:\n    \"helm.sh/hook\": test\nspec:\n  containers:\n    - name: wget\n      image: busybox\n      command: ['wget']\n      args: ['{{ include \"demo.fullname\" . }}:{{ .Values.service.port }}']\n  restartPolicy: Never\n\n</code></pre>"},{"location":"topics/chart_tests/#steps-to-run-a-test-suite-on-a-release","title":"Steps to Run a Test Suite on a Release","text":"<p>First, install the chart on your cluster to create a release. You may have to wait for all pods to become active; if you test immediately after this install, it is likely to show a transitive failure, and you will want to re-test.</p> <pre><code>$ helm install demo demo --namespace default\n$ helm test demo\nNAME: demo\nLAST DEPLOYED: Mon Feb 14 20:03:16 2022\nNAMESPACE: default\nSTATUS: deployed\nREVISION: 1\nTEST SUITE:     demo-test-connection\nLast Started:   Mon Feb 14 20:35:19 2022\nLast Completed: Mon Feb 14 20:35:23 2022\nPhase:          Succeeded\n[...]\n</code></pre>"},{"location":"topics/chart_tests/#notes","title":"Notes","text":"<ul> <li>You can define as many tests as you would like in a single yaml file or spread   across several yaml files in the <code>templates/</code> directory.</li> <li>You are welcome to nest your test suite under a <code>tests/</code> directory like   <code>&lt;chart-name&gt;/templates/tests/</code> for more isolation.</li> <li>A test is a Helm hook, so annotations like   <code>helm.sh/hook-weight</code> and <code>helm.sh/hook-delete-policy</code> may be used with test   resources.</li> </ul>"},{"location":"topics/charts/","title":"Charts","text":"<p>Helm uses a packaging format called charts. A chart is a collection of files that describe a related set of Kubernetes resources. A single chart might be used to deploy something simple, like a memcached pod, or something complex, like a full web app stack with HTTP servers, databases, caches, and so on.</p> <p>Charts are created as files laid out in a particular directory tree. They can be packaged into versioned archives to be deployed.</p> <p>If you want to download and look at the files for a published chart, without installing it, you can do so with <code>helm pull chartrepo/chartname</code>.</p> <p>This document explains the chart format, and provides basic guidance for building charts with Helm.</p>"},{"location":"topics/charts/#the-chart-file-structure","title":"The Chart File Structure","text":"<p>A chart is organized as a collection of files inside of a directory. The directory name is the name of the chart (without versioning information). Thus, a chart describing WordPress would be stored in a <code>wordpress/</code> directory.</p> <p>Inside of this directory, Helm will expect a structure that matches this:</p> <pre><code>wordpress/\n  Chart.yaml          # A YAML file containing information about the chart\n  LICENSE             # OPTIONAL: A plain text file containing the license for the chart\n  README.md           # OPTIONAL: A human-readable README file\n  values.yaml         # The default configuration values for this chart\n  values.schema.json  # OPTIONAL: A JSON Schema for imposing a structure on the values.yaml file\n  charts/             # A directory containing any charts upon which this chart depends.\n  crds/               # Custom Resource Definitions\n  templates/          # A directory of templates that, when combined with values,\n                      # will generate valid Kubernetes manifest files.\n  templates/NOTES.txt # OPTIONAL: A plain text file containing short usage notes\n</code></pre> <p>Helm reserves use of the <code>charts/</code>, <code>crds/</code>, and <code>templates/</code> directories, and of the listed file names. Other files will be left as they are.</p>"},{"location":"topics/charts/#the-chartyaml-file","title":"The Chart.yaml File","text":"<p>The <code>Chart.yaml</code> file is required for a chart. It contains the following fields:</p> <pre><code>apiVersion: The chart API version (required)\nname: The name of the chart (required)\nversion: A SemVer 2 version (required)\nkubeVersion: A SemVer range of compatible Kubernetes versions (optional)\ndescription: A single-sentence description of this project (optional)\ntype: The type of the chart (optional)\nkeywords:\n  - A list of keywords about this project (optional)\nhome: The URL of this projects home page (optional)\nsources:\n  - A list of URLs to source code for this project (optional)\ndependencies: # A list of the chart requirements (optional)\n  - name: The name of the chart (nginx)\n    version: The version of the chart (\"1.2.3\")\n    repository: (optional) The repository URL (\"https://example.com/charts\") or alias (\"@repo-name\")\n    condition: (optional) A yaml path that resolves to a boolean, used for enabling/disabling charts (e.g. subchart1.enabled )\n    tags: # (optional)\n      - Tags can be used to group charts for enabling/disabling together\n    import-values: # (optional)\n      - ImportValues holds the mapping of source values to parent key to be imported. Each item can be a string or pair of child/parent sublist items.\n    alias: (optional) Alias to be used for the chart. Useful when you have to add the same chart multiple times\nmaintainers: # (optional)\n  - name: The maintainers name (required for each maintainer)\n    email: The maintainers email (optional for each maintainer)\n    url: A URL for the maintainer (optional for each maintainer)\nicon: A URL to an SVG or PNG image to be used as an icon (optional).\nappVersion: The version of the app that this contains (optional). Needn't be SemVer. Quotes recommended.\ndeprecated: Whether this chart is deprecated (optional, boolean)\nannotations:\n  example: A list of annotations keyed by name (optional).\n</code></pre> <p>As of v3.3.2, additional fields are not allowed. The recommended approach is to add custom metadata in <code>annotations</code>.</p>"},{"location":"topics/charts/#charts-and-versioning","title":"Charts and Versioning","text":"<p>Every chart must have a version number. A version must follow the SemVer 2 standard. Unlike Helm Classic, Helm v2 and later uses version numbers as release markers. Packages in repositories are identified by name plus version.</p> <p>For example, an <code>nginx</code> chart whose version field is set to <code>version: 1.2.3</code> will be named:</p> <pre><code>nginx-1.2.3.tgz\n</code></pre> <p>More complex SemVer 2 names are also supported, such as <code>version: 1.2.3-alpha.1+ef365</code>. But non-SemVer names are explicitly disallowed by the system.</p> <p>NOTE: Whereas Helm Classic and Deployment Manager were both very GitHub oriented when it came to charts, Helm v2 and later does not rely upon or require GitHub or even Git. Consequently, it does not use Git SHAs for versioning at all.</p> <p>The <code>version</code> field inside of the <code>Chart.yaml</code> is used by many of the Helm tools, including the CLI. When generating a package, the <code>helm package</code> command will use the version that it finds in the <code>Chart.yaml</code> as a token in the package name. The system assumes that the version number in the chart package name matches the version number in the <code>Chart.yaml</code>. Failure to meet this assumption will cause an error.</p>"},{"location":"topics/charts/#the-apiversion-field","title":"The <code>apiVersion</code> Field","text":"<p>The <code>apiVersion</code> field should be <code>v2</code> for Helm charts that require at least Helm 3. Charts supporting previous Helm versions have an <code>apiVersion</code> set to <code>v1</code> and are still installable by Helm 3.</p> <p>Changes from <code>v1</code> to <code>v2</code>:</p> <ul> <li>A <code>dependencies</code> field defining chart dependencies, which were located in a   separate <code>requirements.yaml</code> file for <code>v1</code> charts (see Chart   Dependencies).</li> <li>The <code>type</code> field, discriminating application and library charts (see Chart   Types).</li> </ul>"},{"location":"topics/charts/#the-appversion-field","title":"The <code>appVersion</code> Field","text":"<p>Note that the <code>appVersion</code> field is not related to the <code>version</code> field. It is a way of specifying the version of the application. For example, the <code>drupal</code> chart may have an <code>appVersion: \"8.2.1\"</code>, indicating that the version of Drupal included in the chart (by default) is <code>8.2.1</code>. This field is informational, and has no impact on chart version calculations. Wrapping the version in quotes is highly recommended. It forces the YAML parser to treat the version number as a string. Leaving it unquoted can lead to parsing issues in some cases. For example, YAML interprets <code>1.0</code> as a floating point value, and a git commit SHA like <code>1234e10</code> as scientific notation.</p> <p>As of Helm v3.5.0, <code>helm create</code> wraps the default <code>appVersion</code> field in quotes.</p>"},{"location":"topics/charts/#the-kubeversion-field","title":"The <code>kubeVersion</code> Field","text":"<p>The optional <code>kubeVersion</code> field can define semver constraints on supported Kubernetes versions. Helm will validate the version constraints when installing the chart and fail if the cluster runs an unsupported Kubernetes version.</p> <p>Version constraints may comprise space separated AND comparisons such as</p> <pre><code>&gt;= 1.13.0 &lt; 1.15.0\n</code></pre> <p>which themselves can be combined with the OR <code>||</code> operator like in the following example</p> <pre><code>&gt;= 1.13.0 &lt; 1.14.0 || &gt;= 1.14.1 &lt; 1.15.0\n</code></pre> <p>In this example the version <code>1.14.0</code> is excluded, which can make sense if a bug in certain versions is known to prevent the chart from running properly.</p> <p>Apart from version constrains employing operators <code>=</code> <code>!=</code> <code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code> the following shorthand notations are supported</p> <ul> <li>hyphen ranges for closed intervals, where <code>1.1 - 2.3.4</code> is equivalent to <code>&gt;=    1.1 &lt;= 2.3.4</code>.</li> <li>wildcards <code>x</code>, <code>X</code> and <code>*</code>, where <code>1.2.x</code> is equivalent to <code>&gt;= 1.2.0 &lt;    1.3.0</code>.</li> <li>tilde ranges (patch version changes allowed), where <code>~1.2.3</code> is equivalent to    <code>&gt;= 1.2.3 &lt; 1.3.0</code>.</li> <li>caret ranges (minor version changes allowed), where <code>^1.2.3</code> is equivalent to    <code>&gt;= 1.2.3 &lt; 2.0.0</code>.</li> </ul> <p>For a detailed explanation of supported semver constraints see Masterminds/semver.</p>"},{"location":"topics/charts/#deprecating-charts","title":"Deprecating Charts","text":"<p>When managing charts in a Chart Repository, it is sometimes necessary to deprecate a chart. The optional <code>deprecated</code> field in <code>Chart.yaml</code> can be used to mark a chart as deprecated. If the latest version of a chart in the repository is marked as deprecated, then the chart as a whole is considered to be deprecated. The chart name can be later reused by publishing a newer version that is not marked as deprecated. The workflow for deprecating charts is:</p> <ol> <li>Update chart's <code>Chart.yaml</code> to mark the chart as deprecated, bumping the    version</li> <li>Release the new chart version in the Chart Repository</li> <li>Remove the chart from the source repository (e.g. git)</li> </ol>"},{"location":"topics/charts/#chart-types","title":"Chart Types","text":"<p>The <code>type</code> field defines the type of chart. There are two types: <code>application</code> and <code>library</code>. Application is the default type and it is the standard chart which can be operated on fully. The library chart provides utilities or functions for the chart builder. A library chart differs from an application chart because it is not installable and usually doesn't contain any resource objects.</p> <p>Note: An application chart can be used as a library chart. This is enabled by setting the type to <code>library</code>. The chart will then be rendered as a library chart where all utilities and functions can be leveraged. All resource objects of the chart will not be rendered.</p>"},{"location":"topics/charts/#chart-license-readme-and-notes","title":"Chart LICENSE, README and NOTES","text":"<p>Charts can also contain files that describe the installation, configuration, usage and license of a chart.</p> <p>A LICENSE is a plain text file containing the license for the chart. The chart can contain a license as it may have programming logic in the templates and would therefore not be configuration only. There can also be separate license(s) for the application installed by the chart, if required.</p> <p>A README for a chart should be formatted in Markdown (README.md), and should generally contain:</p> <ul> <li>A description of the application or service the chart provides</li> <li>Any prerequisites or requirements to run the chart</li> <li>Descriptions of options in <code>values.yaml</code> and default values</li> <li>Any other information that may be relevant to the installation or   configuration of the chart</li> </ul> <p>When hubs and other user interfaces display details about a chart that detail is pulled from the content in the <code>README.md</code> file.</p> <p>The chart can also contain a short plain text <code>templates/NOTES.txt</code> file that will be printed out after installation, and when viewing the status of a release. This file is evaluated as a template, and can be used to display usage notes, next steps, or any other information relevant to a release of the chart. For example, instructions could be provided for connecting to a database, or accessing a web UI. Since this file is printed to STDOUT when running <code>helm install</code> or <code>helm status</code>, it is recommended to keep the content brief and point to the README for greater detail.</p>"},{"location":"topics/charts/#chart-dependencies","title":"Chart Dependencies","text":"<p>In Helm, one chart may depend on any number of other charts. These dependencies can be dynamically linked using the <code>dependencies</code> field in <code>Chart.yaml</code> or brought in to the <code>charts/</code> directory and managed manually.</p>"},{"location":"topics/charts/#managing-dependencies-with-the-dependencies-field","title":"Managing Dependencies with the <code>dependencies</code> field","text":"<p>The charts required by the current chart are defined as a list in the <code>dependencies</code> field.</p> <pre><code>dependencies:\n  - name: apache\n    version: 1.2.3\n    repository: https://example.com/charts\n  - name: mysql\n    version: 3.2.1\n    repository: https://another.example.com/charts\n</code></pre> <ul> <li>The <code>name</code> field is the name of the chart you want.</li> <li>The <code>version</code> field is the version of the chart you want.</li> <li>The <code>repository</code> field is the full URL to the chart repository. Note that you   must also use <code>helm repo add</code> to add that repo locally.</li> <li>You might use the name of the repo instead of URL</li> </ul> <pre><code>$ helm repo add fantastic-charts https://charts.helm.sh/incubator\n</code></pre> <pre><code>dependencies:\n  - name: awesomeness\n    version: 1.0.0\n    repository: \"@fantastic-charts\"\n</code></pre> <p>Once you have defined dependencies, you can run <code>helm dependency update</code> and it will use your dependency file to download all the specified charts into your <code>charts/</code> directory for you.</p> <pre><code>$ helm dep up foochart\nHang tight while we grab the latest from your chart repositories...\n...Successfully got an update from the \"local\" chart repository\n...Successfully got an update from the \"stable\" chart repository\n...Successfully got an update from the \"example\" chart repository\n...Successfully got an update from the \"another\" chart repository\nUpdate Complete. Happy Helming!\nSaving 2 charts\nDownloading apache from repo https://example.com/charts\nDownloading mysql from repo https://another.example.com/charts\n</code></pre> <p>When <code>helm dependency update</code> retrieves charts, it will store them as chart archives in the <code>charts/</code> directory. So for the example above, one would expect to see the following files in the charts directory:</p> <pre><code>charts/\n  apache-1.2.3.tgz\n  mysql-3.2.1.tgz\n</code></pre>"},{"location":"topics/charts/#alias-field-in-dependencies","title":"Alias field in dependencies","text":"<p>In addition to the other fields above, each requirements entry may contain the optional field <code>alias</code>.</p> <p>Adding an alias for a dependency chart would put a chart in dependencies using alias as name of new dependency.</p> <p>One can use <code>alias</code> in cases where they need to access a chart with other name(s).</p> <pre><code># parentchart/Chart.yaml\n\ndependencies:\n  - name: subchart\n    repository: http://localhost:10191\n    version: 0.1.0\n    alias: new-subchart-1\n  - name: subchart\n    repository: http://localhost:10191\n    version: 0.1.0\n    alias: new-subchart-2\n  - name: subchart\n    repository: http://localhost:10191\n    version: 0.1.0\n</code></pre> <p>In the above example we will get 3 dependencies in all for <code>parentchart</code>:</p> <pre><code>subchart\nnew-subchart-1\nnew-subchart-2\n</code></pre> <p>The manual way of achieving this is by copy/pasting the same chart in the <code>charts/</code> directory multiple times with different names.</p>"},{"location":"topics/charts/#tags-and-condition-fields-in-dependencies","title":"Tags and Condition fields in dependencies","text":"<p>In addition to the other fields above, each requirements entry may contain the optional fields <code>tags</code> and <code>condition</code>.</p> <p>All charts are loaded by default. If <code>tags</code> or <code>condition</code> fields are present, they will be evaluated and used to control loading for the chart(s) they are applied to.</p> <p>Condition - The condition field holds one or more YAML paths (delimited by commas). If this path exists in the top parent's values and resolves to a boolean value, the chart will be enabled or disabled based on that boolean value.  Only the first valid path found in the list is evaluated and if no paths exist then the condition has no effect.</p> <p>Tags - The tags field is a YAML list of labels to associate with this chart. In the top parent's values, all charts with tags can be enabled or disabled by specifying the tag and a boolean value.</p> <pre><code># parentchart/Chart.yaml\n\ndependencies:\n  - name: subchart1\n    repository: http://localhost:10191\n    version: 0.1.0\n    condition: subchart1.enabled,global.subchart1.enabled\n    tags:\n      - front-end\n      - subchart1\n  - name: subchart2\n    repository: http://localhost:10191\n    version: 0.1.0\n    condition: subchart2.enabled,global.subchart2.enabled\n    tags:\n      - back-end\n      - subchart2\n</code></pre> <pre><code># parentchart/values.yaml\n\nsubchart1:\n  enabled: true\ntags:\n  front-end: false\n  back-end: true\n</code></pre> <p>In the above example all charts with the tag <code>front-end</code> would be disabled but since the <code>subchart1.enabled</code> path evaluates to 'true' in the parent's values, the condition will override the <code>front-end</code> tag and <code>subchart1</code> will be enabled.</p> <p>Since <code>subchart2</code> is tagged with <code>back-end</code> and that tag evaluates to <code>true</code>, <code>subchart2</code> will be enabled. Also note that although <code>subchart2</code> has a condition specified, there is no corresponding path and value in the parent's values so that condition has no effect.</p>"},{"location":"topics/charts/#using-the-cli-with-tags-and-conditions","title":"Using the CLI with Tags and Conditions","text":"<p>The <code>--set</code> parameter can be used as usual to alter tag and condition values.</p> <pre><code>helm install --set tags.front-end=true --set subchart2.enabled=false\n</code></pre>"},{"location":"topics/charts/#tags-and-condition-resolution","title":"Tags and Condition Resolution","text":"<ul> <li>Conditions (when set in values) always override tags. The first condition   path that exists wins and subsequent ones for that chart are ignored.</li> <li>Tags are evaluated as 'if any of the chart's tags are true then enable the   chart'.</li> <li>Tags and conditions values must be set in the top parent's values.</li> <li>The <code>tags:</code> key in values must be a top level key. Globals and nested <code>tags:</code>   tables are not currently supported.</li> </ul>"},{"location":"topics/charts/#importing-child-values-via-dependencies","title":"Importing Child Values via dependencies","text":"<p>In some cases it is desirable to allow a child chart's values to propagate to the parent chart and be shared as common defaults. An additional benefit of using the <code>exports</code> format is that it will enable future tooling to introspect user-settable values.</p> <p>The keys containing the values to be imported can be specified in the parent chart's <code>dependencies</code> in the field <code>import-values</code> using a YAML list. Each item in the list is a key which is imported from the child chart's <code>exports</code> field.</p> <p>To import values not contained in the <code>exports</code> key, use the child-parent format. Examples of both formats are described below.</p>"},{"location":"topics/charts/#using-the-exports-format","title":"Using the exports format","text":"<p>If a child chart's <code>values.yaml</code> file contains an <code>exports</code> field at the root, its contents may be imported directly into the parent's values by specifying the keys to import as in the example below:</p> <pre><code># parent's Chart.yaml file\n\ndependencies:\n  - name: subchart\n    repository: http://localhost:10191\n    version: 0.1.0\n    import-values:\n      - data\n</code></pre> <pre><code># child's values.yaml file\n\nexports:\n  data:\n    myint: 99\n</code></pre> <p>Since we are specifying the key <code>data</code> in our import list, Helm looks in the <code>exports</code> field of the child chart for <code>data</code> key and imports its contents.</p> <p>The final parent values would contain our exported field:</p> <pre><code># parent's values\n\nmyint: 99\n</code></pre> <p>Please note the parent key <code>data</code> is not contained in the parent's final values. If you need to specify the parent key, use the 'child-parent' format.</p>"},{"location":"topics/charts/#using-the-child-parent-format","title":"Using the child-parent format","text":"<p>To access values that are not contained in the <code>exports</code> key of the child chart's values, you will need to specify the source key of the values to be imported (<code>child</code>) and the destination path in the parent chart's values (<code>parent</code>).</p> <p>The <code>import-values</code> in the example below instructs Helm to take any values found at <code>child:</code> path and copy them to the parent's values at the path specified in <code>parent:</code></p> <pre><code># parent's Chart.yaml file\n\ndependencies:\n  - name: subchart1\n    repository: http://localhost:10191\n    version: 0.1.0\n    ...\n    import-values:\n      - child: default.data\n        parent: myimports\n</code></pre> <p>In the above example, values found at <code>default.data</code> in the subchart1's values will be imported to the <code>myimports</code> key in the parent chart's values as detailed below:</p> <pre><code># parent's values.yaml file\n\nmyimports:\n  myint: 0\n  mybool: false\n  mystring: \"helm rocks!\"\n</code></pre> <pre><code># subchart1's values.yaml file\n\ndefault:\n  data:\n    myint: 999\n    mybool: true\n</code></pre> <p>The parent chart's resulting values would be:</p> <pre><code># parent's final values\n\nmyimports:\n  myint: 999\n  mybool: true\n  mystring: \"helm rocks!\"\n</code></pre> <p>The parent's final values now contains the <code>myint</code> and <code>mybool</code> fields imported from subchart1.</p>"},{"location":"topics/charts/#managing-dependencies-manually-via-the-charts-directory","title":"Managing Dependencies manually via the <code>charts/</code> directory","text":"<p>If more control over dependencies is desired, these dependencies can be expressed explicitly by copying the dependency charts into the <code>charts/</code> directory.</p> <p>A dependency should be an unpacked chart directory but its name cannot start  with <code>_</code> or <code>.</code>. Such files are ignored by the chart loader.</p> <p>For example, if the WordPress chart depends on the Apache chart, the Apache chart (of the correct version) is supplied in the WordPress chart's <code>charts/</code> directory:</p> <pre><code>wordpress:\n  Chart.yaml\n  # ...\n  charts/\n    apache/\n      Chart.yaml\n      # ...\n    mysql/\n      Chart.yaml\n      # ...\n</code></pre> <p>The example above shows how the WordPress chart expresses its dependency on Apache and MySQL by including those charts inside of its <code>charts/</code> directory.</p> <p>TIP: To drop a dependency into your <code>charts/</code> directory, use the <code>helm pull</code> command</p>"},{"location":"topics/charts/#operational-aspects-of-using-dependencies","title":"Operational aspects of using dependencies","text":"<p>The above sections explain how to specify chart dependencies, but how does this affect chart installation using <code>helm install</code> and <code>helm upgrade</code>?</p> <p>Suppose that a chart named \"A\" creates the following Kubernetes objects</p> <ul> <li>namespace \"A-Namespace\"</li> <li>statefulset \"A-StatefulSet\"</li> <li>service \"A-Service\"</li> </ul> <p>Furthermore, A is dependent on chart B that creates objects</p> <ul> <li>namespace \"B-Namespace\"</li> <li>replicaset \"B-ReplicaSet\"</li> <li>service \"B-Service\"</li> </ul> <p>After installation/upgrade of chart A a single Helm release is created/modified. The release will create/update all of the above Kubernetes objects in the following order:</p> <ul> <li>A-Namespace</li> <li>B-Namespace</li> <li>A-Service</li> <li>B-Service</li> <li>B-ReplicaSet</li> <li>A-StatefulSet</li> </ul> <p>This is because when Helm installs/upgrades charts, the Kubernetes objects from the charts and all its dependencies are</p> <ul> <li>aggregated into a single set; then</li> <li>sorted by type followed by name; and then</li> <li>created/updated in that order.</li> </ul> <p>Hence a single release is created with all the objects for the chart and its dependencies.</p> <p>The install order of Kubernetes types is given by the enumeration InstallOrder in kind_sorter.go (see the Helm source file).</p>"},{"location":"topics/charts/#templates-and-values","title":"Templates and Values","text":"<p>Helm Chart templates are written in the Go template language, with the addition of 50 or so add-on template functions from the Sprig library and a few other specialized functions.</p> <p>All template files are stored in a chart's <code>templates/</code> folder. When Helm renders the charts, it will pass every file in that directory through the template engine.</p> <p>Values for the templates are supplied two ways:</p> <ul> <li>Chart developers may supply a file called <code>values.yaml</code> inside of a chart.   This file can contain default values.</li> <li>Chart users may supply a YAML file that contains values. This can be provided   on the command line with <code>helm install</code>.</li> </ul> <p>When a user supplies custom values, these values will override the values in the chart's <code>values.yaml</code> file.</p>"},{"location":"topics/charts/#template-files","title":"Template Files","text":"<p>Template files follow the standard conventions for writing Go templates (see the text/template Go package documentation for details). An example template file might look something like this:</p> <pre><code>apiVersion: v1\nkind: ReplicationController\nmetadata:\n  name: deis-database\n  namespace: deis\n  labels:\n    app.kubernetes.io/managed-by: deis\nspec:\n  replicas: 1\n  selector:\n    app.kubernetes.io/name: deis-database\n  template:\n    metadata:\n      labels:\n        app.kubernetes.io/name: deis-database\n    spec:\n      serviceAccount: deis-database\n      containers:\n        - name: deis-database\n          image: {{ .Values.imageRegistry }}/postgres:{{ .Values.dockerTag }}\n          imagePullPolicy: {{ .Values.pullPolicy }}\n          ports:\n            - containerPort: 5432\n          env:\n            - name: DATABASE_STORAGE\n              value: {{ default \"minio\" .Values.storage }}\n</code></pre> <p>The above example, based loosely on https://github.com/deis/charts, is a template for a Kubernetes replication controller. It can use the following four template values (usually defined in a <code>values.yaml</code> file):</p> <ul> <li><code>imageRegistry</code>: The source registry for the Docker image.</li> <li><code>dockerTag</code>: The tag for the docker image.</li> <li><code>pullPolicy</code>: The Kubernetes pull policy.</li> <li><code>storage</code>: The storage backend, whose default is set to <code>\"minio\"</code></li> </ul> <p>All of these values are defined by the template author. Helm does not require or dictate parameters.</p> <p>To see many working charts, check out the CNCF Artifact Hub.</p>"},{"location":"topics/charts/#predefined-values","title":"Predefined Values","text":"<p>Values that are supplied via a <code>values.yaml</code> file (or via the <code>--set</code> flag) are accessible from the <code>.Values</code> object in a template. But there are other pre-defined pieces of data you can access in your templates.</p> <p>The following values are pre-defined, are available to every template, and cannot be overridden. As with all values, the names are case sensitive.</p> <ul> <li><code>Release.Name</code>: The name of the release (not the chart)</li> <li><code>Release.Namespace</code>: The namespace the chart was released to.</li> <li><code>Release.Service</code>: The service that conducted the release.</li> <li><code>Release.IsUpgrade</code>: This is set to true if the current operation is an   upgrade or rollback.</li> <li><code>Release.IsInstall</code>: This is set to true if the current operation is an   install.</li> <li><code>Chart</code>: The contents of the <code>Chart.yaml</code>. Thus, the chart version is   obtainable as <code>Chart.Version</code> and the maintainers are in <code>Chart.Maintainers</code>.</li> <li><code>Files</code>: A map-like object containing all non-special files in the chart. This   will not give you access to templates, but will give you access to additional   files that are present (unless they are excluded using <code>.helmignore</code>). Files   can be accessed using <code>{{ index .Files \"file.name\" }}</code> or using the   <code>{{.Files.Get name }}</code> function. You can also access the contents of the file   as <code>[]byte</code> using <code>{{ .Files.GetBytes }}</code></li> <li><code>Capabilities</code>: A map-like object that contains information about the versions   of Kubernetes (<code>{{ .Capabilities.KubeVersion }}</code>) and the supported Kubernetes   API versions (<code>{{ .Capabilities.APIVersions.Has \"batch/v1\" }}</code>)</li> </ul> <p>NOTE: Any unknown <code>Chart.yaml</code> fields will be dropped. They will not be accessible inside of the <code>Chart</code> object. Thus, <code>Chart.yaml</code> cannot be used to pass arbitrarily structured data into the template. The values file can be used for that, though.</p>"},{"location":"topics/charts/#values-files","title":"Values files","text":"<p>Considering the template in the previous section, a <code>values.yaml</code> file that supplies the necessary values would look like this:</p> <pre><code>imageRegistry: \"quay.io/deis\"\ndockerTag: \"latest\"\npullPolicy: \"Always\"\nstorage: \"s3\"\n</code></pre> <p>A values file is formatted in YAML. A chart may include a default <code>values.yaml</code> file. The Helm install command allows a user to override values by supplying additional YAML values:</p> <pre><code>$ helm install --generate-name --values=myvals.yaml wordpress\n</code></pre> <p>When values are passed in this way, they will be merged into the default values file. For example, consider a <code>myvals.yaml</code> file that looks like this:</p> <pre><code>storage: \"gcs\"\n</code></pre> <p>When this is merged with the <code>values.yaml</code> in the chart, the resulting generated content will be:</p> <pre><code>imageRegistry: \"quay.io/deis\"\ndockerTag: \"latest\"\npullPolicy: \"Always\"\nstorage: \"gcs\"\n</code></pre> <p>Note that only the last field was overridden.</p> <p>NOTE: The default values file included inside of a chart must be named <code>values.yaml</code>. But files specified on the command line can be named anything.</p> <p>NOTE: If the <code>--set</code> flag is used on <code>helm install</code> or <code>helm upgrade</code>, those values are simply converted to YAML on the client side.</p> <p>NOTE: If any required entries in the values file exist, they can be declared as required in the chart template by using the 'required' function</p> <p>Any of these values are then accessible inside of templates using the <code>.Values</code> object:</p> <pre><code>apiVersion: v1\nkind: ReplicationController\nmetadata:\n  name: deis-database\n  namespace: deis\n  labels:\n    app.kubernetes.io/managed-by: deis\nspec:\n  replicas: 1\n  selector:\n    app.kubernetes.io/name: deis-database\n  template:\n    metadata:\n      labels:\n        app.kubernetes.io/name: deis-database\n    spec:\n      serviceAccount: deis-database\n      containers:\n        - name: deis-database\n          image: {{ .Values.imageRegistry }}/postgres:{{ .Values.dockerTag }}\n          imagePullPolicy: {{ .Values.pullPolicy }}\n          ports:\n            - containerPort: 5432\n          env:\n            - name: DATABASE_STORAGE\n              value: {{ default \"minio\" .Values.storage }}\n</code></pre>"},{"location":"topics/charts/#scope-dependencies-and-values","title":"Scope, Dependencies, and Values","text":"<p>Values files can declare values for the top-level chart, as well as for any of the charts that are included in that chart's <code>charts/</code> directory. Or, to phrase it differently, a values file can supply values to the chart as well as to any of its dependencies. For example, the demonstration WordPress chart above has both <code>mysql</code> and <code>apache</code> as dependencies. The values file could supply values to all of these components:</p> <pre><code>title: \"My WordPress Site\" # Sent to the WordPress template\n\nmysql:\n  max_connections: 100 # Sent to MySQL\n  password: \"secret\"\n\napache:\n  port: 8080 # Passed to Apache\n</code></pre> <p>Charts at a higher level have access to all of the variables defined beneath. So the WordPress chart can access the MySQL password as <code>.Values.mysql.password</code>. But lower level charts cannot access things in parent charts, so MySQL will not be able to access the <code>title</code> property. Nor, for that matter, can it access <code>apache.port</code>.</p> <p>Values are namespaced, but namespaces are pruned. So for the WordPress chart, it can access the MySQL password field as <code>.Values.mysql.password</code>. But for the MySQL chart, the scope of the values has been reduced and the namespace prefix removed, so it will see the password field simply as <code>.Values.password</code>.</p>"},{"location":"topics/charts/#global-values","title":"Global Values","text":"<p>As of 2.0.0-Alpha.2, Helm supports special \"global\" value. Consider this modified version of the previous example:</p> <pre><code>title: \"My WordPress Site\" # Sent to the WordPress template\n\nglobal:\n  app: MyWordPress\n\nmysql:\n  max_connections: 100 # Sent to MySQL\n  password: \"secret\"\n\napache:\n  port: 8080 # Passed to Apache\n</code></pre> <p>The above adds a <code>global</code> section with the value <code>app: MyWordPress</code>. This value is available to all charts as <code>.Values.global.app</code>.</p> <p>For example, the <code>mysql</code> templates may access <code>app</code> as <code>{{ .Values.global.app}}</code>, and so can the <code>apache</code> chart. Effectively, the values file above is regenerated like this:</p> <pre><code>title: \"My WordPress Site\" # Sent to the WordPress template\n\nglobal:\n  app: MyWordPress\n\nmysql:\n  global:\n    app: MyWordPress\n  max_connections: 100 # Sent to MySQL\n  password: \"secret\"\n\napache:\n  global:\n    app: MyWordPress\n  port: 8080 # Passed to Apache\n</code></pre> <p>This provides a way of sharing one top-level variable with all subcharts, which is useful for things like setting <code>metadata</code> properties like labels.</p> <p>If a subchart declares a global variable, that global will be passed downward (to the subchart's subcharts), but not upward to the parent chart. There is no way for a subchart to influence the values of the parent chart.</p> <p>Also, global variables of parent charts take precedence over the global variables from subcharts.</p>"},{"location":"topics/charts/#schema-files","title":"Schema Files","text":"<p>Sometimes, a chart maintainer might want to define a structure on their values. This can be done by defining a schema in the <code>values.schema.json</code> file. A schema is represented as a JSON Schema. It might look something like this:</p> <pre><code>{\n  \"$schema\": \"https://json-schema.org/draft-07/schema#\",\n  \"properties\": {\n    \"image\": {\n      \"description\": \"Container Image\",\n      \"properties\": {\n        \"repo\": {\n          \"type\": \"string\"\n        },\n        \"tag\": {\n          \"type\": \"string\"\n        }\n      },\n      \"type\": \"object\"\n    },\n    \"name\": {\n      \"description\": \"Service name\",\n      \"type\": \"string\"\n    },\n    \"port\": {\n      \"description\": \"Port\",\n      \"minimum\": 0,\n      \"type\": \"integer\"\n    },\n    \"protocol\": {\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\n    \"protocol\",\n    \"port\"\n  ],\n  \"title\": \"Values\",\n  \"type\": \"object\"\n}\n</code></pre> <p>This schema will be applied to the values to validate it. Validation occurs when any of the following commands are invoked:</p> <ul> <li><code>helm install</code></li> <li><code>helm upgrade</code></li> <li><code>helm lint</code></li> <li><code>helm template</code></li> </ul> <p>An example of a <code>values.yaml</code> file that meets the requirements of this schema might look something like this:</p> <pre><code>name: frontend\nprotocol: https\nport: 443\n</code></pre> <p>Note that the schema is applied to the final <code>.Values</code> object, and not just to the <code>values.yaml</code> file. This means that the following <code>yaml</code> file is valid, given that the chart is installed with the appropriate <code>--set</code> option shown below.</p> <pre><code>name: frontend\nprotocol: https\n</code></pre> <pre><code>helm install --set port=443\n</code></pre> <p>Furthermore, the final <code>.Values</code> object is checked against all subchart schemas. This means that restrictions on a subchart can't be circumvented by a parent chart. This also works backwards - if a subchart has a requirement that is not met in the subchart's <code>values.yaml</code> file, the parent chart must satisfy those restrictions in order to be valid.</p>"},{"location":"topics/charts/#references","title":"References","text":"<p>When it comes to writing templates, values, and schema files, there are several standard references that will help you out.</p> <ul> <li>Go templates</li> <li>Extra template functions</li> <li>The YAML format</li> <li>JSON Schema</li> </ul>"},{"location":"topics/charts/#custom-resource-definitions-crds","title":"Custom Resource Definitions (CRDs)","text":"<p>Kubernetes provides a mechanism for declaring new types of Kubernetes objects. Using CustomResourceDefinitions (CRDs), Kubernetes developers can declare custom resource types.</p> <p>In Helm 3, CRDs are treated as a special kind of object. They are installed before the rest of the chart, and are subject to some limitations.</p> <p>CRD YAML files should be placed in the <code>crds/</code> directory inside of a chart. Multiple CRDs (separated by YAML start and end markers) may be placed in the same file. Helm will attempt to load all of the files in the CRD directory into Kubernetes.</p> <p>CRD files cannot be templated. They must be plain YAML documents.</p> <p>When Helm installs a new chart, it will upload the CRDs, pause until the CRDs are made available by the API server, and then start the template engine, render the rest of the chart, and upload it to Kubernetes. Because of this ordering, CRD information is available in the <code>.Capabilities</code> object in Helm templates, and Helm templates may create new instances of objects that were declared in CRDs.</p> <p>For example, if your chart had a CRD for <code>CronTab</code> in the <code>crds/</code> directory, you may create instances of the <code>CronTab</code> kind in the <code>templates/</code> directory:</p> <pre><code>crontabs/\n  Chart.yaml\n  crds/\n    crontab.yaml\n  templates/\n    mycrontab.yaml\n</code></pre> <p>The <code>crontab.yaml</code> file must contain the CRD with no template directives:</p> <pre><code>kind: CustomResourceDefinition\nmetadata:\n  name: crontabs.stable.example.com\nspec:\n  group: stable.example.com\n  versions:\n    - name: v1\n      served: true\n      storage: true\n  scope: Namespaced\n  names:\n    plural: crontabs\n    singular: crontab\n    kind: CronTab\n</code></pre> <p>Then the template <code>mycrontab.yaml</code> may create a new <code>CronTab</code> (using templates as usual):</p> <pre><code>apiVersion: stable.example.com\nkind: CronTab\nmetadata:\n  name: {{ .Values.name }}\nspec:\n   # ...\n</code></pre> <p>Helm will make sure that the <code>CronTab</code> kind has been installed and is available from the Kubernetes API server before it proceeds installing the things in <code>templates/</code>.</p>"},{"location":"topics/charts/#limitations-on-crds","title":"Limitations on CRDs","text":"<p>Unlike most objects in Kubernetes, CRDs are installed globally. For that reason, Helm takes a very cautious approach in managing CRDs. CRDs are subject to the following limitations:</p> <ul> <li>CRDs are never reinstalled. If Helm determines that the CRDs in the <code>crds/</code>   directory are already present (regardless of version), Helm will not attempt   to install or upgrade.</li> <li>CRDs are never installed on upgrade or rollback. Helm will only create CRDs on   installation operations.</li> <li>CRDs are never deleted. Deleting a CRD automatically deletes all of the CRD's   contents across all namespaces in the cluster. Consequently, Helm will not   delete CRDs.</li> </ul> <p>Operators who want to upgrade or delete CRDs are encouraged to do this manually and with great care.</p>"},{"location":"topics/charts/#using-helm-to-manage-charts","title":"Using Helm to Manage Charts","text":"<p>The <code>helm</code> tool has several commands for working with charts.</p> <p>It can create a new chart for you:</p> <pre><code>$ helm create mychart\nCreated mychart/\n</code></pre> <p>Once you have edited a chart, <code>helm</code> can package it into a chart archive for you:</p> <pre><code>$ helm package mychart\nArchived mychart-0.1.-.tgz\n</code></pre> <p>You can also use <code>helm</code> to help you find issues with your chart's formatting or information:</p> <pre><code>$ helm lint mychart\nNo issues found\n</code></pre>"},{"location":"topics/charts/#chart-repositories","title":"Chart Repositories","text":"<p>A chart repository is an HTTP server that houses one or more packaged charts. While <code>helm</code> can be used to manage local chart directories, when it comes to sharing charts, the preferred mechanism is a chart repository.</p> <p>Any HTTP server that can serve YAML files and tar files and can answer GET requests can be used as a repository server. The Helm team has tested some servers, including Google Cloud Storage with website mode enabled, and S3 with website mode enabled.</p> <p>A repository is characterized primarily by the presence of a special file called <code>index.yaml</code> that has a list of all of the packages supplied by the repository, together with metadata that allows retrieving and verifying those packages.</p> <p>On the client side, repositories are managed with the <code>helm repo</code> commands. However, Helm does not provide tools for uploading charts to remote repository servers. This is because doing so would add substantial requirements to an implementing server, and thus raise the barrier for setting up a repository.</p>"},{"location":"topics/charts/#chart-starter-packs","title":"Chart Starter Packs","text":"<p>The <code>helm create</code> command takes an optional <code>--starter</code> option that lets you specify a \"starter chart\". Also, the starter option has a short alias <code>-p</code>.</p> <p>Examples of usage:</p> <pre><code>helm create my-chart --starter starter-name\nhelm create my-chart -p starter-name\nhelm create my-chart -p /absolute/path/to/starter-name\n</code></pre> <p>Starters are just regular charts, but are located in <code>$XDG_DATA_HOME/helm/starters</code>. As a chart developer, you may author charts that are specifically designed to be used as starters. Such charts should be designed with the following considerations in mind:</p> <ul> <li>The <code>Chart.yaml</code> will be overwritten by the generator.</li> <li>Users will expect to modify such a chart's contents, so documentation should   indicate how users can do so.</li> <li>All occurrences of <code>&lt;CHARTNAME&gt;</code> will be replaced with the specified chart name so that starter charts can be used as templates, except for some variable files. For example, if you use custom files in the <code>vars</code> directory or certain <code>README.md</code> files, <code>&lt;CHARTNAME&gt;</code> will NOT override inside them. Additionally, the chart description is not inherited.</li> </ul> <p>Currently the only way to add a chart to <code>$XDG_DATA_HOME/helm/starters</code> is to manually copy it there. In your chart's documentation, you may want to explain that process.</p>"},{"location":"topics/charts_hooks/","title":"Chart Hooks","text":"<p>Helm provides a hook mechanism to allow chart developers to intervene at certain points in a release's life cycle. For example, you can use hooks to:</p> <ul> <li>Load a ConfigMap or Secret during install before any other charts are loaded.</li> <li>Execute a Job to back up a database before installing a new chart, and then   execute a second job after the upgrade in order to restore data.</li> <li>Run a Job before deleting a release to gracefully take a service out of   rotation before removing it.</li> </ul> <p>Hooks work like regular templates, but they have special annotations that cause Helm to utilize them differently. In this section, we cover the basic usage pattern for hooks.</p>"},{"location":"topics/charts_hooks/#the-available-hooks","title":"The Available Hooks","text":"<p>The following hooks are defined:</p> Annotation Value Description <code>pre-install</code> Executes after templates are rendered, but before any resources are created in Kubernetes <code>post-install</code> Executes after all resources are loaded into Kubernetes <code>pre-delete</code> Executes on a deletion request before any resources are deleted from Kubernetes <code>post-delete</code> Executes on a deletion request after all of the release's resources have been deleted <code>pre-upgrade</code> Executes on an upgrade request after templates are rendered, but before any resources are updated <code>post-upgrade</code> Executes on an upgrade request after all resources have been upgraded <code>pre-rollback</code> Executes on a rollback request after templates are rendered, but before any resources are rolled back <code>post-rollback</code> Executes on a rollback request after all resources have been modified <code>test</code> Executes when the Helm test subcommand is invoked (view test docs) <p>Note that the <code>crd-install</code> hook has been removed in favor of the <code>crds/</code> directory in Helm 3.</p>"},{"location":"topics/charts_hooks/#hooks-and-the-release-lifecycle","title":"Hooks and the Release Lifecycle","text":"<p>Hooks allow you, the chart developer, an opportunity to perform operations at strategic points in a release lifecycle. For example, consider the lifecycle for a <code>helm install</code>. By default, the lifecycle looks like this:</p> <ol> <li>User runs <code>helm install foo</code></li> <li>The Helm library install API is called</li> <li>After some verification, the library renders the <code>foo</code> templates</li> <li>The library loads the resulting resources into Kubernetes</li> <li>The library returns the release object (and other data) to the client</li> <li>The client exits</li> </ol> <p>Helm defines two hooks for the <code>install</code> lifecycle: <code>pre-install</code> and <code>post-install</code>. If the developer of the <code>foo</code> chart implements both hooks, the lifecycle is altered like this:</p> <ol> <li>User runs <code>helm install foo</code></li> <li>The Helm library install API is called</li> <li>CRDs in the <code>crds/</code> directory are installed</li> <li>After some verification, the library renders the <code>foo</code> templates</li> <li>The library prepares to execute the <code>pre-install</code> hooks (loading hook    resources into Kubernetes)</li> <li>The library sorts hooks by weight (assigning a weight of 0 by default),     by resource kind and finally by name in ascending order.</li> <li>The library then loads the hook with the lowest weight first (negative to    positive)</li> <li>The library waits until the hook is \"Ready\" (except for CRDs)</li> <li>The library loads the resulting resources into Kubernetes. Note that if the    <code>--wait</code> flag is set, the library will wait until all resources are in a    ready state and will not run the <code>post-install</code> hook until they are ready.</li> <li>The library executes the <code>post-install</code> hook (loading hook resources)</li> <li>The library waits until the hook is \"Ready\"</li> <li>The library returns the release object (and other data) to the client</li> <li>The client exits</li> </ol> <p>What does it mean to wait until a hook is ready? This depends on the resource declared in the hook. If the resource is a <code>Job</code> or <code>Pod</code> kind, Helm will wait until it successfully runs to completion. And if the hook fails, the release will fail. This is a blocking operation, so the Helm client will pause while the Job is run.</p> <p>For all other kinds, as soon as Kubernetes marks the resource as loaded (added or updated), the resource is considered \"Ready\". When many resources are declared in a hook, the resources are executed serially. If they have hook weights (see below), they are executed in weighted order.  Starting from Helm 3.2.0 hook resources with same weight are installed in the same  order as normal non-hook resources. Otherwise, ordering is not guaranteed. (In Helm 2.3.0 and after, they are sorted alphabetically. That behavior, though, is not considered binding and could change in the future.) It is considered good practice to add a hook weight, and set it to <code>0</code> if weight is not important.</p>"},{"location":"topics/charts_hooks/#hook-resources-are-not-managed-with-corresponding-releases","title":"Hook resources are not managed with corresponding releases","text":"<p>The resources that a hook creates are currently not tracked or managed as part of the release. Once Helm verifies that the hook has reached its ready state, it will leave the hook resource alone. Garbage collection of hook resources when the corresponding release is deleted may be added to Helm 3 in the future, so any hook resources that must never be deleted should be annotated with <code>helm.sh/resource-policy: keep</code>.</p> <p>Practically speaking, this means that if you create resources in a hook, you cannot rely upon <code>helm uninstall</code> to remove the resources. To destroy such resources, you need to either add a custom <code>helm.sh/hook-delete-policy</code> annotation to the hook template file, or set the time to live (TTL) field of a Job resource.</p>"},{"location":"topics/charts_hooks/#writing-a-hook","title":"Writing a Hook","text":"<p>Hooks are just Kubernetes manifest files with special annotations in the <code>metadata</code> section. Because they are template files, you can use all of the normal template features, including reading <code>.Values</code>, <code>.Release</code>, and <code>.Template</code>.</p> <p>For example, this template, stored in <code>templates/post-install-job.yaml</code>, declares a job to be run on <code>post-install</code>:</p> <pre><code>apiVersion: batch/v1\nkind: Job\nmetadata:\n  name: \"{{ .Release.Name }}\"\n  labels:\n    app.kubernetes.io/managed-by: {{ .Release.Service | quote }}\n    app.kubernetes.io/instance: {{ .Release.Name | quote }}\n    app.kubernetes.io/version: {{ .Chart.AppVersion }}\n    helm.sh/chart: \"{{ .Chart.Name }}-{{ .Chart.Version }}\"\n  annotations:\n    # This is what defines this resource as a hook. Without this line, the\n    # job is considered part of the release.\n    \"helm.sh/hook\": post-install\n    \"helm.sh/hook-weight\": \"-5\"\n    \"helm.sh/hook-delete-policy\": hook-succeeded\nspec:\n  template:\n    metadata:\n      name: \"{{ .Release.Name }}\"\n      labels:\n        app.kubernetes.io/managed-by: {{ .Release.Service | quote }}\n        app.kubernetes.io/instance: {{ .Release.Name | quote }}\n        helm.sh/chart: \"{{ .Chart.Name }}-{{ .Chart.Version }}\"\n    spec:\n      restartPolicy: Never\n      containers:\n      - name: post-install-job\n        image: \"alpine:3.3\"\n        command: [\"/bin/sleep\",\"{{ default \"10\" .Values.sleepyTime }}\"]\n\n</code></pre> <p>What makes this template a hook is the annotation:</p> <pre><code>annotations:\n  \"helm.sh/hook\": post-install\n</code></pre> <p>One resource can implement multiple hooks:</p> <pre><code>annotations:\n  \"helm.sh/hook\": post-install,post-upgrade\n</code></pre> <p>Similarly, there is no limit to the number of different resources that may implement a given hook. For example, one could declare both a secret and a config map as a pre-install hook.</p> <p>When subcharts declare hooks, those are also evaluated. There is no way for a top-level chart to disable the hooks declared by subcharts.</p> <p>It is possible to define a weight for a hook which will help build a deterministic executing order. Weights are defined using the following annotation:</p> <pre><code>annotations:\n  \"helm.sh/hook-weight\": \"5\"\n</code></pre> <p>Hook weights can be positive or negative numbers but must be represented as strings. When Helm starts the execution cycle of hooks of a particular Kind it will sort those hooks in ascending order.</p>"},{"location":"topics/charts_hooks/#hook-deletion-policies","title":"Hook deletion policies","text":"<p>It is possible to define policies that determine when to delete corresponding hook resources. Hook deletion policies are defined using the following annotation:</p> <pre><code>annotations:\n  \"helm.sh/hook-delete-policy\": before-hook-creation,hook-succeeded\n</code></pre> <p>You can choose one or more defined annotation values:</p> Annotation Value Description <code>before-hook-creation</code> Delete the previous resource before a new hook is launched (default) <code>hook-succeeded</code> Delete the resource after the hook is successfully executed <code>hook-failed</code> Delete the resource if the hook failed during execution <p>If no hook deletion policy annotation is specified, the <code>before-hook-creation</code> behavior applies by default.</p>"},{"location":"topics/kubernetes_apis/","title":"Deprecated Kubernetes APIs","text":"<p>Kubernetes is an API-driven system and the API evolves over time to reflect the evolving understanding of the problem space. This is common practice across systems and their APIs. An important part of evolving APIs is a good deprecation policy and process to inform users of how changes to APIs are implemented. In other words, consumers of your API need to know in advance and in what release an API will be removed or changed. This removes the element of surprise and breaking changes to consumers.</p> <p>The Kubernetes deprecation policy documents how Kubernetes handles the changes to its API versions. The policy for deprecation states the timeframe that API versions will be supported following a deprecation announcement. It is therefore important to be aware of deprecation announcements and know when API versions will be removed, to help minimize the effect.</p> <p>This is an example of an announcement for the removal of deprecated API versions in Kubernetes 1.16 and was advertised a few months prior to the release. These API versions would have been announced for deprecation prior to this again. This shows that there is a good policy in place which informs consumers of API version support.</p> <p>Helm templates specify a Kubernetes API group when defining a Kubernetes object, similar to a Kubernetes manifest file. It is specified in the <code>apiVersion</code> field of the template and it identifies the API version of the Kubernetes object. This means that Helm users and chart maintainers need to be aware when Kubernetes API versions have been deprecated and in what Kubernetes version they will be removed.</p>"},{"location":"topics/kubernetes_apis/#chart-maintainers","title":"Chart Maintainers","text":"<p>You should audit your charts checking for Kubernetes API versions that are deprecated or are removed in a Kubernetes version. The API versions found as due to be or that are now out of support, should be updated to the supported version and a new version of the chart released. The API version is defined by the <code>kind</code> and <code>apiVersion</code> fields. For example, here is a removed <code>Deployment</code> object API version in Kubernetes 1.16:</p> <pre><code>apiVersion: apps/v1beta1\nkind: Deployment\n</code></pre>"},{"location":"topics/kubernetes_apis/#helm-users","title":"Helm Users","text":"<p>You should audit the charts that you use (similar to chart maintainers) and identify any charts where API versions are deprecated or removed in a Kubernetes version. For the charts identified, you need to check for the latest version of the chart (which has supported API versions) or update the chart yourself.</p> <p>Additionally, you also need to audit any charts deployed (i.e. Helm releases) checking again for any deprecated or removed API versions. This can be done by getting details of a release using the <code>helm get manifest</code> command.</p> <p>The means for updating a Helm release to supported APIs depends on your findings as follows:</p> <ol> <li>If you find deprecated API versions only then:</li> <li>Perform a <code>helm upgrade</code> with a version of the chart with supported     Kubernetes API versions</li> <li>Add a description in the upgrade, something along the lines to not perform a     rollback to a Helm version prior to this current version</li> <li>If you find any API version(s) that is/are removed in a Kubernetes version     then:</li> <li>If you are running a Kubernetes version where the API version(s) are still     available (for example, you are on Kubernetes 1.15 and found you use APIs     that will be removed in Kubernetes 1.16):<ul> <li>Follow the step 1 procedure</li> </ul> </li> <li>Otherwise (for example, you are already running a Kubernetes version where     some API versions reported by <code>helm get manifest</code> are no longer available):<ul> <li>You need to edit the release manifest that is stored in the cluster to   update the API versions to supported APIs. See Updating API Versions of a   Release Manifest for more   details</li> </ul> </li> </ol> <p>Note: In all cases of updating a Helm release with supported APIs, you should never rollback the release to a version prior to the release version with the supported APIs.</p> <p>Recommendation: The best practice is to upgrade releases using deprecated API versions to supported API versions, prior to upgrading to a kubernetes cluster that removes those API versions.</p> <p>If you don't update a release as suggested previously, you will have an error similar to the following when trying to upgrade a release in a Kubernetes version where its API version(s) is/are removed:</p> <pre><code>Error: UPGRADE FAILED: current release manifest contains removed kubernetes api(s)\nfor this kubernetes version and it is therefore unable to build the kubernetes\nobjects for performing the diff. error from kubernetes: unable to recognize \"\":\nno matches for kind \"Deployment\" in version \"apps/v1beta1\"\n</code></pre> <p>Helm fails in this scenario because it attempts to create a diff patch between the current deployed release (which contains the Kubernetes APIs that are removed in this Kubernetes version) against the chart you are passing with the updated/supported API versions. The underlying reason for failure is that when Kubernetes removes an API version, the Kubernetes Go client library can no longer parse the deprecated objects and Helm therefore fails when calling the library. Helm unfortunately is unable to recover from this situation and is no longer able to manage such a release. See Updating API Versions of a Release Manifest for more details on how to recover from this scenario.</p>"},{"location":"topics/kubernetes_apis/#updating-api-versions-of-a-release-manifest","title":"Updating API Versions of a Release Manifest","text":"<p>The manifest is a property of the Helm release object which is stored in the data field of a Secret (default) or ConfigMap in the cluster. The data field contains a gzipped object which is base 64 encoded (there is an additional base 64 encoding for a Secret). There is a Secret/ConfigMap per release version/revision in the namespace of the release.</p> <p>You can use the Helm mapkubeapis plugin to perform the update of a release to supported APIs. Check out the readme for more details.</p> <p>Alternatively, you can follow these manual steps to perform an update of the API versions of a release manifest. Depending on your configuration you will follow the steps for the Secret or ConfigMap backend.</p> <ul> <li>Get the name of the Secret or Configmap associated with the latest deployed   release:</li> <li>Secrets backend: <code>kubectl get secret -l     owner=helm,status=deployed,name=&lt;release_name&gt; --namespace     &lt;release_namespace&gt; | awk '{print $1}' | grep -v NAME</code></li> <li>ConfigMap backend: <code>kubectl get configmap -l     owner=helm,status=deployed,name=&lt;release_name&gt; --namespace     &lt;release_namespace&gt; | awk '{print $1}' | grep -v NAME</code></li> <li>Get latest deployed release details:</li> <li>Secrets backend: <code>kubectl get secret &lt;release_secret_name&gt; -n     &lt;release_namespace&gt; -o yaml &gt; release.yaml</code></li> <li>ConfigMap backend: <code>kubectl get configmap &lt;release_configmap_name&gt; -n     &lt;release_namespace&gt; -o yaml &gt; release.yaml</code></li> <li>Backup the release in case you need to restore if something goes wrong:</li> <li><code>cp release.yaml release.bak</code></li> <li>In case of emergency, restore: <code>kubectl apply -f release.bak -n     &lt;release_namespace&gt;</code></li> <li>Decode the release object:</li> <li>Secrets backend:<code>cat release.yaml | grep -oP '(?&lt;=release: ).*' | base64 -d     | base64 -d | gzip -d &gt; release.data.decoded</code></li> <li>ConfigMap backend: <code>cat release.yaml | grep -oP '(?&lt;=release: ).*' | base64     -d | gzip -d &gt; release.data.decoded</code></li> <li>Change API versions of the manifests. Can use any tool (e.g. editor) to make   the changes. This is in the <code>manifest</code> field of your decoded release object   (<code>release.data.decoded</code>)</li> <li>Encode the release object:</li> <li>Secrets backend: <code>cat release.data.decoded | gzip | base64 | base64</code></li> <li>ConfigMap backend: <code>cat release.data.decoded | gzip | base64</code></li> <li>Replace <code>data.release</code> property value in the deployed release file   (<code>release.yaml</code>) with the new encoded release object</li> <li>Apply file to namespace: <code>kubectl apply -f release.yaml -n   &lt;release_namespace&gt;</code></li> <li>Perform a <code>helm upgrade</code> with a version of the chart with supported Kubernetes   API versions</li> <li>Add a description in the upgrade, something along the lines to not perform a   rollback to a Helm version prior to this current version</li> </ul>"},{"location":"topics/kubernetes_distros/","title":"Kubernetes Distribution Guide","text":"<p>Helm should work with any conformant version of Kubernetes (whether certified or not).</p> <p>This document captures information about using Helm in specific Kubernetes environments. Please contribute more details about any distros (sorted alphabetically) if desired.</p>"},{"location":"topics/kubernetes_distros/#aks","title":"AKS","text":"<p>Helm works with Azure Kubernetes Service.</p>"},{"location":"topics/kubernetes_distros/#dcos","title":"DC/OS","text":"<p>Helm has been tested and is working on Mesospheres DC/OS 1.11 Kubernetes platform, and requires no additional configuration.</p>"},{"location":"topics/kubernetes_distros/#eks","title":"EKS","text":"<p>Helm works with Amazon Elastic Kubernetes Service (Amazon EKS): Using Helm with Amazon EKS.</p>"},{"location":"topics/kubernetes_distros/#gke","title":"GKE","text":"<p>Google's GKE hosted Kubernetes platform is known to work with Helm, and requires no additional configuration.</p>"},{"location":"topics/kubernetes_distros/#scriptslocal-cluster-and-hyperkube","title":"<code>scripts/local-cluster</code> and Hyperkube","text":"<p>Hyperkube configured via <code>scripts/local-cluster.sh</code> is known to work. For raw Hyperkube you may need to do some manual configuration.</p>"},{"location":"topics/kubernetes_distros/#iks","title":"IKS","text":"<p>Helm works with IBM Cloud Kubernetes Service.</p>"},{"location":"topics/kubernetes_distros/#kind-kubernetes-in-docker","title":"KIND (Kubernetes IN Docker)","text":"<p>Helm is regularly tested on KIND.</p>"},{"location":"topics/kubernetes_distros/#kubeone","title":"KubeOne","text":"<p>Helm works in clusters that are set up by KubeOne without caveats.</p>"},{"location":"topics/kubernetes_distros/#kubermatic","title":"Kubermatic","text":"<p>Helm works in user clusters that are created by Kubermatic without caveats. Since seed cluster can be set up in different ways Helm support depends on their configuration.</p>"},{"location":"topics/kubernetes_distros/#microk8s","title":"MicroK8s","text":"<p>Helm can be enabled in MicroK8s using the command: <code>microk8s.enable helm3</code></p>"},{"location":"topics/kubernetes_distros/#minikube","title":"Minikube","text":"<p>Helm is tested and known to work with Minikube. It requires no additional configuration.</p>"},{"location":"topics/kubernetes_distros/#openshift","title":"Openshift","text":"<p>Helm works straightforward on OpenShift Online, OpenShift Dedicated, OpenShift Container Platform (version &gt;= 3.6) or OpenShift Origin (version &gt;= 3.6). To learn more read this blog post.</p>"},{"location":"topics/kubernetes_distros/#platform9","title":"Platform9","text":"<p>Helm is pre-installed with Platform9 Managed Kubernetes. Platform9 provides access to all official Helm charts through the App Catalog UI and native Kubernetes CLI. Additional repositories can be manually added. Further details are available in this Platform9 App Catalog article.</p>"},{"location":"topics/kubernetes_distros/#ubuntu-with-kubeadm","title":"Ubuntu with <code>kubeadm</code>","text":"<p>Kubernetes bootstrapped with <code>kubeadm</code> is known to work on the following Linux distributions:</p> <ul> <li>Ubuntu 16.04</li> <li>Fedora release 25</li> </ul> <p>Some versions of Helm (v2.0.0-beta2) require you to <code>export KUBECONFIG=/etc/kubernetes/admin.conf</code> or create a <code>~/.kube/config</code>.</p>"},{"location":"topics/kubernetes_distros/#vmware-tanzu-kubernetes-grid","title":"VMware Tanzu Kubernetes Grid","text":"<p>Helm runs on VMware Tanzu Kubernetes Grid, TKG, without needing configuration changes.  The Tanzu CLI can manage installing packages for helm-controller allowing for declaratively managing Helm chart releases.  Further details available in the TKG documentation for CLI-Managed Packages.</p>"},{"location":"topics/library_charts/","title":"Library Charts","text":"<p>A library chart is a type of Helm chart that defines chart primitives or definitions which can be shared by Helm templates in other charts. This allows users to share snippets of code that can be re-used across charts, avoiding repetition and keeping charts DRY.</p> <p>The library chart was introduced in Helm 3 to formally recognize common or helper charts that have been used by chart maintainers since Helm 2. By including it as a chart type, it provides: - A means to explicitly distinguish between common and application charts - Logic to prevent installation of a common chart - No rendering of templates in a common chart which may contain release   artifacts - Allow for dependent charts to use the importer's context</p> <p>A chart maintainer can define a common chart as a library chart and now be confident that Helm will handle the chart in a standard consistent fashion. It also means that definitions in an application chart can be shared by changing the chart type.</p>"},{"location":"topics/library_charts/#create-a-simple-library-chart","title":"Create a Simple Library Chart","text":"<p>As mentioned previously, a library chart is a type of Helm chart. This means that you can start off by creating a scaffold chart:</p> <pre><code>$ helm create mylibchart\nCreating mylibchart\n</code></pre> <p>You will first remove all the files in <code>templates</code> directory as we will create our own templates definitions in this example.</p> <pre><code>$ rm -rf mylibchart/templates/*\n</code></pre> <p>The values file will not be required either.</p> <pre><code>$ rm -f mylibchart/values.yaml\n</code></pre> <p>Before we jump into creating common code, lets do a quick review of some relevant Helm concepts. A named template (sometimes called a partial or a subtemplate) is simply a template defined inside of a file, and given a name.  In the <code>templates/</code> directory, any file that begins with an underscore(_) is not expected to output a Kubernetes manifest file. So by convention, helper templates and partials are placed in a <code>_*.tpl</code> or <code>_*.yaml</code> files.</p> <p>In this example, we will code a common ConfigMap which creates an empty ConfigMap resource. We will define the common ConfigMap in file <code>mylibchart/templates/_configmap.yaml</code> as follows:</p> <pre><code>{{- define \"mylibchart.configmap.tpl\" -}}\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: {{ .Release.Name | printf \"%s-%s\" .Chart.Name }}\ndata: {}\n{{- end -}}\n{{- define \"mylibchart.configmap\" -}}\n{{- include \"mylibchart.util.merge\" (append . \"mylibchart.configmap.tpl\") -}}\n{{- end -}}\n</code></pre> <p>The ConfigMap construct is defined in named template <code>mylibchart.configmap.tpl</code>. It is a simple ConfigMap with an empty resource, <code>data</code>. Within this file there is another named template called <code>mylibchart.configmap</code>. This named template includes another named template <code>mylibchart.util.merge</code> which will take 2 named templates as arguments, the template calling <code>mylibchart.configmap</code> and <code>mylibchart.configmap.tpl</code>.</p> <p>The helper function <code>mylibchart.util.merge</code> is a named template in <code>mylibchart/templates/_util.yaml</code>. It is a handy util from The Common Helm Helper Chart because it merges the 2 templates and overrides any common parts in both:</p> <pre><code>{{- /*\nmylibchart.util.merge will merge two YAML templates and output the result.\nThis takes an array of three values:\n- the top context\n- the template name of the overrides (destination)\n- the template name of the base (source)\n*/}}\n{{- define \"mylibchart.util.merge\" -}}\n{{- $top := first . -}}\n{{- $overrides := fromYaml (include (index . 1) $top) | default (dict ) -}}\n{{- $tpl := fromYaml (include (index . 2) $top) | default (dict ) -}}\n{{- toYaml (merge $overrides $tpl) -}}\n{{- end -}}\n</code></pre> <p>This is important when a chart wants to use common code that it needs to customize with its configuration.</p> <p>Finally, lets change the chart type to <code>library</code>. This requires editing <code>mylibchart/Chart.yaml</code> as follows:</p> <pre><code>apiVersion: v2\nname: mylibchart\ndescription: A Helm chart for Kubernetes\n\n# A chart can be either an 'application' or a 'library' chart.\n#\n# Application charts are a collection of templates that can be packaged into versioned archives\n# to be deployed.\n#\n# Library charts provide useful utilities or functions for the chart developer. They're included as\n# a dependency of application charts to inject those utilities and functions into the rendering\n# pipeline. Library charts do not define any templates and therefore cannot be deployed.\n# type: application\ntype: library\n\n# This is the chart version. This version number should be incremented each time you make changes\n# to the chart and its templates, including the app version.\nversion: 0.1.0\n\n# This is the version number of the application being deployed. This version number should be\n# incremented each time you make changes to the application and it is recommended to use it with quotes.\nappVersion: \"1.16.0\"\n</code></pre> <p>The library chart is now ready to be shared and its ConfigMap definition to be re-used.</p> <p>Before moving on, it is worth checking if Helm recognizes the chart as a library chart:</p> <pre><code>$ helm install mylibchart mylibchart/\nError: library charts are not installable\n</code></pre>"},{"location":"topics/library_charts/#use-the-simple-library-chart","title":"Use the Simple Library Chart","text":"<p>It is time to use the library chart. This means creating a scaffold chart again:</p> <pre><code>$ helm create mychart\nCreating mychart\n</code></pre> <p>Lets clean out the template files again as we want to create a ConfigMap only:</p> <pre><code>$ rm -rf mychart/templates/*\n</code></pre> <p>When we want to create a simple ConfigMap in a Helm template, it could look similar to the following:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: {{ .Release.Name | printf \"%s-%s\" .Chart.Name }}\ndata:\n  myvalue: \"Hello World\"\n</code></pre> <p>We are however going to re-use the common code already created in <code>mylibchart</code>. The ConfigMap can be created in the file <code>mychart/templates/configmap.yaml</code> as follows:</p> <pre><code>{{- include \"mylibchart.configmap\" (list . \"mychart.configmap\") -}}\n{{- define \"mychart.configmap\" -}}\ndata:\n  myvalue: \"Hello World\"\n{{- end -}}\n</code></pre> <p>You can see that it simplifies the work we have to do by inheriting the common ConfigMap definition which adds standard properties for ConfigMap. In our template we add the configuration, in this case the data key <code>myvalue</code> and its value. The configuration override the empty resource of the common ConfigMap. This is feasible because of the helper function <code>mylibchart.util.merge</code> we mentioned in the previous section.</p> <p>To be able to use the common code, we need to add <code>mylibchart</code> as a dependency. Add the following to the end of the file <code>mychart/Chart.yaml</code>:</p> <pre><code># My common code in my library chart\ndependencies:\n- name: mylibchart\n  version: 0.1.0\n  repository: file://../mylibchart\n</code></pre> <p>This includes the library chart as a dynamic dependency from the filesystem which is at the same parent path as our application chart. As we are including the library chart as a dynamic dependency, we need to run <code>helm dependency update</code>. It will copy the library chart into your <code>charts/</code> directory.</p> <pre><code>$ helm dependency update mychart/\nHang tight while we grab the latest from your chart repositories...\n...Successfully got an update from the \"stable\" chart repository\nUpdate Complete. \u2388Happy Helming!\u2388\nSaving 1 charts\nDeleting outdated charts\n</code></pre> <p>We are now ready to deploy our chart. Before installing, it is worth checking the rendered template first.</p> <pre><code>$ helm install mydemo mychart/ --debug --dry-run\ninstall.go:159: [debug] Original chart version: \"\"\ninstall.go:176: [debug] CHART PATH: /root/test/helm-charts/mychart\n\nNAME: mydemo\nLAST DEPLOYED: Tue Mar  3 17:48:47 2020\nNAMESPACE: default\nSTATUS: pending-install\nREVISION: 1\nTEST SUITE: None\nUSER-SUPPLIED VALUES:\n{}\n\nCOMPUTED VALUES:\naffinity: {}\nfullnameOverride: \"\"\nimage:\n  pullPolicy: IfNotPresent\n  repository: nginx\nimagePullSecrets: []\ningress:\n  annotations: {}\n  enabled: false\n  hosts:\n  - host: chart-example.local\n    paths: []\n  tls: []\nmylibchart:\n  global: {}\nnameOverride: \"\"\nnodeSelector: {}\npodSecurityContext: {}\nreplicaCount: 1\nresources: {}\nsecurityContext: {}\nservice:\n  port: 80\n  type: ClusterIP\nserviceAccount:\n  annotations: {}\n  create: true\n  name: null\ntolerations: []\n\nHOOKS:\nMANIFEST:\n---\n# Source: mychart/templates/configmap.yaml\napiVersion: v1\ndata:\n  myvalue: Hello World\nkind: ConfigMap\nmetadata:\n  labels:\n    app: mychart\n    chart: mychart-0.1.0\n    release: mydemo\n  name: mychart-mydemo\n</code></pre> <p>This looks like the ConfigMap we want with data override of <code>myvalue: Hello World</code>. Lets install it:</p> <pre><code>$ helm install mydemo mychart/\nNAME: mydemo\nLAST DEPLOYED: Tue Mar  3 17:52:40 2020\nNAMESPACE: default\nSTATUS: deployed\nREVISION: 1\nTEST SUITE: None\n</code></pre> <p>We can retrieve the release and see that the actual template was loaded.</p> <pre><code>$ helm get manifest mydemo\n---\n# Source: mychart/templates/configmap.yaml\napiVersion: v1\ndata:\n  myvalue: Hello World\nkind: ConfigMap\nmetadata:\n  labels:\n    app: mychart\n    chart: mychart-0.1.0\n    release: mydemo\n  name: mychart-mydemo\n  ```\n\n## Library Chart Benefits\nBecause of their inability to act as standalone charts, library charts can leverage the following functionality:\n- The `.Files` object references the file paths on the parent chart, rather than the path local to the library chart\n- The `.Values` object is the same as the parent chart, in contrast to application [subcharts]({{&lt; ref\n\"/docs/chart_template_guide/subcharts_and_globals.md\" &gt;}}) which receive the section of values configured under their header in the parent.\n\n\n## The Common Helm Helper Chart\n\n```markdown\nNote: The Common Helm Helper Chart repo on Github is no longer actively maintained, and the repo has been deprecated and archived.\n</code></pre> <p>This chart was the original pattern for common charts. It provides utilities that reflect best practices of Kubernetes chart development. Best of all it can be used off the bat by you when developing your charts to give you handy shared code.</p> <p>Here is a quick way to use it. For more details, have a look at the README.</p> <p>Create a scaffold chart again:</p> <pre><code>$ helm create demo\nCreating demo\n</code></pre> <p>Lets use the common code from the helper chart. First, edit deployment <code>demo/templates/deployment.yaml</code> as follows:</p> <pre><code>{{- template \"common.deployment\" (list . \"demo.deployment\") -}}\n{{- define \"demo.deployment\" -}}\n## Define overrides for your Deployment resource here, e.g.\napiVersion: apps/v1\nspec:\n  replicas: {{ .Values.replicaCount }}\n  selector:\n    matchLabels:\n      {{- include \"demo.selectorLabels\" . | nindent 6 }}\n  template:\n    metadata:\n      labels:\n        {{- include \"demo.selectorLabels\" . | nindent 8 }}\n\n{{- end -}}\n</code></pre> <p>And now the service file, <code>demo/templates/service.yaml</code> as follows:</p> <pre><code>{{- template \"common.service\" (list . \"demo.service\") -}}\n{{- define \"demo.service\" -}}\n## Define overrides for your Service resource here, e.g.\n# metadata:\n#   labels:\n#     custom: label\n# spec:\n#   ports:\n#   - port: 8080\n{{- end -}}\n</code></pre> <p>These templates show how inheriting the common code from the helper chart simplifies your coding down to your configuration or customization of the resources.</p> <p>To be able to use the common code, we need to add <code>common</code> as a dependency. Add the following to the end of the file <code>demo/Chart.yaml</code>:</p> <pre><code>dependencies:\n- name: common\n  version: \"^0.0.5\"\n  repository: \"https://charts.helm.sh/incubator/\"\n</code></pre> <p>Note: You will need to add the <code>incubator</code> repo to the Helm repository list (<code>helm repo add</code>).</p> <p>As we are including the chart as a dynamic dependency, we need to run <code>helm dependency update</code>. It will copy the helper chart into your <code>charts/</code> directory.</p> <p>As helper chart is using some Helm 2 constructs, you will need to add the following to <code>demo/values.yaml</code> to enable the <code>nginx</code> image to be loaded as this was updated in Helm 3 scaffold chart:</p> <pre><code>image:\n  tag: 1.16.0\n</code></pre> <p>You can test that the chart templates are correct prior to deploying using the <code>helm lint</code> and <code>helm template</code> commands.</p> <p>If it's good to go, deploy away using <code>helm install</code>!</p>"},{"location":"topics/permissions_sql_storage_backend/","title":"Permissions management for SQL storage backend","text":"<p>This document aims to provide guidance to users for setting up and managing permissions when using the SQL storage backend.</p>"},{"location":"topics/permissions_sql_storage_backend/#introduction","title":"Introduction","text":"<p>To handle permissions, Helm leverages the RBAC feature of Kubernetes. When using the SQL storage backend, Kubernetes' roles can't be used to determine whether or not an user can access a given resource. This document shows how to create and manage these permissions.</p>"},{"location":"topics/permissions_sql_storage_backend/#initialization","title":"Initialization","text":"<p>The first time the Helm CLI will make connect to your database, the client will make sure that it was previously initialized. If it is not, it will take care of the necessary setup automatically. This initialization requires admin privileges on the public schema, or at least to be able to:</p> <ul> <li>create a table</li> <li>grant privileges on the public schema</li> </ul> <p>After the migration was run against your database, all the other roles can use the client.</p>"},{"location":"topics/permissions_sql_storage_backend/#grant-privileges-to-a-non-admin-user-in-postgresql","title":"Grant privileges to a non admin user in PostgreSQL","text":"<p>To manage permissions, the SQL backend driver leverages the RLS(Row Security Level) feature of PostgreSQL. RLS allows all users to be able to read/write from/to the same table, without being able to manipulate the same rows if they are not explicitly allowed to. By default, any role that has not been explicitly granted with the right privileges will always return an empty list when running <code>helm list</code> and will not be able to retrieve or modify any resource in the cluster.</p> <p>Let's see how to grant a given role access to specific namespaces:</p> <pre><code>CREATE POLICY &lt;name&gt; ON releases_v1 FOR ALL TO &lt;role&gt; USING (namespace = 'default');\n</code></pre> <p>This command will grant the permissions to read and write all resources that meet the <code>namespace = 'default'</code> condition to the role <code>role</code>. After creating this policy, the user being connected to the database on the behalf of the role <code>role</code> will therefore be able to see all the releases living in the <code>default</code> namespace when running <code>helm list</code>, and to modify and delete them.</p> <p>Privileges can be managed granularly with RLS, and one might be interested in restraining access given the different columns of the table: * key * type * body * name * namespace * version * status * owner * createdAt * modifiedAt</p>"},{"location":"topics/plugins/","title":"The Helm Plugins Guide","text":"<p>A Helm plugin is a tool that can be accessed through the <code>helm</code> CLI, but which is not part of the built-in Helm codebase.</p> <p>Existing plugins can be found on [related]({{&lt; ref \"related.md#helm-plugins\"</p> <p>}}) section or by searching GitHub.</p> <p>This guide explains how to use and create plugins.</p>"},{"location":"topics/plugins/#an-overview","title":"An Overview","text":"<p>Helm plugins are add-on tools that integrate seamlessly with Helm. They provide a way to extend the core feature set of Helm, but without requiring every new feature to be written in Go and added to the core tool.</p> <p>Helm plugins have the following features:</p> <ul> <li>They can be added and removed from a Helm installation without impacting the   core Helm tool.</li> <li>They can be written in any programming language.</li> <li>They integrate with Helm, and will show up in <code>helm help</code> and other places.</li> </ul> <p>Helm plugins live in <code>$HELM_PLUGINS</code>. You can find the current value of this, including the default value when not set in the environment, using the <code>helm env</code> command.</p> <p>The Helm plugin model is partially based on Git's plugin model. To that end, you may sometimes hear <code>helm</code> referred to as the porcelain layer, with plugins being the plumbing. This is a shorthand way of suggesting that Helm provides the user experience and top level processing logic, while the plugins do the \"detail work\" of performing a desired action.</p>"},{"location":"topics/plugins/#installing-a-plugin","title":"Installing a Plugin","text":"<p>Plugins are installed using the <code>$ helm plugin install &lt;path|url&gt;</code> command. You can pass in a path to a plugin on your local file system or a url of a remote VCS repo. The <code>helm plugin install</code> command clones or copies the plugin at the path/url given into <code>$HELM_PLUGINS</code>. If you are installing from a VCS you can specify the version with the <code>--version</code> argument.</p> <pre><code>$ helm plugin install https://github.com/adamreese/helm-env\n</code></pre> <p>If you have a plugin tar distribution, simply untar the plugin into the <code>$HELM_PLUGINS</code> directory. You can also install tarball plugins directly from url by issuing <code>helm plugin install https://domain/path/to/plugin.tar.gz</code></p>"},{"location":"topics/plugins/#the-plugin-file-structure","title":"The Plugin File Structure","text":"<p>In many ways, a plugin is similar to a chart. Each plugin has a top-level directory containing a <code>plugin.yaml</code> file. Additonal files may be present but only the <code>plugin.yaml</code> file is required.</p> <pre><code>$HELM_PLUGINS/\n  |- last/\n      |- plugin.yaml\n</code></pre>"},{"location":"topics/plugins/#the-pluginyaml-file","title":"The plugin.yaml File","text":"<p>The plugin.yaml file is required for a plugin. It contains the following fields:</p> <pre><code>name: The name of the plugin (REQUIRED)\nversion: A SemVer 2 version (REQUIRED)\nusage: Single line usage text shown in help\ndescription: Long description shown in places like helm help\nignoreFlags: Ignore flags passed in from Helm\nplatformCommand: # Configure command to run based on the platform\n  - os: OS match, can be empty or ommited to match all OS'\n    arch: Architecture match, can be empty or ommited to match all architectures\n    command: Plugin command to execute\n    args: Plugin command arguments\ncommand: (DEPRECATED) Plugin command, use platformCommand instead\nplatformHooks: # Configure plugin lifecycle hooks based on the platform\n  install: # Install lifecycle commands\n    - os: OS match, can be empty or ommited to match all OS'\n      arch: Architecture match, can be empty or ommited to match all architectures\n      command: Plugin install command to execute\n      args: Plugin install command arguments\n  update: # Update lifecycle commands\n    - os: OS match, can be empty or ommited to match all OS'\n      arch: Architecture match, can be empty or ommited to match all architectures\n      command: Plugin update command to execute\n      args: Plugin update command arguments\n  delete: # Delete lifecycle commands\n    - os: OS match, can be empty or ommited to match all OS'\n      arch: Architecture match, can be empty or ommited to match all architectures\n      command: Plugin delete command to execute\n      args: Plugin delete command arguments\nhooks: # (Deprecated) Plugin lifecycle hooks, use platformHooks instead\n  install: Command to install plugin\n  update: Command to update plugin\n  delete: Command to delete plugin\ndownloaders: # Configure downloaders capability\n  - command: Command to invoke\n    protocols:\n      - Protocol schema supported\n</code></pre>"},{"location":"topics/plugins/#the-name-field","title":"The <code>name</code> Field","text":"<p>The <code>name</code> is the name of the plugin. When Helm executes this plugin, this is the name it will use (e.g. <code>helm NAME</code> will invoke this plugin).</p> <p><code>name</code> should match the directory name. In our example above, that means the plugin with <code>name: last</code> should be contained in a directory named <code>last</code>.</p> <p>Restrictions on <code>name</code>:</p> <ul> <li><code>name</code> cannot duplicate one of the existing <code>helm</code> top-level commands.</li> <li><code>name</code> must be restricted to the characters ASCII a-z, A-Z, 0-9, <code>_</code> and <code>-</code>.</li> </ul>"},{"location":"topics/plugins/#the-version-field","title":"The <code>version</code> Field","text":"<p>The <code>version</code> is the SemVer 2 version of the plugin. <code>usage</code> and <code>description</code> are both used to generate the help text of a command.</p>"},{"location":"topics/plugins/#the-ignoreflags-field","title":"The <code>ignoreFlags</code> Field","text":"<p>The <code>ignoreFlags</code> switch tells Helm to not pass flags to the plugin. So if a plugin is called with <code>helm myplugin --foo</code> and <code>ignoreFlags: true</code>, then <code>--foo</code> is silently discarded.</p>"},{"location":"topics/plugins/#the-platformcommand-field","title":"The <code>platformCommand</code> Field","text":"<p>The <code>platformCommand</code> configures the command that the plugin will execute when it is called. You can't set both <code>platformCommand</code> &amp; <code>command</code> as this will result in an error. The following rules will apply in deciding which command to use:</p> <ul> <li>If <code>platformCommand</code> is present, it will be used.</li> <li>If both <code>os</code> and <code>arch</code> match the current platform, search will stop and the   command will be used.</li> <li>If <code>os</code> matches and <code>arch</code> is empty, the command will be used.</li> <li>If <code>os</code> and <code>arch</code> are both empty, the command will be used.</li> <li>If there is no match, Helm will exit with an error.</li> <li>If <code>platformCommand</code> is not present and the deprecated <code>command</code> is present it will be used.</li> <li>If the command is empty, Helm will exit with an error.</li> </ul>"},{"location":"topics/plugins/#the-platformhooks-field","title":"The <code>platformHooks</code> Field","text":"<p>The <code>platformHooks</code> configures the commands that the plugin will execute for lifecycle events. You can't set both <code>platformHooks</code> &amp; <code>hooks</code> as this will resultin an error. The following rules will apply in deciding which hook command to use:</p> <ul> <li>If <code>platformHooks</code> is present, it will be used and the commands for the lifecycle event will be processed.</li> <li>If both <code>os</code> and <code>arch</code> match the current platform, search will stop and the   command will be used.</li> <li>If <code>os</code> matches and <code>arch</code> is empty, the command will be used.</li> <li>If <code>os</code> and <code>arch</code> are both empty, the command will be used.</li> <li>If there is no match, Helm will skip the event.</li> <li>If <code>platformHooks</code> is not present and the deprecated <code>hooks</code> is present the command for the lifecycle event will be used.</li> <li>If the command is empty, Helm will skip the event.</li> </ul>"},{"location":"topics/plugins/#building-a-plugin","title":"Building a Plugin","text":"<p>Here is the plugin YAML for a simple plugin that helps get the last release name:</p> <pre><code>name: last\nversion: 0.1.0\nusage: get the last release name\ndescription: get the last release name\nignoreFlags: false\nplatformCommand:\n  - command: ${HELM_BIN}\n    args:\n      - list\n      - --short\n      - --max=1\n      - --date\n      - -r\n</code></pre> <p>Plugins may require additional scripts and executables. Scripts can be included in the plugin directory and executables can be downloaded via a hook. The following is an example plugin:</p> <pre><code>$HELM_PLUGINS/\n  |- myplugin/\n    |- scripts/\n      |- install.ps1\n      |- install.sh\n    |- plugin.yaml\n</code></pre> <pre><code>name: myplugin\nversion: 0.1.0\nusage: example plugin\ndescription: example plugin\nignoreFlags: false\nplatformCommand:\n  - command: ${HELM_PLUGIN_DIR}/bin/myplugin\n  - os: windows\n    command: ${HELM_PLUGIN_DIR}\\bin\\myplugin.exe\nplatformHooks:\n  install:\n    - command: ${HELM_PLUGIN_DIR}/scripts/install.sh\n    - os: windows\n      command: pwsh\n      args:\n        - -c\n        - ${HELM_PLUGIN_DIR}\\scripts\\install.ps1\n  update:\n    - command: ${HELM_PLUGIN_DIR}/scripts/install.sh\n      args:\n        - -u\n    - os: windows\n      command: pwsh\n      args:\n        - -c\n        - ${HELM_PLUGIN_DIR}\\scripts\\install.ps1\n        - -Update\n</code></pre> <p>Environment variables are interpolated before the plugin is executed. The pattern above illustrates the preferred way to indicate where the plugin program lives.</p>"},{"location":"topics/plugins/#plugin-commands","title":"Plugin Commands","text":"<p>There are some strategies for working with plugin commands:</p> <ul> <li>If a plugin includes an executable, the executable for a <code>platformCommand:</code> or   should be packaged in the plugin directory or installed via a hook.</li> <li>The <code>platformCommand:</code> or <code>command:</code> line will have any environment variables   expanded before execution. <code>$HELM_PLUGIN_DIR</code> will point to the plugin   directory.</li> <li>The command itself is not executed in a shell. So you can't oneline a shell   script.</li> <li>Helm injects lots of configuration into environment variables. Take a look at   the environment to see what information is available.</li> <li>Helm makes no assumptions about the language of the plugin. You can write it   in whatever you prefer.</li> <li>Commands are responsible for implementing specific help text for <code>-h</code> and   <code>--help</code>. Helm will use <code>usage</code> and <code>description</code> for <code>helm help</code> and <code>helm   help myplugin</code>, but will not handle <code>helm myplugin --help</code>.</li> </ul>"},{"location":"topics/plugins/#testing-a-local-plugin","title":"Testing a Local Plugin","text":"<p>First you need to find your <code>HELM_PLUGINS</code> path to do it run the folowing command:</p> <pre><code>helm env\n</code></pre> <p>Change your current directory to the director that <code>HELM_PLUGINS</code> is set to.</p> <p>Now you can add a symbolic link to your build output of your plugin in this example we did it for <code>mapkubeapis</code>.</p> <pre><code>ln -s ~/GitHub/helm-mapkubeapis ./helm-mapkubeapis\n</code></pre>"},{"location":"topics/plugins/#downloader-plugins","title":"Downloader Plugins","text":"<p>By default, Helm is able to pull Charts using HTTP/S. As of Helm 2.4.0, plugins can have a special capability to download Charts from arbitrary sources.</p> <p>Plugins shall declare this special capability in the <code>plugin.yaml</code> file (top level):</p> <pre><code>downloaders:\n- command: \"bin/mydownloader\"\n  protocols:\n  - \"myprotocol\"\n  - \"myprotocols\"\n</code></pre> <p>If such plugin is installed, Helm can interact with the repository using the specified protocol scheme by invoking the <code>command</code>. The special repository shall be added similarly to the regular ones: <code>helm repo add favorite myprotocol://example.com/</code> The rules for the special repos are the same to the regular ones: Helm must be able to download the <code>index.yaml</code> file in order to discover and cache the list of available Charts.</p> <p>The defined command will be invoked with the following scheme: <code>command certFile keyFile caFile full-URL</code>. The SSL credentials are coming from the repo definition, stored in <code>$HELM_REPOSITORY_CONFIG</code> (i.e., <code>$HELM_CONFIG_HOME/repositories.yaml</code>). A Downloader plugin is expected to dump the raw content to stdout and report errors on stderr.</p> <p>The downloader command also supports sub-commands or arguments, allowing you to specify for example <code>bin/mydownloader subcommand -d</code> in the <code>plugin.yaml</code>. This is useful if you want to use the same executable for the main plugin command and the downloader command, but with a different sub-command for each.</p>"},{"location":"topics/plugins/#environment-variables","title":"Environment Variables","text":"<p>When Helm executes a plugin, it passes the outer environment to the plugin, and also injects some additional environment variables.</p> <p>Variables like <code>KUBECONFIG</code> are set for the plugin if they are set in the outer environment.</p> <p>The following variables are guaranteed to be set:</p> <ul> <li><code>HELM_PLUGINS</code>: The path to the plugins directory.</li> <li><code>HELM_PLUGIN_NAME</code>: The name of the plugin, as invoked by <code>helm</code>. So <code>helm   myplug</code> will have the short name <code>myplug</code>.</li> <li><code>HELM_PLUGIN_DIR</code>: The directory that contains the plugin.</li> <li><code>HELM_BIN</code>: The path to the <code>helm</code> command (as executed by the user).</li> <li><code>HELM_DEBUG</code>: Indicates if the debug flag was set by helm.</li> <li><code>HELM_REGISTRY_CONFIG</code>: The location for the registry configuration (if   using). Note that the use of Helm with registries is an experimental feature.</li> <li><code>HELM_REPOSITORY_CACHE</code>: The path to the repository cache files.</li> <li><code>HELM_REPOSITORY_CONFIG</code>: The path to the repository configuration file.</li> <li><code>HELM_NAMESPACE</code>: The namespace given to the <code>helm</code> command (generally using   the <code>-n</code> flag).</li> <li><code>HELM_KUBECONTEXT</code>: The name of the Kubernetes config context given to the   <code>helm</code> command.</li> </ul> <p>Additionally, if a Kubernetes configuration file was explicitly specified, it will be set as the <code>KUBECONFIG</code> variable</p>"},{"location":"topics/plugins/#a-note-on-flag-parsing","title":"A Note on Flag Parsing","text":"<p>When executing a plugin, Helm will parse global flags for its own use. None of these flags are passed on to the plugin. - <code>--burst-limit</code>: This is converted to <code>$HELM_BURST_LIMIT</code> - <code>--debug</code>: If this is specified, <code>$HELM_DEBUG</code> is set to <code>1</code> - <code>--kube-apiserver</code>: This is converted to <code>$HELM_KUBEAPISERVER</code> - <code>--kube-as-group</code>: These are converted to <code>$HELM_KUBEASGROUPS</code> - <code>--kube-as-user</code>: This is converted to <code>$HELM_KUBEASUSER</code> - <code>--kube-ca-file</code>: This is converted to <code>$HELM_KUBECAFILE</code> - <code>--kube-context</code>: This is converted to <code>$HELM_KUBECONTEXT</code> - <code>--kube-insecure-skip-tls-verify</code>: This is converted to <code>$HELM_KUBEINSECURE_SKIP_TLS_VERIFY</code> - <code>--kube-tls-server-name</code>: This is converted to <code>$HELM_KUBETLS_SERVER_NAME</code> - <code>--kube-token</code>: This is converted to <code>$HELM_KUBETOKEN</code> - <code>--kubeconfig</code>: This is converted to <code>$KUBECONFIG</code> - <code>--namespace</code> and <code>-n</code>: This is converted to <code>$HELM_NAMESPACE</code> - <code>--qps</code>: This is converted to <code>$HELM_QPS</code> - <code>--registry-config</code>: This is converted to <code>$HELM_REGISTRY_CONFIG</code> - <code>--repository-cache</code>: This is converted to <code>$HELM_REPOSITORY_CACHE</code> - <code>--repository-config</code>: This is converted to <code>$HELM_REPOSITORY_CONFIG</code></p> <p>Plugins should display help text and then exit for <code>-h</code> and <code>--help</code>. In all other cases, plugins may use flags as appropriate.</p>"},{"location":"topics/plugins/#providing-shell-auto-completion","title":"Providing shell auto-completion","text":"<p>As of Helm 3.2, a plugin can optionally provide support for shell auto-completion as part of Helm's existing auto-completion mechanism.</p>"},{"location":"topics/plugins/#static-auto-completion","title":"Static auto-completion","text":"<p>If a plugin provides its own flags and/or sub-commands, it can inform Helm of them by having a <code>completion.yaml</code> file located in the plugin's root directory. The <code>completion.yaml</code> file has the form:</p> <pre><code>name: &lt;pluginName&gt;\nflags:\n- &lt;flag 1&gt;\n- &lt;flag 2&gt;\nvalidArgs:\n- &lt;arg value 1&gt;\n- &lt;arg value 2&gt;\ncommands:\n  name: &lt;commandName&gt;\n  flags:\n  - &lt;flag 1&gt;\n  - &lt;flag 2&gt;\n  validArgs:\n  - &lt;arg value 1&gt;\n  - &lt;arg value 2&gt;\n  commands:\n     &lt;and so on, recursively&gt;\n</code></pre> <p>Notes:</p> <ol> <li>All sections are optional but should be provided if applicable.</li> <li>Flags should not include the <code>-</code> or <code>--</code> prefix.</li> <li>Both short and long flags can and should be specified. A short flag need not    be associated with its corresponding long form, but both forms should be    listed.</li> <li>Flags need not be ordered in any way, but need to be listed at the correct    point in the sub-command hierarchy of the file.</li> <li>Helm's existing global flags are already handled by Helm's auto-completion    mechanism, therefore plugins need not specify the following flags <code>--debug</code>,    <code>--namespace</code> or <code>-n</code>, <code>--kube-context</code>, and <code>--kubeconfig</code>, or any other    global flag.</li> <li>The <code>validArgs</code> list provides a static list of possible completions for the    first parameter following a sub-command.  It is not always possible to    provide such a list in advance (see the Dynamic    Completion section below), in which case the    <code>validArgs</code> section can be omitted.</li> </ol> <p>The <code>completion.yaml</code> file is entirely optional.  If it is not provided, Helm will simply not provide shell auto-completion for the plugin (unless Dynamic Completion is supported by the plugin).  Also, adding a <code>completion.yaml</code> file is backwards-compatible and will not impact the behavior of the plugin when using older helm versions.</p> <p>As an example, for the <code>fullstatus plugin</code> which has no sub-commands but accepts the same flags as the <code>helm status</code> command, the <code>completion.yaml</code> file is:</p> <pre><code>name: fullstatus\nflags:\n- o\n- output\n- revision\n</code></pre> <p>A more intricate example for the <code>2to3 plugin</code>, has a <code>completion.yaml</code> file of:</p> <pre><code>name: 2to3\ncommands:\n- name: cleanup\n  flags:\n  - config-cleanup\n  - dry-run\n  - l\n  - label\n  - release-cleanup\n  - s\n  - release-storage\n  - tiller-cleanup\n  - t\n  - tiller-ns\n  - tiller-out-cluster\n- name: convert\n  flags:\n  - delete-v2-releases\n  - dry-run\n  - l\n  - label\n  - s\n  - release-storage\n  - release-versions-max\n  - t\n  - tiller-ns\n  - tiller-out-cluster\n- name: move\n  commands:\n  - name: config\n    flags:\n    - dry-run\n</code></pre>"},{"location":"topics/plugins/#dynamic-completion","title":"Dynamic completion","text":"<p>Also starting with Helm 3.2, plugins can provide their own dynamic shell auto-completion. Dynamic shell auto-completion is the completion of parameter values or flag values that cannot be defined in advance.  For example, completion of the names of helm releases currently available on the cluster.</p> <p>For the plugin to support dynamic auto-completion, it must provide an executable file called <code>plugin.complete</code> in its root directory. When the Helm completion script requires dynamic completions for the plugin, it will execute the <code>plugin.complete</code> file, passing it the command-line that needs to be completed.  The <code>plugin.complete</code> executable will need to have the logic to determine what the proper completion choices are and output them to standard output to be consumed by the Helm completion script.</p> <p>The <code>plugin.complete</code> file is entirely optional.  If it is not provided, Helm will simply not provide dynamic auto-completion for the plugin.  Also, adding a <code>plugin.complete</code> file is backwards-compatible and will not impact the behavior of the plugin when using older helm versions.</p> <p>The output of the <code>plugin.complete</code> script should be a new-line separated list such as:</p> <pre><code>rel1\nrel2\nrel3\n</code></pre> <p>When <code>plugin.complete</code> is called, the plugin environment is set just like when the plugin's main script is called. Therefore, the variables <code>$HELM_NAMESPACE</code>, <code>$HELM_KUBECONTEXT</code>, and all other plugin variables will already be set, and their corresponding global flags will be removed.</p> <p>The <code>plugin.complete</code> file can be in any executable form; it can be a shell script, a Go program, or any other type of program that Helm can execute. The <code>plugin.complete</code> file must have executable permissions for the user. The <code>plugin.complete</code> file must exit with a success code (value 0).</p> <p>In some cases, dynamic completion will require to obtain information from the Kubernetes cluster.  For example, the <code>helm fullstatus</code> plugin requires a release name as input. In the <code>fullstatus</code> plugin, for its <code>plugin.complete</code> script to provide completion for current release names, it can simply run <code>helm list -q</code> and output the result.</p> <p>If it is desired to use the same executable for plugin execution and for plugin completion, the <code>plugin.complete</code> script can be made to call the main plugin executable with some special parameter or flag; when the main plugin executable detects the special parameter or flag, it will know to run the completion. In our example, <code>plugin.complete</code> could be implemented like this:</p> <pre><code>#!/usr/bin/env sh\n\n# \"$@\" is the entire command-line that requires completion.\n# It is important to double-quote the \"$@\" variable to preserve a possibly empty last parameter.\n$HELM_PLUGIN_DIR/status.sh --complete \"$@\"\n</code></pre> <p>The <code>fullstatus</code> plugin's real script (<code>status.sh</code>) must then look for the <code>--complete</code> flag and if found, printout the proper completions.</p>"},{"location":"topics/plugins/#tips-and-tricks","title":"Tips and tricks","text":"<ol> <li>The shell will automatically filter out completion choices that don't match    user input. A plugin can therefore return all relevant completions without    removing the ones that don't match the user input.  For example, if the    command-line is <code>helm fullstatus ngin&lt;TAB&gt;</code>, the <code>plugin.complete</code> script can    print all release names (of the <code>default</code> namespace), not just the ones    starting with <code>ngin</code>; the shell will only retain the ones starting with    <code>ngin</code>.</li> <li>To simplify dynamic completion support, especially if you have a complex    plugin, you can have your  <code>plugin.complete</code> script call your main plugin    script and request completion choices.  See the Dynamic    Completion section above for an example.</li> <li>To debug dynamic completion and the <code>plugin.complete</code> file, one can run the    following to see the completion results :<ul> <li><code>helm __complete &lt;pluginName&gt; &lt;arguments to complete&gt;</code>.  For example:</li> <li><code>helm __complete fullstatus --output js&lt;ENTER&gt;</code>,</li> <li><code>helm __complete fullstatus -o json \"\"&lt;ENTER&gt;</code></li> </ul> </li> </ol>"},{"location":"topics/provenance/","title":"Helm Provenance and Integrity","text":"<p>Helm has provenance tools which help chart users verify the integrity and origin of a package. Using industry-standard tools based on PKI, GnuPG, and well-respected package managers, Helm can generate and verify signature files.</p>"},{"location":"topics/provenance/#overview","title":"Overview","text":"<p>Integrity is established by comparing a chart to a provenance record. Provenance records are stored in provenance files, which are stored alongside a packaged chart. For example, if a chart is named <code>myapp-1.2.3.tgz</code>, its provenance file will be <code>myapp-1.2.3.tgz.prov</code>.</p> <p>Provenance files are generated at packaging time (<code>helm package --sign ...</code>), and can be checked by multiple commands, notably <code>helm install --verify</code>.</p>"},{"location":"topics/provenance/#the-workflow","title":"The Workflow","text":"<p>This section describes a potential workflow for using provenance data effectively.</p> <p>Prerequisites:</p> <ul> <li>A valid PGP keypair in a binary (not ASCII-armored) format</li> <li>The <code>helm</code> command line tool</li> <li>GnuPG command line tools (optional)</li> <li>Keybase command line tools (optional)</li> </ul> <p>NOTE: If your PGP private key has a passphrase, you will be prompted to enter that passphrase for any commands that support the <code>--sign</code> option.</p> <p>Creating a new chart is the same as before:</p> <pre><code>$ helm create mychart\nCreating mychart\n</code></pre> <p>Once ready to package, add the <code>--sign</code> flag to <code>helm package</code>. Also, specify the name under which the signing key is known and the keyring containing the corresponding private key:</p> <pre><code>$ helm package --sign --key 'John Smith' --keyring path/to/keyring.secret mychart\n</code></pre> <p>Note: The value of the <code>--key</code> argument must be a substring of the desired key's <code>uid</code> (in the output of <code>gpg --list-keys</code>), for example the name or email. The fingerprint cannot be used.</p> <p>TIP: for GnuPG users, your secret keyring is in <code>~/.gnupg/secring.gpg</code>. You can use <code>gpg --list-secret-keys</code> to list the keys you have.</p> <p>Warning:  the GnuPG v2 store your secret keyring using a new format <code>kbx</code> on the default location  <code>~/.gnupg/pubring.kbx</code>. Please use the following command to convert your keyring to the legacy gpg format:</p> <pre><code>$ gpg --export &gt;~/.gnupg/pubring.gpg\n$ gpg --export-secret-keys &gt;~/.gnupg/secring.gpg\n</code></pre> <p>At this point, you should see both <code>mychart-0.1.0.tgz</code> and <code>mychart-0.1.0.tgz.prov</code>. Both files should eventually be uploaded to your desired chart repository.</p> <p>You can verify a chart using <code>helm verify</code>:</p> <pre><code>$ helm verify mychart-0.1.0.tgz\n</code></pre> <p>A failed verification looks like this:</p> <pre><code>$ helm verify topchart-0.1.0.tgz\nError: sha256 sum does not match for topchart-0.1.0.tgz: \"sha256:1939fbf7c1023d2f6b865d137bbb600e0c42061c3235528b1e8c82f4450c12a7\" != \"sha256:5a391a90de56778dd3274e47d789a2c84e0e106e1a37ef8cfa51fd60ac9e623a\"\n</code></pre> <p>To verify during an install, use the <code>--verify</code> flag.</p> <pre><code>$ helm install --generate-name --verify mychart-0.1.0.tgz\n</code></pre> <p>If the keyring containing the public key associated with the signed chart is not in the default location, you may need to point to the keyring with <code>--keyring PATH</code> as in the <code>helm package</code> example.</p> <p>If verification fails, the install will be aborted before the chart is even rendered.</p>"},{"location":"topics/provenance/#using-keybaseio-credentials","title":"Using Keybase.io credentials","text":"<p>The Keybase.io service makes it easy to establish a chain of trust for a cryptographic identity. Keybase credentials can be used to sign charts.</p> <p>Prerequisites:</p> <ul> <li>A configured Keybase.io account</li> <li>GnuPG installed locally</li> <li>The <code>keybase</code> CLI installed locally</li> </ul>"},{"location":"topics/provenance/#signing-packages","title":"Signing packages","text":"<p>The first step is to import your keybase keys into your local GnuPG keyring:</p> <pre><code>$ keybase pgp export -s | gpg --import\n</code></pre> <p>This will convert your Keybase key into the OpenPGP format, and then import it locally into your <code>~/.gnupg/secring.gpg</code> file.</p> <p>You can double check by running <code>gpg --list-secret-keys</code>.</p> <pre><code>$ gpg --list-secret-keys\n/Users/mattbutcher/.gnupg/secring.gpg\n-------------------------------------\nsec   2048R/1FC18762 2016-07-25\nuid                  technosophos (keybase.io/technosophos) &lt;technosophos@keybase.io&gt;\nssb   2048R/D125E546 2016-07-25\n</code></pre> <p>Note that your secret key will have an identifier string:</p> <pre><code>technosophos (keybase.io/technosophos) &lt;technosophos@keybase.io&gt;\n</code></pre> <p>That is the full name of your key.</p> <p>Next, you can package and sign a chart with <code>helm package</code>. Make sure you use at least part of that name string in <code>--key</code>.</p> <pre><code>$ helm package --sign --key technosophos --keyring ~/.gnupg/secring.gpg mychart\n</code></pre> <p>As a result, the <code>package</code> command should produce both a <code>.tgz</code> file and a <code>.tgz.prov</code> file.</p>"},{"location":"topics/provenance/#verifying-packages","title":"Verifying packages","text":"<p>You can also use a similar technique to verify a chart signed by someone else's Keybase key. Say you want to verify a package signed by <code>keybase.io/technosophos</code>. To do this, use the <code>keybase</code> tool:</p> <pre><code>$ keybase follow technosophos\n$ keybase pgp pull\n</code></pre> <p>The first command above tracks the user <code>technosophos</code>. Next <code>keybase pgp pull</code> downloads the OpenPGP keys of all of the accounts you follow, placing them in your GnuPG keyring (<code>~/.gnupg/pubring.gpg</code>).</p> <p>At this point, you can now use <code>helm verify</code> or any of the commands with a <code>--verify</code> flag:</p> <pre><code>$ helm verify somechart-1.2.3.tgz\n</code></pre>"},{"location":"topics/provenance/#reasons-a-chart-may-not-verify","title":"Reasons a chart may not verify","text":"<p>These are common reasons for failure.</p> <ul> <li>The <code>.prov</code> file is missing or corrupt. This indicates that something is   misconfigured or that the original maintainer did not create a provenance   file.</li> <li>The key used to sign the file is not in your keyring. This indicate that the   entity who signed the chart is not someone you've already signaled that you   trust.</li> <li>The verification of the <code>.prov</code> file failed. This indicates that something is   wrong with either the chart or the provenance data.</li> <li>The file hashes in the provenance file do not match the hash of the archive   file. This indicates that the archive has been tampered with.</li> </ul> <p>If a verification fails, there is reason to distrust the package.</p>"},{"location":"topics/provenance/#the-provenance-file","title":"The Provenance File","text":"<p>The provenance file contains a chart\u2019s YAML file plus several pieces of verification information. Provenance files are designed to be automatically generated.</p> <p>The following pieces of provenance data are added:</p> <ul> <li>The chart file (<code>Chart.yaml</code>) is included to give both humans and tools an   easy view into the contents of the chart.</li> <li>The signature (SHA256, just like Docker) of the chart package (the <code>.tgz</code>   file) is included, and may be used to verify the integrity of the chart   package.</li> <li>The entire body is signed using the algorithm used by OpenPGP (see   Keybase.io for an emerging way of making crypto   signing and verification easy).</li> </ul> <p>The combination of this gives users the following assurances:</p> <ul> <li>The package itself has not been tampered with (checksum package <code>.tgz</code>).</li> <li>The entity who released this package is known (via the GnuPG/PGP signature).</li> </ul> <p>The format of the file looks something like this:</p> <pre><code>Hash: SHA512\n\napiVersion: v2\nappVersion: \"1.16.0\"\ndescription: Sample chart\nname: mychart\ntype: application\nversion: 0.1.0\n\n...\nfiles:\n  mychart-0.1.0.tgz: sha256:d31d2f08b885ec696c37c7f7ef106709aaf5e8575b6d3dc5d52112ed29a9cb92\n-----BEGIN PGP SIGNATURE-----\n\nwsBcBAEBCgAQBQJdy0ReCRCEO7+YH8GHYgAAfhUIADx3pHHLLINv0MFkiEYpX/Kd\nnvHFBNps7hXqSocsg0a9Fi1LRAc3OpVh3knjPfHNGOy8+xOdhbqpdnB+5ty8YopI\nmYMWp6cP/Mwpkt7/gP1ecWFMevicbaFH5AmJCBihBaKJE4R1IX49/wTIaLKiWkv2\ncR64bmZruQPSW83UTNULtdD7kuTZXeAdTMjAK0NECsCz9/eK5AFggP4CDf7r2zNi\nhZsNrzloIlBZlGGns6mUOTO42J/+JojnOLIhI3Psd0HBD2bTlsm/rSfty4yZUs7D\nqtgooNdohoyGSzR5oapd7fEvauRQswJxOA0m0V+u9/eyLR0+JcYB8Udi1prnWf8=\n=aHfz\n-----END PGP SIGNATURE-----\n</code></pre> <p>Note that the YAML section contains two documents (separated by <code>...\\n</code>). The first file is the content of <code>Chart.yaml</code>. The second is the checksums, a map of filenames to SHA-256 digests of that file's content at packaging time.</p> <p>The signature block is a standard PGP signature, which provides tamper resistance.</p>"},{"location":"topics/provenance/#chart-repositories","title":"Chart Repositories","text":"<p>Chart repositories serve as a centralized collection of Helm charts.</p> <p>Chart repositories must make it possible to serve provenance files over HTTP via a specific request, and must make them available at the same URI path as the chart.</p> <p>For example, if the base URL for a package is <code>https://example.com/charts/mychart-1.2.3.tgz</code>, the provenance file, if it exists, MUST be accessible at <code>https://example.com/charts/mychart-1.2.3.tgz.prov</code>.</p> <p>From the end user's perspective, <code>helm install --verify myrepo/mychart-1.2.3</code> should result in the download of both the chart and the provenance file with no additional user configuration or action.</p>"},{"location":"topics/provenance/#signatures-in-oci-based-registries","title":"Signatures in OCI-based registries","text":"<p>When publishing charts to an OCI-based registry, the <code>helm-sigstore</code> plugin can be used  to publish provenance to sigstore.  As described in the documentation, the process of creating provenance and signing with a GPG key are common, but the <code>helm sigstore upload</code> command can be used to publish the provenance to an immutable transparency log.</p>"},{"location":"topics/provenance/#establishing-authority-and-authenticity","title":"Establishing Authority and Authenticity","text":"<p>When dealing with chain-of-trust systems, it is important to be able to establish the authority of a signer. Or, to put this plainly, the system above hinges on the fact that you trust the person who signed the chart. That, in turn, means you need to trust the public key of the signer.</p> <p>One of the design decisions with Helm has been that the Helm project would not insert itself into the chain of trust as a necessary party. We don't want to be \"the certificate authority\" for all chart signers. Instead, we strongly favor a decentralized model, which is part of the reason we chose OpenPGP as our foundational technology. So when it comes to establishing authority, we have left this step more-or-less undefined in Helm 2 (a decision carried forward in Helm 3).</p> <p>However, we have some pointers and recommendations for those interested in using the provenance system:</p> <ul> <li>The Keybase platform provides a public centralized   repository for trust information.</li> <li>You can use Keybase to store your keys or to get the public keys of others.</li> <li>Keybase also has fabulous documentation available</li> <li>While we haven't tested it, Keybase's \"secure website\" feature could be used     to serve Helm charts.</li> <li>The basic idea is that an official \"chart reviewer\" signs charts with her or     his key, and the resulting provenance file is then uploaded to the chart     repository.</li> <li>There has been some work on the idea that a list of valid signing keys may     be included in the <code>index.yaml</code> file of a repository.</li> </ul>"},{"location":"topics/rbac/","title":"Role-based Access Control","text":"<p>In Kubernetes, granting roles to a user or an application-specific service account is a best practice to ensure that your application is operating in the scope that you have specified. Read more about service account permissions in the official Kubernetes docs.</p> <p>From Kubernetes 1.6 onwards, Role-based Access Control is enabled by default. RBAC allows you to specify which types of actions are permitted depending on the user and their role in your organization.</p> <p>With RBAC, you can</p> <ul> <li>grant privileged operations (creating cluster-wide resources, like new roles)   to administrators</li> <li>limit a user's ability to create resources (pods, persistent volumes,   deployments) to specific namespaces, or in cluster-wide scopes (resource   quotas, roles, custom resource definitions)</li> <li>limit a user's ability to view resources either in specific namespaces or at a   cluster-wide scope.</li> </ul> <p>This guide is for administrators who want to restrict the scope of a user's interaction with the Kubernetes API.</p>"},{"location":"topics/rbac/#managing-user-accounts","title":"Managing user accounts","text":"<p>All Kubernetes clusters have two categories of users: service accounts managed by Kubernetes, and normal users.</p> <p>Normal users are assumed to be managed by an outside, independent service. An administrator distributing private keys, a user store like Keystone or Google Accounts, even a file with a list of usernames and passwords. In this regard, Kubernetes does not have objects which represent normal user accounts. Normal users cannot be added to a cluster through an API call.</p> <p>In contrast, service accounts are users managed by the Kubernetes API. They are bound to specific namespaces, and created automatically by the API server or manually through API calls. Service accounts are tied to a set of credentials stored as Secrets, which are mounted into pods allowing in-cluster processes to talk to the Kubernetes API.</p> <p>API requests are tied to either a normal user or a service account, or are treated as anonymous requests. This means every process inside or outside the cluster, from a human user typing <code>kubectl</code> on a workstation, to kubelets on nodes, to members of the control plane, must authenticate when making requests to the API server, or be treated as an anonymous user.</p>"},{"location":"topics/rbac/#roles-clusterroles-rolebindings-and-clusterrolebindings","title":"Roles, ClusterRoles, RoleBindings, and ClusterRoleBindings","text":"<p>In Kubernetes, user accounts and service accounts can only view and edit resources they have been granted access to. This access is granted through the use of Roles and RoleBindings. Roles and RoleBindings are bound to a particular namespace, which grant users the ability to view and/or edit resources within that namespace the Role provides them access to.</p> <p>At a cluster scope, these are called ClusterRoles and ClusterRoleBindings. Granting a user a ClusterRole grants them access to view and/or edit resources across the entire cluster. It is also required to view and/or edit resources at the cluster scope (namespaces, resource quotas, nodes).</p> <p>ClusterRoles can be bound to a particular namespace through reference in a RoleBinding. The <code>admin</code>, <code>edit</code> and <code>view</code> default ClusterRoles are commonly used in this manner.</p> <p>These are a few ClusterRoles available by default in Kubernetes. They are intended to be user-facing roles. They include super-user roles (<code>cluster-admin</code>), and roles with more granular access (<code>admin</code>, <code>edit</code>, <code>view</code>).</p> Default ClusterRole Default ClusterRoleBinding Description <code>cluster-admin</code> <code>system:masters</code> group Allows super-user access to perform any action on any resource. When used in a ClusterRoleBinding, it gives full control over every resource in the cluster and in all namespaces. When used in a RoleBinding, it gives full control over every resource in the rolebinding's namespace, including the namespace itself. <code>admin</code> None Allows admin access, intended to be granted within a namespace using a RoleBinding. If used in a RoleBinding, allows read/write access to most resources in a namespace, including the ability to create roles and rolebindings within the namespace. It does not allow write access to resource quota or to the namespace itself. <code>edit</code> None Allows read/write access to most objects in a namespace. It does not allow viewing or modifying roles or rolebindings. <code>view</code> None Allows read-only access to see most objects in a namespace. It does not allow viewing roles or rolebindings. It does not allow viewing secrets, since those are escalating."},{"location":"topics/rbac/#restricting-a-user-accounts-access-using-rbac","title":"Restricting a user account's access using RBAC","text":"<p>Now that we understand the basics of Role-based Access Control, let's discuss how an administrator can restrict a user's scope of access.</p>"},{"location":"topics/rbac/#example-grant-a-user-readwrite-access-to-a-particular-namespace","title":"Example: Grant a user read/write access to a particular namespace","text":"<p>To restrict a user's access to a particular namespace, we can use either the <code>edit</code> or the <code>admin</code> role. If your charts create or interact with Roles and Rolebindings, you'll want to use the <code>admin</code> ClusterRole.</p> <p>Additionally, you may also create a RoleBinding with <code>cluster-admin</code> access. Granting a user <code>cluster-admin</code> access at the namespace scope provides full control over every resource in the namespace, including the namespace itself.</p> <p>For this example, we will create a user with the <code>edit</code> Role. First, create the namespace:</p> <pre><code>$ kubectl create namespace foo\n</code></pre> <p>Now, create a RoleBinding in that namespace, granting the user the <code>edit</code> role.</p> <pre><code>$ kubectl create rolebinding sam-edit\n    --clusterrole edit \\\u200b\n    --user sam \\\u200b\n    --namespace foo\n</code></pre>"},{"location":"topics/rbac/#example-grant-a-user-readwrite-access-at-the-cluster-scope","title":"Example: Grant a user read/write access at the cluster scope","text":"<p>If a user wishes to install a chart that installs cluster-scope resources (namespaces, roles, custom resource definitions, etc.), they will require cluster-scope write access.</p> <p>To do that, grant the user either <code>admin</code> or <code>cluster-admin</code> access.</p> <p>Granting a user <code>cluster-admin</code> access grants them access to absolutely every resource available in Kubernetes, including node access with <code>kubectl drain</code> and other administrative tasks. It is highly recommended to consider providing the user <code>admin</code> access instead, or to create a custom ClusterRole tailored to their needs.</p> <pre><code>$ kubectl create clusterrolebinding sam-view\n    --clusterrole view \\\u200b\n    --user sam\n\n$ kubectl create clusterrolebinding sam-secret-reader\n    --clusterrole secret-reader \\\u200b\n    --user sam\n</code></pre>"},{"location":"topics/rbac/#example-grant-a-user-read-only-access-to-a-particular-namespace","title":"Example: Grant a user read-only access to a particular namespace","text":"<p>You might've noticed that there is no ClusterRole available for viewing secrets. The <code>view</code> ClusterRole does not grant a user read access to Secrets due to escalation concerns. Helm stores release metadata as Secrets by default.</p> <p>In order for a user to run <code>helm list</code>, they need to be able to read these secrets. For that, we will create a special <code>secret-reader</code> ClusterRole.</p> <p>Create the file <code>cluster-role-secret-reader.yaml</code> and write the following content into the file:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\u200b\nkind: ClusterRole\u200b\nmetadata:\u200b\n  name: secret-reader\u200b\nrules:\u200b\n- apiGroups: [\"\"]\u200b\n  resources: [\"secrets\"]\u200b\n  verbs: [\"get\", \"watch\", \"list\"]\n</code></pre> <p>Then, create the ClusterRole using</p> <pre><code>$ kubectl create -f clusterrole-secret-reader.yaml\u200b\n</code></pre> <p>Once that's done, we can grant a user read access to most resources, and then grant them read access to secrets:</p> <pre><code>$ kubectl create namespace foo\n\n$ kubectl create rolebinding sam-view\n    --clusterrole view \\\u200b\n    --user sam \\\u200b\n    --namespace foo\n\n$ kubectl create rolebinding sam-secret-reader\n    --clusterrole secret-reader \\\u200b\n    --user sam \\\u200b\n    --namespace foo\n</code></pre>"},{"location":"topics/rbac/#example-grant-a-user-read-only-access-at-the-cluster-scope","title":"Example: Grant a user read-only access at the cluster scope","text":"<p>In certain scenarios, it may be beneficial to grant a user cluster-scope access. For example, if a user wants to run the command <code>helm list --all-namespaces</code>, the API requires the user has cluster-scope read access.</p> <p>To do that, grant the user both <code>view</code> and <code>secret-reader</code> access as described above, but with a ClusterRoleBinding.</p> <pre><code>$ kubectl create clusterrolebinding sam-view\n    --clusterrole view \\\u200b\n    --user sam\n\n$ kubectl create clusterrolebinding sam-secret-reader\n    --clusterrole secret-reader \\\u200b\n    --user sam\n</code></pre>"},{"location":"topics/rbac/#additional-thoughts","title":"Additional Thoughts","text":"<p>The examples shown above utilize the default ClusterRoles provided with Kubernetes. For more fine-grained control over what resources users are granted access to, have a look at the Kubernetes documentation on creating your own custom Roles and ClusterRoles.</p>"},{"location":"topics/registries/","title":"Use OCI-based registries","text":"<p>Beginning in Helm 3, you can use container registries with OCI support to store and share chart packages. Beginning in Helm v3.8.0, OCI support is enabled by default. </p>"},{"location":"topics/registries/#oci-support-prior-to-v380","title":"OCI support prior to v3.8.0","text":"<p>OCI support graduated from experimental to general availability with Helm v3.8.0. In prior versions of Helm, OCI support behaved differently. If you were using OCI support prior to Helm v3.8.0, its important to understand what has changed with different versions of Helm.</p>"},{"location":"topics/registries/#enabling-oci-support-prior-to-v380","title":"Enabling OCI support prior to v3.8.0","text":"<p>Prior to Helm v3.8.0, OCI support is experimental and must be enabled.</p> <p>To enable OCI experimental support for Helm versions prior to v3.8.0, set <code>HELM_EXPERIMENTAL_OCI</code> in your environment. For example:</p> <pre><code>export HELM_EXPERIMENTAL_OCI=1\n</code></pre>"},{"location":"topics/registries/#oci-feature-deprecation-and-behavior-changes-with-v380","title":"OCI feature deprecation and behavior changes with v3.8.0","text":"<p>The release of Helm v3.8.0, the following features and behaviors are different from previous versions of Helm:</p> <ul> <li>When setting a chart in the dependencies as OCI, the version can be set to a range like other dependencies.</li> <li>SemVer tags that include build information can be pushed and used. OCI registries don't support <code>+</code> as a tag character. Helm translates the <code>+</code> to <code>_</code> when stored as a tag.</li> <li>The <code>helm registry login</code> command now follows the same structure as the Docker CLI for storing credentials. The same location for registry configuration can be passed to both Helm and the Docker CLI.</li> </ul>"},{"location":"topics/registries/#oci-feature-deprecation-and-behavior-changes-with-v370","title":"OCI feature deprecation and behavior changes with v3.7.0","text":"<p>The release of Helm v3.7.0 included the implementation of HIP 6 for OCI support. As a result, the following features and behaviors are different from previous versions of Helm:</p> <ul> <li>The <code>helm chart</code> subcommand has been removed.</li> <li>The chart cache has been removed (no <code>helm chart list</code> etc.).</li> <li>OCI registry references are now always prefixed with <code>oci://</code>.</li> <li>The basename of the registry reference must always match the chart's name.</li> <li>The tag of the registry reference must always match the chart's semantic version (i.e. no <code>latest</code> tags).</li> <li>The chart layer media type was switched from <code>application/tar+gzip</code> to <code>application/vnd.cncf.helm.chart.content.v1.tar+gzip</code>.</li> </ul>"},{"location":"topics/registries/#using-an-oci-based-registry","title":"Using an OCI-based registry","text":""},{"location":"topics/registries/#helm-repositories-in-oci-based-registries","title":"Helm repositories in OCI-based registries","text":"<p>A Helm repository is a way to house and distribute packaged Helm charts. An OCI-based registry can contain zero or more Helm repositories and each of those repositories can contain zero or more packaged Helm charts.</p>"},{"location":"topics/registries/#use-hosted-registries","title":"Use hosted registries","text":"<p>There are several hosted container registries with OCI support that you can use for your Helm charts. For example:</p> <ul> <li>Amazon ECR</li> <li>Azure Container Registry</li> <li>Docker Hub</li> <li>Google Artifact Registry</li> <li>Harbor</li> <li>IBM Cloud Container Registry</li> <li>JFrog Artifactory</li> </ul> <p>Follow the hosted container registry provider's documentation to create and configure a registry with OCI support. </p> <p>Note:  You can run Docker Registry or <code>zot</code>, which are OCI-based registries, on your development computer. Running an OCI-based registry on your development computer should only be used for testing purposes.</p>"},{"location":"topics/registries/#using-sigstore-to-sign-oci-based-charts","title":"Using sigstore to sign OCI-based charts","text":"<p>The <code>helm-sigstore</code> plugin allows using Sigstore to sign Helm charts with the same tools used to sign container images.  This provides an alternative to the GPG-based provenance supported by classic chart repositories.</p> <p>For more details on using the <code>helm sigstore</code> plugin, see that project's documentation.</p>"},{"location":"topics/registries/#commands-for-working-with-registries","title":"Commands for working with registries","text":""},{"location":"topics/registries/#the-registry-subcommand","title":"The <code>registry</code> subcommand","text":""},{"location":"topics/registries/#login","title":"<code>login</code>","text":"<p>login to a registry (with manual password entry)</p> <pre><code>$ helm registry login -u myuser localhost:5000\nPassword:\nLogin succeeded\n</code></pre>"},{"location":"topics/registries/#logout","title":"<code>logout</code>","text":"<p>logout from a registry</p> <pre><code>$ helm registry logout localhost:5000\nLogout succeeded\n</code></pre>"},{"location":"topics/registries/#the-push-subcommand","title":"The <code>push</code> subcommand","text":"<p>Upload a chart to an OCI-based registry:</p> <pre><code>$ helm push mychart-0.1.0.tgz oci://localhost:5000/helm-charts\nPushed: localhost:5000/helm-charts/mychart:0.1.0\nDigest: sha256:ec5f08ee7be8b557cd1fc5ae1a0ac985e8538da7c93f51a51eff4b277509a723\n</code></pre> <p>The <code>push</code> subcommand can only be used against <code>.tgz</code> files created ahead of time using <code>helm package</code>.</p> <p>When using <code>helm push</code> to upload a chart an OCI registry, the reference must be prefixed with <code>oci://</code> and must not contain the basename or tag.</p> <p>The registry reference basename is inferred from the chart's name, and the tag is inferred from the chart's semantic version. This is currently a strict requirement.</p> <p>Certain registries require the repository and/or namespace (if specified) to be created beforehand. Otherwise, an error will be produced during the  <code>helm push</code> operation.</p> <p>If you have created a provenance file (<code>.prov</code>), and it is present next to the chart <code>.tgz</code> file, it will automatically be uploaded to the registry upon <code>push</code>. This results in an extra layer on the Helm chart manifest.</p> <p>Users of the helm-push plugin (for uploading charts to ChartMuseum) may experience issues, since the plugin conflicts with the new, built-in <code>push</code>. As of version v0.10.0, the plugin has been renamed to <code>cm-push</code>.</p>"},{"location":"topics/registries/#other-subcommands","title":"Other subcommands","text":"<p>Support for the <code>oci://</code> protocol is also available in various other subcommands. Here is a complete list:</p> <ul> <li><code>helm pull</code></li> <li><code>helm show</code></li> <li><code>helm template</code></li> <li><code>helm install</code></li> <li><code>helm upgrade</code></li> </ul> <p>The basename (chart name) of the registry reference is included for any type of action involving chart download (vs. <code>helm push</code> where it is omitted).</p> <p>Here are a few examples of using the subcommands listed above against OCI-based charts:</p> <pre><code>$ helm pull oci://localhost:5000/helm-charts/mychart --version 0.1.0\nPulled: localhost:5000/helm-charts/mychart:0.1.0\nDigest: sha256:0be7ec9fb7b962b46d81e4bb74fdcdb7089d965d3baca9f85d64948b05b402ff\n\n$ helm show all oci://localhost:5000/helm-charts/mychart --version 0.1.0\napiVersion: v2\nappVersion: 1.16.0\ndescription: A Helm chart for Kubernetes\nname: mychart\n...\n\n$ helm template myrelease oci://localhost:5000/helm-charts/mychart --version 0.1.0\n---\n# Source: mychart/templates/serviceaccount.yaml\napiVersion: v1\nkind: ServiceAccount\n...\n\n$ helm install myrelease oci://localhost:5000/helm-charts/mychart --version 0.1.0\nNAME: myrelease\nLAST DEPLOYED: Wed Oct 27 15:11:40 2021\nNAMESPACE: default\nSTATUS: deployed\nREVISION: 1\nNOTES:\n...\n\n$ helm upgrade myrelease oci://localhost:5000/helm-charts/mychart --version 0.2.0\nRelease \"myrelease\" has been upgraded. Happy Helming!\nNAME: myrelease\nLAST DEPLOYED: Wed Oct 27 15:12:05 2021\nNAMESPACE: default\nSTATUS: deployed\nREVISION: 2\nNOTES:\n...\n</code></pre>"},{"location":"topics/registries/#specifying-dependencies","title":"Specifying dependencies","text":"<p>Dependencies of a chart can be pulled from a registry using the <code>dependency update</code> subcommand.</p> <p>The <code>repository</code> for a given entry in <code>Chart.yaml</code> is specified as the registry reference without the basename:</p> <pre><code>dependencies:\n  - name: mychart\n    version: \"2.7.0\"\n    repository: \"oci://localhost:5000/myrepo\"\n</code></pre> <p>This will fetch <code>oci://localhost:5000/myrepo/mychart:2.7.0</code> when <code>dependency update</code> is executed.</p>"},{"location":"topics/registries/#helm-chart-manifest","title":"Helm chart manifest","text":"<p>Example Helm chart manifest as represented in a registry (note the <code>mediaType</code> fields):</p> <pre><code>{\n  \"schemaVersion\": 2,\n  \"config\": {\n    \"mediaType\": \"application/vnd.cncf.helm.config.v1+json\",\n    \"digest\": \"sha256:8ec7c0f2f6860037c19b54c3cfbab48d9b4b21b485a93d87b64690fdb68c2111\",\n    \"size\": 117\n  },\n  \"layers\": [\n    {\n      \"mediaType\": \"application/vnd.cncf.helm.chart.content.v1.tar+gzip\",\n      \"digest\": \"sha256:1b251d38cfe948dfc0a5745b7af5ca574ecb61e52aed10b19039db39af6e1617\",\n      \"size\": 2487\n    }\n  ]\n}\n</code></pre> <p>The following example contains a provenance file (note the extra layer):</p> <pre><code>{\n  \"schemaVersion\": 2,\n  \"config\": {\n    \"mediaType\": \"application/vnd.cncf.helm.config.v1+json\",\n    \"digest\": \"sha256:8ec7c0f2f6860037c19b54c3cfbab48d9b4b21b485a93d87b64690fdb68c2111\",\n    \"size\": 117\n  },\n  \"layers\": [\n    {\n      \"mediaType\": \"application/vnd.cncf.helm.chart.content.v1.tar+gzip\",\n      \"digest\": \"sha256:1b251d38cfe948dfc0a5745b7af5ca574ecb61e52aed10b19039db39af6e1617\",\n      \"size\": 2487\n    },\n    {\n      \"mediaType\": \"application/vnd.cncf.helm.chart.provenance.v1.prov\",\n      \"digest\": \"sha256:3e207b409db364b595ba862cdc12be96dcdad8e36c59a03b7b3b61c946a5741a\",\n      \"size\": 643\n    }\n  ]\n}\n</code></pre>"},{"location":"topics/registries/#migrating-from-chart-repos","title":"Migrating from chart repos","text":"<p>Migrating from classic chart repositories (index.yaml-based repos) is as simple using <code>helm pull</code>, then using <code>helm push</code> to upload the resulting <code>.tgz</code> files to a registry.</p>"},{"location":"topics/release_policy/","title":"Release schedule policy","text":"<p>For the benefit of its users, Helm defines and announces release dates in advance.  This document describes the policy governing Helm's release schedule.</p>"},{"location":"topics/release_policy/#release-calendar","title":"Release calendar","text":"<p>A public calendar showing the upcoming Helm releases can be found here.</p>"},{"location":"topics/release_policy/#semantic-versioning","title":"Semantic versioning","text":"<p>Helm versions are expressed as <code>x.y.z</code>, where <code>x</code> is the major version, <code>y</code> is the minor version, and <code>z</code> is the patch version, following Semantic Versioning terminology.</p>"},{"location":"topics/release_policy/#patch-releases","title":"Patch releases","text":"<p>Patch releases provide users with bug fixes and security fixes.  They do not contain new features.</p> <p>A new patch release relating to the latest minor/major release will normally be done once a month on the second Wednesday of each month.</p> <p>A patch release to fix a high priority regression or security issue can be done whenever needed.</p> <p>A patch release will be cancelled for any of the following reasons: - if there is no new content since the previous release - if the patch release date falls within one week before the first release candidate (RC1) of an upcoming minor release - if the patch release date falls within four weeks following a minor release</p>"},{"location":"topics/release_policy/#minor-releases","title":"Minor releases","text":"<p>Minor releases contain security and bug fixes as well as new features.  They are backwards compatible with respect to the API and the CLI usage.</p> <p>To align with Kubernetes releases, a minor helm release will be done every 4 months (3 releases a year).</p> <p>Extra minor releases can be done if needed but will not affect the timeline of an announced future release, unless the announced release is less than 7 days away.</p> <p>At the same time as a release is published, the date of the next minor release will be announced and posted to Helm's main web page.</p>"},{"location":"topics/release_policy/#major-releases","title":"Major releases","text":"<p>Major releases contain breaking changes.  Such releases are rare but are sometimes necessary to allow helm to continue to evolve in important new directions.</p> <p>Major releases can be difficult to plan.  With that in mind, a final release date will only be chosen and announced once the first beta version of such a release is available.</p>"},{"location":"topics/v2_v3_migration/","title":"Migrating Helm v2 to v3","text":"<p>This guide shows how to migrate  Helm v2 to v3. Helm v2 needs to be installed and managing releases in one or more clusters.</p>"},{"location":"topics/v2_v3_migration/#overview-of-helm-3-changes","title":"Overview of Helm 3 Changes","text":"<p>The full list of changes from Helm 2 to 3 are documented in the FAQ section. The following is a summary of some of those changes that a user should be aware of before and during migration:</p> <ol> <li>Removal of Tiller:</li> <li>Replaces client/server with client/library architecture (<code>helm</code> binary      only)</li> <li>Security is now on per user basis (delegated to Kubernetes user cluster      security)</li> <li>Releases are now stored as in-cluster secrets and the release object      metadata has changed</li> <li>Releases are persisted on a release namespace basis and not in the Tiller      namespace anymore</li> <li>Chart repository updated:</li> <li><code>helm search</code> now supports both local repository searches and making search      queries against Artifact Hub</li> <li>Chart apiVersion bumped to \"v2\" for following specification changes:</li> <li>Dynamically linked chart dependencies moved to <code>Chart.yaml</code>      (<code>requirements.yaml</code> removed and  requirements --&gt; dependencies)</li> <li>Library charts (helper/common charts) can now be added as dynamically      linked chart dependencies</li> <li>Charts have a <code>type</code> metadata field to define the chart to be of an      <code>application</code> or <code>library</code> chart. It is application by default which means      it is renderable and installable</li> <li>Helm 2 charts (apiVersion=v1) are still installable</li> <li>XDG directory specification added:</li> <li>Helm home removed and replaced with XDG directory specification for storing      configuration files</li> <li>No longer need to initialize Helm</li> <li><code>helm init</code> and <code>helm home</code> removed</li> <li>Additional changes:</li> <li>Helm install/set-up is simplified:<ul> <li>Helm client (helm binary) only (no Tiller)</li> <li>Run-as-is paradigm</li> </ul> </li> <li><code>local</code> or <code>stable</code> repositories are not set-up by default</li> <li><code>crd-install</code> hook removed and replaced with <code>crds</code> directory in chart      where all CRDs defined in it will be installed before any rendering of the      chart</li> <li><code>test-failure</code> hook annotation value removed, and <code>test-success</code>      deprecated. Use <code>test</code> instead</li> <li>Commands removed/replaced/added:<ul> <li>delete --&gt; uninstall : removes all release history by default      (previously needed <code>--purge</code>)</li> <li>fetch --&gt; pull</li> <li>home (removed)</li> <li>init (removed)</li> <li>install: requires release name or <code>--generate-name</code> argument</li> <li>inspect --&gt; show</li> <li>reset (removed)</li> <li>serve (removed)</li> <li>template: <code>-x</code>/<code>--execute</code> argument renamed to <code>-s</code>/<code>--show-only</code></li> <li>upgrade: Added argument <code>--history-max</code> which limits the maximum number      of revisions saved per release (0 for no limit)</li> </ul> </li> <li>Helm 3 Go library has undergone a lot of changes and is incompatible with      the Helm 2 library</li> <li>Release binaries are now hosted on <code>get.helm.sh</code></li> </ol>"},{"location":"topics/v2_v3_migration/#migration-use-cases","title":"Migration Use Cases","text":"<p>The migration use cases are as follows:</p> <ol> <li>Helm v2 and v3 managing the same cluster:</li> <li>This use case is only recommended if you intend to phase out Helm v2      gradually and do not require v3 to manage any releases deployed by v2. All      new releases being deployed should be performed by v3 and existing v2      deployed releases are updated/removed by v2 only</li> <li>Helm v2 and v3 can quite happily manage the same cluster. The Helm versions      can be installed on the same or separate systems</li> <li>If installing Helm v3 on the same system, you need to perform an additional      step to ensure that both client versions can co-exist until ready to remove      Helm v2 client. Rename or put the Helm v3 binary in a different folder to      avoid conflict</li> <li> <p>Otherwise there are no conflicts between both versions because of the      following distinctions:</p> <ul> <li>v2 and v3 release (history) storage are independent of each other. The    changes include the Kubernetes resource for storage and the release    object metadata contained in the resource. Releases will also be on a per    user namespace instead of using the Tiller namespace (for example, v2    default Tiller namespace kube-system). v2 uses \"ConfigMaps\" or \"Secrets\"    under the Tiller namespace and <code>TILLER</code>ownership. v3 uses \"Secrets\" in    the user namespace and <code>helm</code> ownership. Releases are incremental in both    v2 and v3</li> <li>The only issue could be if Kubernetes cluster scoped resources (e.g.    <code>clusterroles.rbac</code>) are defined in a chart. The v3 deployment would then    fail even if unique in the namespace as the resources would clash</li> <li>v3 configuration no longer uses <code>$HELM_HOME</code> and uses XDG directory    specification instead. It is also created on the fly as need be. It is    therefore independent of v2 configuration. This is applicable only when    both versions are installed on the same system</li> </ul> </li> <li> <p>Migrating Helm v2 to Helm v3:</p> </li> <li>This use case applies when you want Helm v3 to manage existing Helm v2      releases</li> <li>It should be noted that a Helm v2 client:<ul> <li>can manage 1 to many Kubernetes clusters</li> <li>can connect to 1 to many Tiller instances for  a cluster</li> </ul> </li> <li>This means that you have to be aware of this when migrating as releases      are deployed into clusters by Tiller and its namespace. You have to      therefore be aware of migrating for each cluster and each Tiller instance      that is managed by the Helm v2 client instance</li> <li>The recommended data migration path is as follows:<ol> <li>Backup v2 data</li> <li>Migrate Helm v2 configuration</li> <li>Migrate Helm v2 releases</li> <li>When confident that Helm v3 is managing all Helm v2 data (for all     clusters and Tiller instances of the Helm v2 client instance) as     expected, then clean up Helm v2 data</li> </ol> </li> <li>The migration process is automated by the Helm v3      2to3 plugin</li> </ol>"},{"location":"topics/v2_v3_migration/#reference","title":"Reference","text":"<ul> <li>Helm v3 2to3 plugin</li> <li>Blog post      explaining <code>2to3</code> plugin usage with examples</li> </ul>"},{"location":"topics/version_skew/","title":"Helm Version Support Policy","text":"<p>This document describes the maximum version skew supported between Helm and Kubernetes.</p>"},{"location":"topics/version_skew/#supported-versions","title":"Supported Versions","text":"<p>Helm versions are expressed as <code>x.y.z</code>, where <code>x</code> is the major version, <code>y</code> is the minor version, and <code>z</code> is the patch version, following Semantic Versioning terminology.</p> <p>The Helm project maintains a release branch for the most recent minor release. Applicable fixes, including security fixes, are cherry-picked into the release branch, depending on severity and feasibility. More details can be found in  Helm's release policy.</p>"},{"location":"topics/version_skew/#supported-version-skew","title":"Supported Version Skew","text":"<p>When a new version of Helm is released, it is compiled against a particular minor version of Kubernetes. For example, Helm 3.0.0 interacts with Kubernetes using the Kubernetes 1.16.2 client, so it is compatible with Kubernetes 1.16.</p> <p>As of Helm 3, Helm is assumed to be compatible with <code>n-3</code> versions of Kubernetes it was compiled against. Due to Kubernetes' changes between minor versions, Helm 2's support policy is slightly stricter, assuming to be compatible with <code>n-1</code> versions of Kubernetes.</p> <p>For example, if you are using a version of Helm 3 that was compiled against the Kubernetes 1.17 client APIs, then it should be safe to use with Kubernetes 1.17, 1.16, 1.15, and 1.14. If you are using a version of Helm 2 that was compiled against the Kubernetes 1.16 client APIs, then it should be safe to use with Kubernetes 1.16 and 1.15.</p> <p>It is not recommended to use Helm with a version of Kubernetes that is newer than the version it was compiled against, as Helm does not make any forward compatiblility guarantees.</p> <p>If you choose to use Helm with a version of Kubernetes that it does not support, you are using it at your own risk.</p> <p>Please refer to the table below to determine what version of Helm is compatible with your cluster.</p> Helm Version Supported Kubernetes Versions 3.17.x 1.32.x - 1.29.x 3.16.x 1.31.x - 1.28.x 3.15.x 1.30.x - 1.27.x 3.14.x 1.29.x - 1.26.x 3.13.x 1.28.x - 1.25.x 3.12.x 1.27.x - 1.24.x 3.11.x 1.26.x - 1.23.x 3.10.x 1.25.x - 1.22.x 3.9.x 1.24.x - 1.21.x 3.8.x 1.23.x - 1.20.x 3.7.x 1.22.x - 1.19.x 3.6.x 1.21.x - 1.18.x 3.5.x 1.20.x - 1.17.x 3.4.x 1.19.x - 1.16.x 3.3.x 1.18.x - 1.15.x 3.2.x 1.18.x - 1.15.x 3.1.x 1.17.x - 1.14.x 3.0.x 1.16.x - 1.13.x 2.16.x 1.16.x - 1.15.x 2.15.x 1.15.x - 1.14.x 2.14.x 1.14.x - 1.13.x 2.13.x 1.13.x - 1.12.x 2.12.x 1.12.x - 1.11.x 2.11.x 1.11.x - 1.10.x 2.10.x 1.10.x - 1.9.x 2.9.x 1.10.x - 1.9.x 2.8.x 1.9.x - 1.8.x 2.7.x 1.8.x - 1.7.x 2.6.x 1.7.x - 1.6.x 2.5.x 1.6.x - 1.5.x 2.4.x 1.6.x - 1.5.x 2.3.x 1.5.x - 1.4.x 2.2.x 1.5.x - 1.4.x 2.1.x 1.5.x - 1.4.x 2.0.x 1.4.x - 1.3.x"}]}